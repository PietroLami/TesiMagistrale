\documentclass[12pt,a4paper,openright,twoside]{report}
\usepackage[italian]{babel}
\usepackage[latin1]{inputenc}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{amsthm}
\usepackage{xcolor}
\oddsidemargin=30pt \evensidemargin=20pt%impostano i margini

\usepackage[all]{xy}
\usepackage{pdfpages}
\usepackage{titlesec}
\usepackage{fancyhdr}
\pagestyle{fancy}

\usepackage{color}



\newcommand{\id}{id}
% Terms
\newcommand{\nil}{[\:]}
\newcommand{\ol}[1]{\overline{#1}}  % sequence of objects

% New symbols:
\newcommand{\cons}{\!:\!}


% Arrows
\newcommand{\h}{\mathit{h}}
\renewcommand{\k}{\lambda}
\newcommand{\init}{\mathsf{init}}
\newcommand{\final}{\mathsf{final}}
\newcommand{\rlh}{\rightleftharpoons}
\newcommand{\lh}{\leftharpoondown}
\newcommand{\rh}{\rightharpoonup}
\newcommand{\lhh}{\leftharpoondown\hspace{-1.8ex}\leftharpoondown}
\newcommand{\rlhh}{\rightleftharpoons\hspace{-1.8ex}\rightleftharpoons}
\newcommand{\M}{\mathsf{M}}
\newcommand{\Hi}{\mathsf{H}}
\newcommand{\s}{\mathsf{S}}


\newcommand{\remark}[1]{\mbox{}\\\fbox{\begin{minipage}{.95\linewidth}
			Remark: \textsf{#1} \end{minipage}}\\}

\def \tuple#1{\langle #1 \rangle}


\usepackage{xcolor}
\newcommand{\mathcolorbox}[2]{\colorbox{#1}{$\displaystyle #2$}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand{\chaptermark}[1]{%
	\markboth{ #1}{}}

\renewcommand{\sectionmark}[1]{
	\markright{\thesection\ #1}}

\newcommand{\too}{\longrightarrow}
\newcommand{\arro}[1]{\xrightarrow{#1}} 
\newcommand{\hoo}{\hookrightarrow} 
\newcommand{\del}{\mathsf{del}}
\newcommand{\rolldel}{\mathsf{rolldel}} 
\newcommand{\comp}{\:|\:} 


\usepackage{thmtools}

\newtheorem{theorem}{Teorema}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollario}
\newtheorem{example}[theorem]{Esempio}


\newtheoremstyle{theoremdd}
  {\topsep}% measure of space to leave above the theorem. E.g.: 3pt
{\topsep}% measure of space to leave below the theorem. E.g.: 3pt
{}% name of font to use in the body of the theorem
{0pt}% measure of space to indent
{\bfseries}% name of head font
{. }% punctuation between head and body
{ }% space after theorem head; " " = normal interword space
{\thmname{#1}\thmnumber{ #2}\thmnote{ (#3)}}
\theoremstyle{theoremdd}
\newtheorem{definition}[theorem]{Definizione}

\renewcommand{\ttdefault}{cmtt}
\usepackage{url}
\usepackage{tikz}
\usepackage{diagbox}
\usepackage{multirow}



%\usepackage{ebproof}
% \usepackage{tikz} % Useless, but might be handy to draw fancier lines.
\usepackage{amssymb} % To provide the \varnothing symbol
\newcommand{\nothing}{\varnothing} % different from \emptyset
\usepackage{cancel}


\usepackage{tikz}

\newcommand{\reflect}[1]{\tikz[baseline=(h.base)]\node[xscale=-1](h){#1}; }
\usepackage{centernot}
\usepackage{stmaryrd}
\usepackage{ebproof}
% \usepackage{tikz} % Useless, but might be handy to draw fancier lines.
\usepackage{amssymb} % To provide the \varnothing symbol




\begin{document}

\tableofcontents
\thispagestyle{empty}                   %elimina il numero della pagina
\clearpage{\pagestyle{empty}\cleardoublepage}
\chapter{Introduzione}
Erlang è un linguaggio di programmazione funzionale e concorrente basato sul paradigma ad attori (concorrenza basata sul \textit{message-passing}). \\
BEAM è la macchina virtuale al centro di Erlang, fa parte dell'Erlang Run-Time System (ERTS), che compila il codice sorgente di Erlang in bytecode, che viene quindi eseguito su BEAM.
Core Erlang \cite{CoreErlang} è uno dei linguaggi intermedi in cui Erlang viene compilato.

In questa tesi si mostra un estensione della semantica descritta nell'articolo ``A theory of reversibility for Erlang'' \cite{Lanese} con delle feature imperative.

Nella Sezione \ref{sect:linguaggio} viene modificato il linguaggio presentato nell'articolo~\cite{Lanese} aggiungendo le operazione di registrazione di atomi e pid, deregistrazione di pid e di lookup, inoltre viene aggiunto un non terminale \textit{end} per poter identificare quando un processo è arrivato in uno stato finale. 

Nella Sezione \ref{sect:semantica} viene modificata la nozione di sistema data nell'articolo \cite{Lanese} in cui viene introdotta una mappa formata dalle coppie di atomi-pid che sono stati registrati. Inoltre sono state introdotte le regole per la semantica del linguaggio, in questo caso sono state aggiunte le regole per la valutazione delle nuove espressioni e inoltre sono state aggiunte le regole per descrivere il fallimento di un'espressione, che nell'articolo \cite{Lanese} non erano presenti. Inoltre sono state aggiunte le regole di sistema per le nuove espressioni e per i casi di fallimento.

Nella Sezione \ref{sect:semreversibile} viene descritta la semantica reversibile divisa in semantica \textit{forward} e \textit{backward}. La prima è un'estensione delle regole introdotte precedentemente in cui nell'articolo \cite{Lanese} viene aggiunta una storia dei processi mentre in questo lavoro è stata l'aggiunta di una storia della mappa. La semantica \textit{backward} invece descrive come viene fatto un passo all'indietro. In questo caso viene introdotta una nozione di operazione in lettura e scrittura per generalizzare le \textit{side-condition} delle regole inserite e per dare una nozione di operazione concorrente più generale. 

Nella Sezione \ref{sect:semrollback} è stato esteso l'operatore di reversibilità che può essere utilizzato per annullare le azioni di un dato processo fino a raggiungere un determinato punto di controllo, introdotto dal programmatore. Per garantire la coerenza causale, l'azione di rollback potrebbe essere propagata ad altri processi dipendenti. 

\section{Reversibilità}
Normalmente la computazione avviene in una direzione, in un programma le istruzioni vengono eseguite in un determinato ordine, per computazione reversibile ci si riferisce alla possibilità di eseguire un programma sia in avanti (o anche computazione \textit{forward}) che indietro (o anche computazione \textit{backward}).

Dato un programma non è ovvio che sia possibile eseguire una computazione backward, infatti tutti i linguaggi di programmazione tradizionali consentono operazioni con perdita di informazione. \\
Durante l'esecuzione di un programma, a meno che non sia reversibile o senza perdita di informazioni, i dati intermedi vengono persi mentre viene calcolato l'output finale.

\begin{example}
	L'assegnamento \texttt{$\mathtt{x}$ = 96}  elimina il vecchio valore di $\mathtt{x}$ che deve essere memorizzato se si vuole annullare questa assegnazione.
\end{example}

Landauer \cite{Landauer} notò anche che ogni computazione irreversibile può essere trasformata in una computazione reversibile, includendola in una computazione più ampia nella quale nessuna informazione viene persa, salvando ogni volta gli stati intermedi della computazione così da non avere perdita di informazione.\\
L'idea alla base di questo lavoro \cite{Landauer} è che qualsiasi linguaggio di programmazione o formalismo può essere reso reversibile aggiungendo la cronologia del calcolo a ogni stato, questo metodo è di solito chiamato incorporamento di Landauer.

Questa idea fu ulteriormente migliorata da Bennett \cite{Bennett} al fine di evitare la generazione di dati ``spazzatura'', applicando una serie di analisi al fine di limitare il più possibile le informazioni richieste nella storia.

La reversibilità in un contesto sequenziale è facile da capire, per invertire l'esecuzione di un programma sequenziale è sufficiente annullare ricorsivamente l'ultima azione eseguita dal programma. La definizione di reversibilità in un contesto in cui vengono considerati anche i sistemi distribuiti è più complicata, poiché non esiste il concetto di ``ultima azione'', dato che, molte azioni vengono eseguite contemporaneamente.

Una definizione adeguata di reversibilità in uno scenario concorrente è stata proposta da Danos e Krivine nel loro articolo \cite{Danos}. Intuitivamente, la definizione afferma che qualsiasi azione può essere annullata a condizione che tutte le sue eventuali conseguenze siano annullate preventivamente.

Il calcolo reversibile potrebbe essere applicato per migliorare il modo in cui alcune attività vengono risolte, per esempio nel debug.

\section{Debugger reversibile}

I Debugger non sono altro che programmi, che consento di analizzare se un programma è sintatticamente corretto, in modo tale da effettuare una ricerca del bug in modo più veloce e accurato possibile. Grazie ai Debugger si ha la possibilità di scovare errori o malfunzionamenti all'interno del programma sfruttando funzioni specifiche per il debugging: l'attività che consiste proprio nell'individuazione della porzione di software affetta da bug.

Generalmente il tipo di debugger più utilizzato è il debugger a runtime che consente la ricerca dei bug tramite funzionalità standard come \textit{breackpoint}, \textit{controlpoint} e \textit{viste da watch}, che consentono al programmatore di analizzare più accuratamente determinate parti di codice per identificare gli errori con una scansione in avanti del codice.

Di contro però, la maggior parte dei debugger fornisce (infatti), un'assistenza limitata all'esecuzione in avanti del codice per la navigazione temporale, per cui i programmatori devono spesso ricorrere alla simulazione dell'esecuzione del programma mentalmente per cercare di immaginare i flussi di istruzioni che vengono eseguiti. Infatti, con un debugger a \textit{runtime}, il programmatore può cercare il bug inserendo dei breackpoint all'interno dei thread e sperare di scovare il bug facendo dei tentativi, magari entrando in watch per osservare come vengono modificate le variabili durante l'esecuzione del programma. A tal proposito sono nati anche debug più complessi i cosidetti: debugger reversibili che a differenza dei debugger tradizionali, consentono agli sviluppatori di registrare le attività del programma in esecuzione, per poi riavvolgere e riprodurre tali istruzioni, compresi eventuali errori, per ispezionare lo stato del programma, questi debugger sono molto utili negli scenari concorrenti \cite{Engblom}.\\
Riavvolgere le azioni di un particolare processo significa anche annullare ogni conseguenza dell'operazione (cioè  tutte le azioni ``collegate'' a quell'operazione) che si vuole annullare. Questa nozione è chiamata \textit{consistenza causale} \cite{Danos}.

\clearpage{\pagestyle{empty}\cleardoublepage}
\chapter{Estensione con feature imperative}

Nel seguito di questo capitolo, verrà presentata la sintassi del linguaggio esteso supportato, seguita dalla semantica (reversibile).
In contrasto con la semantica descritta nell'articolo ``A theory of reversibility for Erlang'' \cite{Lanese} quella che verrà presentata qui includerà funzioni imperative integrate.
Le modifiche effettuate all'articolo \cite{Lanese} sono evidenziate in giallo.

\section{Sintassi del linguaggio}\label{sect:linguaggio}
In questa sezione, verrà mostrata la sintassi di un linguaggio funzionale di prim'ordine, concorrente e distribuito basato sul paradigma ad attori utilizzato. Questo linguaggio è un sotto insieme di Core Erlang \cite{CoreErlang}, che è uno dei linguaggi intermedi in cui un programma Erlang viene compilato.
\begin{figure}[ht]
	\begin{center}
		$
		\begin{array}{rcl@{~~~~~~}l}
			
			\mathit{module} & ::= & \mathsf{module} ~ Atom = %%[fname_1,\ldots,fname_n] =
			\mathit{fun}_1~\ldots~\mathit{fun}_n\\
			{\mathit{fun}} & ::= & \mathit{fname} = \mathsf{fun}~(\mathit{Var}_1,\ldots,\mathit{Var}_n) \to expr \\
			{\mathit{fname}} & ::= & Atom/\mathit{Integer} \\
			lit & ::= & Atom \mid \mathit{Integer} \mid \mathit{Float} \mid
			\mathit{Pid} \mid \nil \\
			expr & ::= & \mathit{Var}  \mid \mathit{fname} \mid [expr_1|expr_2]
			\mid   \{expr_1,\ldots,expr_n\} \\
			& \mid & \mathsf{call}~Op~(expr_1,\ldots,expr_n) 
			\mid \mathsf{apply}~\mathit{fname}~(expr_1,\ldots,expr_n) \\
			& \mid &
			\mathsf{case}~expr~\mathsf{of}~clause_1;\ldots;clause_m~\mathsf{end}\\
			& \mid & \mathsf{let}~\mathit{Var}=expr_1~\mathsf{in}~expr_2 
			\mid \mathsf{receive}~clause_1;\ldots;clause_n~\mathsf{end}\\
			& \mid & \mathsf{spawn}(\mathit{fname},[expr_1,\ldots,expr_n])  
			\mid expr \:!\: expr \mid \mathsf{self}()\\
			& \mid &   \mathcolorbox{yellow}{ \mathsf{register}(expr, expr)} \mid    \mathcolorbox{yellow}{ \mathsf{unregister}(expr)}  \mid \mathcolorbox{yellow}{end} \\
			clause & ::= & pat ~\mathsf{when}~expr_1 \to expr_2
			\\
			pat & ::= & \mathit{Var} \mid lit \mid [pat_1|pat_2] \mid
			\{pat_1,\ldots,pat_n\} \\
			Op & ::= & \dots \mid \mathcolorbox{yellow} { \mathsf{whereis}} \mid \mathcolorbox{yellow} {\mathsf{registered}}\\
			\mathcolorbox{yellow}{end} & ::= & lit \mid [end_1|end_2] \mid
			\{end_1,\ldots,end_n\} 
		\end{array}
		$
	\end{center}
	\caption{Regole di sintassi del linguaggio} \label{ErlangSyntax}
\end{figure}
\newline
\newline
Nella Figura~\ref{ErlangSyntax} viene presentata la sintassi del linguaggio, si può notare che vengono considerate solo espressioni di prim'ordine quindi il primo argomento delle applicazioni di funzioni e della spawn è un nome di funzione (invece che un'espressione o chiusura arbitraria) e il primo argomento nelle chiamate è un'operazione built-in $Op$. Rispetto alla sintassi precedente sono state aggiunte le funzioni built-in: 
\begin{itemize}
	\item $\mathsf{whereis}$ che dato in input un atomo restituisce il pid associato, se non è registrato l'atomo \textbf{undefined};
	\item $\mathsf{registered}$ che restituisce una lista di tutti gli atomi nella mappa, se non sono presenti atomi registrati restituisce una lista vuota;
\end{itemize}
sono anche state aggiunte le funzioni:
\begin{itemize}
	\item $\mathsf{register}$ che dati in input un atomo e un pid inserisce la in una mappa la coppia atomo,pid e restituisce l'atomo \textbf{true}. Altrimenti se l'atomo o il pid sono già presenti nella mappa il processo fallisce;
	\item $\mathsf{unregister}$ che dato in input un atomo toglie dalla mappa la coppia atomo, pid e restituisce l'atomo \textbf{true}. Altrimenti se l'atomo non è presente nella mappa il processo fallisce.
\end{itemize}
Inoltre è stato creato il non terminale \textit{end} per riuscire a determinare quando un processo è in uno stato finale, così è possibile determinare se un processo è fallito. In questo modo si è riusciti ad avere un comportamento il più fedele possibile a quello di Erlang nel caso delle funzioni aggiunte. Nelle regole che verranno descritte successivamente il simbolo $\epsilon$ rappresenterà un non terminale \textit{end}. 

\section{Semantica del linguaggio}\label{sect:semantica}
In questa sezione descriveremo formalmente la semantica del linguaggio presentato nella sezione \ref{sect:linguaggio}.

\begin{definition} [Processo]
	Un processo è indicato da una tupla $\tuple {p, (\theta, e), q}$ dove $p$ è il pid del processo (ed è unico), $(\theta, e)$ è il controllo, che consiste di un ambiente (una sostituzione) e di un'espressione da valutare, e $q$ è la casella di posta del processo, una coda FIFO con la sequenza di messaggi che sono stati inviati al processo.
	
	Consideriamo le seguenti operazioni sulle cassette postali locali. Dato un messaggio $v$ e una casella di posta locale $q$, $v:q$ denota una nuova casella di posta con il messaggio $v$ sopra (cioè $v$ è il messaggio più recente). Indichiamo anche con $q \backslash\! \! \backslash v$ una nuova coda che risulta da $q$ rimuovendo l'occorrenza più vecchia del messaggio $v$ (che non è necessariamente il messaggio più vecchio nel
	coda). \qed
\end{definition}
%
Un \emph{sistema} in esecuzione può quindi essere visto come un insieme di processi, che definiamo formalmente come segue:

\begin{definition} [Sistema] \label{sistema}
	Un sistema è indicato da $\Gamma;\Pi;\M$, dove $\Gamma$, la \emph{casella di posta globale}, è un insieme di coppie nella forma $(destinazione,$ $messaggio)$ e $\Pi$ è un insieme di processi, indicato da un'espressione della forma
	\[
	\tuple{p_1, (\theta_1, e_1), q_1} ~ \comp \cdots
	\comp ~ \tuple {p_n, (\theta_n, e_n), q_n}
	\]
	dove `` $\comp$ '' denota un operatore associativo e commutativo.
	%
	Data una casella di posta globale $\Gamma $, $\Gamma \cup \{(p, v) \} $ denota una nuova casella di posta che include anche la coppia $(p, v)$, usiamo ``$\cup$'' come unione multiset.
	Spesso denotiamo un sistema con un'espressione nella forma $\Gamma;\tuple{p,(\theta, e),q}\comp \Pi;\M$ per far notare che $ \tuple {p, (\theta, e), q} $ è un processo arbitrario del pool (grazie al fatto che `` $\comp $ '' è associativo e commutativo).
	Infine $\M$ rappresenta l'insieme delle coppie $(atomo,pid)$ registrate, indicheremo con ``$\cup$'' l'aggiunta di una coppia alla mappa e con ``$\backslash\! \! \backslash$'' la rimozione di una coppia dalla mappa.\qed 
\end{definition}
%
Intuitivamente, $\Gamma$ memorizza i messaggi dopo che sono stati inviati e prima che vengano inseriti nella casella di destinazione, quindi rappresenta i messaggi che si trovano nella rete.
\newline

La semantica è definita tramite due relazione di transizione: $\too$ per le espressioni e $\hoo$ per il sistema. Mostreremo prima la relazione di transizione etichettata 
\[
\too\; : (Env,Exp)\times Label\times(Env,Exp)
\]
dove $Env$ e $Exp$ rappresentano rispettivamente l'ambiente (cioè le sostituzioni) e le espressioni mentre $Label$ denota un elemento dell'insieme
\[
\begin{array}{l}
	\hspace{-11ex}
	\{\tau, \mathsf{send}(v_1,v_2),
	\mathsf{rec}(\kappa,\ol{cl_n}), \mathsf{spawn}(\kappa,a/n,[\ol{v_n}]),
	\mathsf{self}(\kappa),
	\mathsf{register}(\kappa,a,p),
	\mathsf{unregister}(\kappa,a),
	\tau \M\M',
	\bot
	\}
\end{array}
\]
Verrà utilizzato $\ell$ per indicare un'etichetta fra quelle appena indicate.\\ Per chiarezza le regole di transizione della semantica verranno divise in quattro insiemi: quelle per le espressioni sequenziali sono raffigurate nella Figura~\ref{fig:seq-rules}, quelle per i fallimenti delle espressioni sequenziali che si trovano nella Figura~\ref{fig:seq-rules-fail}, quelle per le espressioni concorrenti sono nella Figura~\ref{fig:concurrent-rules} e infine quelle per i fallimenti delle espressioni concorrenti che sono nella Figura~\ref{fig:concurrent-rules-fail}.

\begin{figure}[h]
	\footnotesize
	\[
	\begin{array}{c}
		(\mathit{Var}) ~ {\displaystyle \frac{}{\theta,X
				\arro{\tau} \theta,\theta(X)}} 
		
		\hspace{2ex}
		
		(\mathit{Tuple}) ~ {\displaystyle 
			\frac{\theta,e_i \arro{\ell}
				\theta',e'_i}{\theta,\{\ol{v_{1,{i-1}}},e_i,\ol{e_{{i+1},n}}\}
				\arro{\ell} \theta',
				\{\ol{v_{1,{i-1}}},e'_i,\ol{e_{{i+1},n}}\}}}\\[4ex] 
		
		(\mathit{List1})  ~{\displaystyle 
			\frac{\theta,e_1 \arro{\ell}
				\theta',e'_1}{\theta,[e_1|e_2]
				\arro{\ell} \theta',
				[e'_1|e_2]}} 
		
		\hspace{2ex}
		
		(\mathit{List2}) ~ {\displaystyle 
			\frac{\theta,e_2 \arro{\ell}
				\theta',e'_2}{\theta,[v_1|e_2]
				\arro{\ell} \theta',
				[v_1|e'_2]}} \\[4ex]
		
		(\mathit{Let1}) ~ {\displaystyle \frac{\theta,e_1
				\arro{\ell} \theta',e'_1 }{\theta,\mathsf{let}~ 
				X=e_1~\mathsf{in}~e_2
				\arro{\ell} \theta',\mathsf{let}~ 
				X=e'_1~\mathsf{in}~e_2}}
		
		\hspace{1ex}
		
		(\mathit{Let2}) ~ {\displaystyle \frac{}{\theta,\mathsf{let}~ 
				X=v~\mathsf{in}~e
				\arro{\tau} \theta[X\mapsto v],e}} \\[4ex]
		
		(\mathit{Case1}) ~ {\displaystyle
			\frac{\theta,e\arro{\ell}
				\theta',e'}{\begin{array}{l}
					\theta,\mathsf{case}~e~\mathsf{of}~cl_1;\ldots;cl_n~\mathsf{end}
					\arro{\ell}
					\theta',\mathsf{case}~e'~\mathsf{of}~cl_1;\ldots;cl_n~\mathsf{end}\\
		\end{array}}}\\[4ex]
		
		(\mathit{Case2}) ~ {\displaystyle
			\frac{\mathsf{match}(\theta,v,cl_1,\ldots,cl_n) = \tuple{\theta_i,e_i}}{\theta,\mathsf{case}~v~\mathsf{of}~cl_1;\ldots;cl_n~\mathsf{end}
				\arro{\tau} \theta\theta_i,e_i}} \\[4ex]
		
		(\mathit{Call1}) ~ {\displaystyle
			\frac{\theta,e_i\arro{\ell}
				\theta',e'_i~~~i\in\{1,\ldots,n\}}{\theta,\mathsf{call}~op~(\ol{v_{1,i-1}},e_i,\ol{e_{i+1,n}})
				\arro{\ell}
				\theta',\mathsf{call}~op~(\ol{v_{1,i-1}},e'_i,\ol{e_{i+1,n}})}} \\[5ex]
		
		(\mathit{Call2}) ~ {\displaystyle
			\frac{\mathsf{eval}(op,v_1,\ldots,v_n)=v}{\theta,\mathsf{call}~op~(v_1,\ldots,v_n)
				\arro{\tau} \theta,v}} \\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{Call3}) ~ {\displaystyle
				\frac{\mathsf{evalM}(\M,op,v_1,\ldots,v_n)= (v,\M') }{\theta,\mathsf{call}~op~(v_1,\ldots,v_n)
					\arro{\tau\M\M'} \theta,v}} }\\[4ex]
		
		(\mathit{Apply1}) ~ {\displaystyle
			\frac{\theta,e_i\arro{\ell}
				\theta',e'_i~~~i\in\{1,\ldots,n\}}{\theta,\mathsf{apply}~a/n~(\ol{v_{1,i-1}},e_i,\ol{e_{i+1,n}}) 
				\arro{\ell}
				\theta',\mathsf{apply}~a/n~(\ol{v_{1,i-1}},e'_i,\ol{e_{i+1,n}})}}\\[5ex] 
		
		(\mathit{Apply2}) ~ {\displaystyle
			\frac{\mu(a/n) = \mathsf{fun}~(X_1,\ldots,X_n)\to e}{\theta,\mathsf{apply}~a/n~(v_1,\ldots,v_n)
				\arro{\tau} \theta\cup\{X_1\mapsto v_1,\ldots,X_n\mapsto v_n\},e}} %\{\ol{X_n\mapsto v_n}\},e}} 
	\end{array}
	\]
	\caption{Semantica standard: valutazione espressioni sequenziali} \label{fig:seq-rules}
\end{figure}

Le transizioni sono etichettate con $ \tau$ (una riduzione sequenziale senza side-effects), o con $\tau\M\M'$ che indica una riduzione che accede alla mappa senza side-effects, o con l'etichetta $\bot$ che indica la propagazione di un fallimento, o con un'etichetta che identifica la riduzione di un'azione con alcuni side-effects. Le etichette sono usate nelle regole di sistema (Figure~\ref {fig:system-rules}, \ref{fig:system-rules-map}) per determinare gli effetti collaterali associati e/o le informazioni da recuperare.
\newline
Nella Figura~\ref{fig:seq-rules} sono presenti le regole di transizione per la valutazione delle espressioni sequenziali.
\newline
Come in Erlang, consideriamo che l'ordine di valutazione degli argomenti in una tupla, lista, ecc. È fisso da sinistra a destra.
\newline
Per la valutazione dei case, si assume una funzione ausiliaria $\mathsf{match}$ che seleziona la prima clausola, $cl_i = (pat_i ~\mathsf{when} ~ e'_i \to e_i)$, in modo tale che $v$ corrisponda a $pat_i$, ovvero $ v = \theta_i (pat_i)$, e che la guardia sia soddisfatta, cioè, $\theta \theta_i, e'_i \too^\ast \theta ', true$. Come in Core Erlang, assumiamo che i patterns possano solo contenere nuove variabili (ma le guardie potrebbero avere variabili legate, quindi passiamo l'ambiente corrente $ \theta $ alla funzione $ \mathsf {match} $).
\newline
Le funzioni possono essere definite nel programma (in questo caso sono invocate da $\mathsf {apply}$) o essere un built-in (invocate da $\mathsf{call}$). In quest'ultimo caso vengono valutati utilizzando la funzione ausiliaria $\mathsf {eval}$.
\newline
Nella regola $\mathit {Apply2}$, si considera che la mappatura $\mu$ memorizza tutte le definizioni di funzione nel programma, cioè, mappa ogni nome di funzione $ a/n $ in una copia della sua definizione $\mathsf{fun} ~ (X_1, \ldots, X_n) \to e$, dove $ X_1, \ldots, X_n $ sono nuove variabili (distinte) e sono le uniche variabili che possono essere libere in $e$.
%
Per quanto riguarda le applicazioni, si noti che consideriamo solo il primo ordine funzioni. Per estendere la nostra semantica a considerare anche funzioni di ordine superiore, si dovrebbe ridurre il nome della funzione a \emph {chiusura} della forma $ (\theta ', \mathsf {fun} ~ (X_1, \ldots, X_n) \to e) $. 
\newline
Alle regole della semantica standard delle espressi sequenziali è stata aggiunta la regola $Call3$ utilizzata per la valutazione delle funzioni built-in che devono accedere alla mappa. Le funzioni built-in come si può vedere dalla regola $Call2$ vengono valutate tramite la funzione ausiliaria $\mathsf{eval}$, per questo motivo si è scelto di utilizzare la funzione ausiliaria $\mathsf{evalM}$ per valutare le funzioni built-in che utilizzano una mappa. Infatti per la valutazione $\mathsf{evalM}$ oltre a prendere in input i parametri prende in input pure la mappa, indicata con $\M$.
La funzione $\mathsf{evalM}$ e la funzione $\mathsf{eval}$ sono quindi sono due funzioni parziali visto che non è definito l'output per ogni input. $\mathsf{M'}$ corrisponde alla parte della mappa acceduta dalla funzione $\mathsf{evalM}$.
\newpage
\begin{figure}[h]
	\footnotesize
	\[
	\begin{array}{c}
		\mathcolorbox{yellow}{ (\mathit{TupleF}) ~ {\displaystyle 
				\frac{\theta,e_i \arro{\bot} fail
				}{\theta,\{\ol{v_{1,{i-1}}},e_i,\ol{e_{{i+1},n}}\}
					\arro{\bot} fail
		}}}\\[4ex] 
		
		\mathcolorbox{yellow}{(\mathit{List1F})  ~{\displaystyle 
				\frac{\theta,e_1 \arro{\bot} fail}
				{\theta,[e_1|e_2] \arro{\bot} fail}} 
			
			\hspace{2ex}
			
			(\mathit{List2F}) ~ {\displaystyle 
				\frac{\theta,e_2 \arro{\bot} fail }
				{\theta,[v_1|e_2]\arro{\bot} fail }} }\\[4ex]
		
		\mathcolorbox{yellow}{ (\mathit{Let1F}) ~ {\displaystyle \frac{\theta,e_1
					\arro{\bot} fail }{\theta,\mathsf{let}~ 
					X=e_1~\mathsf{in}~e_2
					\arro{\bot} fail}}} \\[4ex]
		
		\mathcolorbox{yellow}{ (\mathit{Case1F}) ~ {\displaystyle
				\frac{\theta,e\arro{\bot} fail
				}{\begin{array}{l}
						\theta,\mathsf{case}~e~\mathsf{of}~cl_1;\ldots;cl_n~\mathsf{end}
						\arro{\bot} fail
						
		\end{array}}}}\\[4ex]
		
		\mathcolorbox{yellow}{ (\mathit{Case2F}) ~ {\displaystyle
				\frac{\mathsf{match}(\theta,v,cl_1,\ldots,cl_n) = \emptyset }{\theta,\mathsf{case}~v~\mathsf{of}~cl_1;\ldots;cl_n~\mathsf{end}
					\arro{\bot} caseFail}}} \\[4ex]
		
		\mathcolorbox{yellow}{ (\mathit{Call1F}) ~ {\displaystyle
				\frac{\theta,e_i\arro{\bot} fail}
				{\theta,\mathsf{call}~op~(\ol{v_{1,i-1}},e_i,\ol{e_{i+1,n}})
					\arro{\bot } fail
		}}} \\[5ex]
		
		\mathcolorbox{yellow}{ (\mathit{Call2F}) ~ {\displaystyle
				\frac{\mathsf{eval}(op,v_1,\ldots,v_n) = \emptyset ~\land~ \mathsf{evalM}(\M,op,v_1,\ldots,v_n) = \emptyset  }{\theta,\mathsf{call }~ op (v_1,\dots,v_n)
					\arro{\bot} callFail}} }\\[4ex]

		\mathcolorbox{yellow}{ (\mathit{Apply1F}) ~ {\displaystyle
				\frac{\theta,e_i\arro{\bot} fail }
				{\theta,\mathsf{apply}~a/n~(\ol{v_{1,i-1}},e_i,\ol{e_{i+1,n}}) 
					\arro{\bot} fail
		}} }\\[5ex] 
		
		\mathcolorbox{yellow}{(\mathit{Apply2F}) ~ {\displaystyle
				\frac{\mu(a/n) = \emptyset }{\theta,\mathsf{apply}~a/n~(v_1,\ldots,v_n)
					\arro{\bot} applyFail}} }
		\end{array}
	\]
	\caption{Semantica standard: valutazione del fallimento delle espressioni sequenziali} \label{fig:seq-rules-fail}
\end{figure}
Nella Figura~\ref{fig:seq-rules-fail} sono presenti le regole di transizione che gestiscono i fallimenti.
La propagazione dell'errore è indicata dall'etichetta $\bot$, quindi se una valutazione di un'espressione fallisce allora il fallimento viene propagato. \\
Con il simbolo $\emptyset$ si intende: 
\begin{itemize}
	\item nel caso dei match, che l'argomento $v$ non corrisponde a nessuna clausola\footnote {Più precisamente in un programma Erlang quando è tradotto nella rappresentazione intermedia Core Erlang, viene aggiunta una clausola catch-all quindi il simbolo $\emptyset$ corrisponde al match della clausola aggiunta.};
	\item nei casi di eval, evalM e $\mu$ significa che le funzioni non sono definite sull'input dato.
\end{itemize}
\begin{figure}[h]
	\footnotesize
	\[
	\begin{array}{c}
		(\mathit{Send1}) ~ {\displaystyle 
			\frac{\theta,e_1 \arro{\ell} \theta',e'_1}{\theta,e_1\:!\: e_2 \arro{\ell}
				\theta',e'_1\:!\: e_2} ~~~~(\mathit{Send2}) ~\frac{\theta,e_2 \arro{\ell} \theta',e'_2}{\theta,v_1\:!\: e_2 \arro{\ell}
				\theta',v_1\:!\: e'_2} 
		}\\[4ex]
		
		(\mathit{Send3}) ~ {\displaystyle
			\frac{  }{\theta,v_1\:!\: v_2 \arro{\mathsf{send}(v_1,v_2)} \theta,v_2}
		}\\[4ex]
		
		(\mathit{Receive}) ~ {\displaystyle
			\frac{~}{\theta,\mathsf{receive}~cl_1;\ldots;cl_n~\mathsf{end}
				\arro{\mathsf{rec}(\kappa,\ol{cl_n})}
				\theta,\kappa
			}
		}\\[4ex]
		
		(\mathit{Spawn1}) ~ {\displaystyle
			\frac{\theta,e_i\arro{\ell}
				\theta',e'_i~~~i\in\{1,\ldots,n\}}{\theta,\mathsf{spawn}(a/n,[\ol{v_{1,i-1}},e_i,\ol{e_{i+1,n}}])
				\arro{\ell} \theta',\mathsf{spawn}(a/n,[\ol{v_{1,i-1}},e'_i,\ol{e_{i+1,n}}])       
		}}\\[4ex]
		
		(\mathit{Spawn2}) ~ {\displaystyle
			\frac{}{\theta,\mathsf{spawn}(a/n,[\ol{v_n}])
				\arro{\mathsf{spawn}(\kappa,a/n,[\ol{v_n}])} \theta,\kappa         
		}}\\[4ex]
		
		(\mathit{Self}) ~ {\displaystyle
			\frac{}{\theta,\mathsf{self}() \arro{\mathsf{self}(\kappa)} \theta,\kappa}}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{Register1}) ~ {\displaystyle 
				\frac{\theta, e_1 \arro{\ell} \theta',e'_1}{\theta, \mathsf{register}(e_1, e_2) \arro{\ell}
					\theta',\mathsf{register}(e'_1, e_2)} ~~~~
		}}\\[4ex]
		
		\mathcolorbox{yellow}{  (\mathit{Register2}) ~{\displaystyle
				\frac{\theta,e_2 \arro{\ell} \theta',e'_2}{\theta,\mathsf{register}(v_1, e_2) \arro{\ell}
					\theta',\mathsf{register}(v_1, e'_2)} 
		}}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{Register3}) ~ {\displaystyle
				\frac{~}{\theta,\mathsf{register}(v_1, v_2) \arro{\mathsf{register}(\kappa,v_1,v_2)} \theta,\kappa}}
		}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{Unregister1}) ~ {\displaystyle 
				\frac{\theta, e \arro{\ell} \theta',e'}{\theta, \mathsf{unregister}(e) \arro{\ell}
					\theta',\mathsf{unregister}(e')}}}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{Unregister2}) ~ {\displaystyle
				\frac{~}{\theta,\mathsf{unregister}(v) \arro{\mathsf{unregister}(\kappa,v)} \theta,\kappa}}
		}
	\end{array}
	\]
	\caption{Semantica standard: valutazione delle espressioni concorrenti} \label{fig:concurrent-rules}
\end{figure}

Consideriamo ora la valutazione di espressioni concorrenti che producono side-effects (Figura~\ref{fig:concurrent-rules}). Abbiamo le regole $\mathit{Send1}$, $\mathit {Send2}$ e $\mathit{Send3}$ per `` $! $ ''. In questo caso sappiamo \emph{localmente} a cosa dovrebbe essere ridotta l'espressione (cioè $ v_2 $ nella regola $\mathit {Send3}$). Per le restanti regole, questo non è noto localmente e, quindi, restituiamo un nuovo simbolo distinto, $\kappa $,  che viene trattato come una variabile, in modo che nelle regole di sistema nella figure~\ref{fig:system-rules}, \ref{fig:system-rules-map} $\kappa$ legherà al suo valore corretto:\footnote {Nota che $\kappa$ assume valori nel dominio $expr \cup Pid $, al contrario delle variabili ordinarie che possono essere associate solo a valori.} l'espressione selezionata nella regola $\mathit {Ricevive} $, un pid nelle regole $\mathit {Spawn}$ e $\mathit{Self}$ e \textbf{true} o \textbf{false} nelle regole $\mathit{Register}$ e $\mathit{Unregister}$. In questi casi, l'etichetta della transizione contiene tutte le informazioni necessarie alle regole di sistema per eseguire la valutazione a livello di sistema, incluso il simbolo $\kappa$. Questo \emph{trucco} ci permette di mantenere separate le regole per espressioni e sistemi (cioè, la semantica mostrata nelle Figura~\ref {fig:seq-rules} e \ref{fig:concurrent-rules} è per lo più indipendente dalle regole nelle Figure~\ref{fig:system-rules}, \ref{fig:system-rules-map}), in contrasto con altre semantiche di Erlang, ad esempio \cite{CMRT13tr}, dove sono combinate in una singola relazione di transizione.
Nelle regole di valutazione delle espressioni concorrenti della semantica standard sono state aggiunte le regole per la valutazione della $\mathsf{register}$ e dell'$\mathsf{unregister}$.

\begin{figure}[h]
	\footnotesize
	\[
	\begin{array}{c}	
		\mathcolorbox{yellow}{ (\mathit{Send1F}) ~ {\displaystyle 
				\frac{\theta,e_1 \arro{\bot} fail}
				{\theta,e_1\:!\: e_2 \arro{\bot} fail} ~~~~
				
				(\mathit{Send2F}) ~\frac{\theta,e_2 \arro{\bot} fail}
				{\theta,v_1\:!\: e_2 \arro{\bot} fail} 
		}}\\[4ex]
		
		\mathcolorbox{yellow}{ (\mathit{Spawn1F}) ~ {\displaystyle
				\frac{\theta,e_i\arro{\bot} fail}
				{\theta,\mathsf{spawn}(a/n,[\ol{v_{1,i-1}},e_i,\ol{e_{i+1,n}}])
					\arro{\bot} fail         
		}}}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{Register1F}) ~ {\displaystyle 
				\frac{\theta, e_1 \arro{\bot} fail}
				{\theta, \mathsf{register}(e_1, e_2) \arro{\bot} fail} ~~~~
			
				(\mathit{Register2F}) ~\frac{\theta,e_2 \arro{\bot} fail}
				{\theta,\mathsf{register}(v_1, e_2) \arro{\bot } fail} 
		}}\\[4ex]
		
		\mathcolorbox{yellow}{ (\mathit{Unregister1F}) ~ {\displaystyle 
				\frac{\theta, e \arro{\bot} fail}
				{\theta, \mathsf{unregister}(e) \arro{\bot} fail }}}
	\end{array}
	\]
	\caption{Semantica standard: valutazione del fallimento delle espressioni concorrenti} \label{fig:concurrent-rules-fail}
\end{figure}
~\newline
Anche nelle regole della valutazione delle espressioni concorrenti sono state aggiunte le regole che gestiscono il fallimento di un processo e che propagano il fallimento della valutazione di un'espressione.
\newline
Ora si possono presentare le regole di sistema che sono rappresentate nelle figure~\ref{fig:system-rules} e \ref{fig:system-rules-map}, in tutte le regole viene considerato un sistema generale nella forma $\Gamma;\tuple{p,(\theta,e),q}\:\comp\: \Pi;\M$ dove $\Gamma$ è la casella di posta globale, $\tuple{p,(\theta,e),q}\:\comp\: \Pi$ è l'insieme dei processi che contiene almeno un processo e $\M$ è la mappa dei pid registrati. Rispetto all'articolo \cite{Lanese} in tutte le regole è stata aggiunta $\M$ visto che la definizione di sistema (Definizione~\ref{sistema}) è cambiata.\\
Ora verranno descritte brevemente tutte le regole di transizione del sistema. 
\begin{figure}[th]
	\footnotesize
	\[
	\begin{array}{c}
		(\mathit{Seq}) ~ {\displaystyle
			\frac{\theta,e\arro{\tau} \theta',e'
			}{\Gamma;\tuple{p,(\theta,e),q}\comp \Pi; \mathcolorbox{yellow}{\M} \hoo
				\Gamma;\tuple{p,(\theta',e'),q}\comp \Pi; \mathcolorbox{yellow}{\M}}
		}\\[4ex]
		
		\mathcolorbox{yellow}{\mathit{(Call3)} ~ {\displaystyle
				\frac{\theta,e\arro{\tau\M\M'} \theta',e'
				}{\Gamma;\tuple{p,(\theta,e),q}\comp \Pi; \M \hoo
					\Gamma;\tuple{p,(\theta',e'),q}\comp \Pi; \M}
		}}\\[4ex]
		
		(\mathit{Send}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{send}(p'',v)}
				\theta',e'  ~~~ \mathcolorbox{yellow}{\mathsf{isAtom}(p'')=false }
			}{\Gamma;\tuple{p,(\theta,e),q} 
				\comp \Pi; \mathcolorbox{yellow}{\M} \hoo \Gamma\cup (p'',v);\tuple{p,(\theta',e'),q}\comp \Pi; \mathcolorbox{yellow}{\M}}
		}\\[4ex]
		
		\mathcolorbox{yellow}{  (\mathit{SendA}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{send}(a,v)}
					\theta',e'  ~~~ \mathsf{isAtom}(a)=true ~~ \mathsf{matchPid}(\M, a) = p''
				}{\Gamma;\tuple{p,(\theta,e),q} 
					\comp \Pi;\M \hoo \Gamma\cup (p'',v);\tuple{p,(\theta',e'),q}\comp \Pi;\M}
		}}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{SendF}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{send}(a,v)}
					\theta',e'  ~~~ \mathsf{isAtom}(a)=true ~~\mathsf{matchPid}(\M, a) = false
				}{\Gamma;\tuple{p,(\theta,e),q} 
					\comp \Pi; \mathcolorbox{yellow}{\M} \hoo \Gamma;\tuple{p,(\theta,sendFail),q}\comp \Pi; {\M}}
		}}\\[4ex]
		
		(\mathit{Receive}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{rec}(\kappa,\ol{cl_n})}
				\theta',e'~~~ \mathsf{matchrec}(\theta,\ol{cl_n},q) =
				(\theta_i,e_i,v)} {\Gamma;\tuple{p,(\theta,e),q}\comp \Pi; \mathcolorbox{yellow}{\M} \hoo
				\Gamma;\tuple{p,(\theta'\theta_i,e'\{\kappa\mapsto
					e_i\}),q\backslash\!\!\backslash v}\comp \Pi; \mathcolorbox{yellow}{\M}}
		}\\[4ex]
		
		(\mathit{Spawn}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{spawn}(\kappa,a/n,[\ol{v_n}])}
				\theta',e'~~~ p'~\mbox{is a fresh pid}}{\Gamma;\tuple{p,(\theta,e),q} 
				\comp \Pi; \mathcolorbox{yellow}{\M} \hoo \Gamma;\tuple{p,(\theta',e'\{\kappa\mapsto p'\}),q}\comp \tuple{p',(\id,\mathsf{apply}~a/n~(\ol{v_n})),\nil} 
				\comp \Pi; \mathcolorbox{yellow}{\M}}
		}\\[4ex]
		
		(\mathit{Self}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{self}(\kappa)} \theta',e'}{\Gamma;\tuple{p,(\theta,e),q} 
				\comp \Pi; \mathcolorbox{yellow}{\M} \hoo \Gamma;\tuple{p,(\theta',e'\{\kappa\mapsto p\}),q} 
				\comp \Pi; \mathcolorbox{yellow}{\M} }
		}\\[4ex]
		
		(\mathit{Sched}) ~ {\displaystyle
			\frac{~}{\Gamma\cup\{(p,v)\};\tuple{p,(\theta,e),q}\comp\Pi; \mathcolorbox{yellow}{\M} 
				\hoo \Gamma;\tuple{p,(\theta,e),v\cons q}\comp\Pi; \mathcolorbox{yellow}{\M}}
		}
	\end{array}
	\]
	\caption{Regole standard della semantica del sistema} \label{fig:system-rules}
\end{figure}

La regola $\mathit{Seq}$ aggiorna semplicemente il controllo $(\theta, e)$ del processo considerato quando un'espressione sequenziale viene ridotta utilizzando le regole di espressione.

La regola $\mathit{Call3}$ come $\mathit{Seq}$ aggiorna semplicemente il controllo $(\theta, e)$ del processo considerato quando un'espressione sequenziale viene ridotta utilizzando le regole di espressione, però accede alla mappa, quindi utilizza l'etichetta $\tau\M\M'$ invece di $\tau$.

Le regole $\mathit{Send} $ e $\mathit{SendA} $ aggiungono la coppia $(p '', v)$ alla casella di posta globale $\Gamma$ invece di aggiungerla alla coda del processo $p ''$. Ciò è necessario per garantire che tutti i possibili intrecci di messaggi siano modellati correttamente.
È stata introdotta la funzione ausiliaria $\mathsf{isAtom}$ che viene utilizzata per capire se la regola debba accedere alla mappa, l'unica differenza fra le due regole è che la $\mathit{SendA}$ utilizza un atomo come destinatario. 
Si noti che $e '$ è solitamente diverso da $v$ poiché $e$ può avere operatori annidati diversi. Ad esempio, se $e$ ha la forma `` $\mathsf{case} ~ \mathrm{p} \:! \: V ~ \mathsf {of} ~ \{\ldots \} $,'' allora $ e '$ sarà ``$ \mathsf {case} ~ v ~ \mathsf {of} ~ \{\ldots \} $'' con etichetta $ \mathsf {send} (\mathrm {p}, v) $.

La regola $\mathit{SendF}$ introduce un fallimento, infatti l'espressione da valutare successivamente nel processo sarà $sendFail$ un atomo che corrisponde ad un fallimento perché all'atomo che si utilizza per inviare un messaggio non è associato nessun pid che si capisce grazie alla funzione $\mathsf{matchPid}$.
	
Nella regola $ \mathit {Receive} $, usiamo la funzione ausiliaria $ \mathsf {matchrec} $ per valutare un'espressione di ricezione. La differenza principale con $\mathsf {match}$ è che $\mathsf{matchrec}$ prende anche una coda $q$ e restituisce il messaggio selezionato $v$. Più precisamente, la funzione $ \mathsf {matchrec} $ esegue la scansione della coda $ q $ cercando il \emph {primo} messaggio $ v $ che corrisponde a un modello dell'istruzione di ricezione. Quindi, $ \kappa $ viene associato all'espressione nella clausola selezionata, $ e_i $, e l'ambiente viene esteso con la sostituzione corrispondente.
		
Se nessun messaggio nella coda $ q $ corrisponde ad alcuna clausola, la regola non è applicabile e il processo selezionato non può essere ridotto (cioè viene sospeso). Come nelle espressioni case, assumiamo che i pattern possano contenere solo nuove variabili.
		
Le regole presentate finora consentono di memorizzare i messaggi nella casella di posta globale, ma non di rimuoverne i messaggi. Questo è esattamente il compito dello scheduler, modellato dalla regola $ \mathit{Sched} $. Questa regola sceglie in modo non deterministico una coppia $ (p, v) $ nella cassetta postale globale $ \Gamma $ e consegna il messaggio $ v $ al processo di destinazione $ p $. Qui, ignoriamo deliberatamente la restrizione: `` i messaggi inviati, direttamente, tra due processi dati arrivano nello stesso ordine in cui sono stati inviati ", poiché le attuali implementazioni lo garantiscono solo all'interno dello stesso nodo. In pratica, ignorare questa restrizione equivale a considerare che ogni processo è potenzialmente eseguito in un nodo diverso. Una definizione alternativa che garantisce questa restrizione può essere trovata in \cite{NPV16b}.

      \begin{figure}[th]
	\footnotesize
	\[
	\begin{array}{c}
		
		\mathcolorbox{yellow}{(\mathit{Register T}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{register}(\mathsf{true},a,p')}
					\theta',e' ~ \mathsf{matchMapReg}(\M, a,p') = true} {\Gamma;\tuple{p,(\theta,e),q}\comp \Pi; \M \hoo
					\Gamma;\tuple{p,(\theta',e'),q}\comp \Pi; \M\cup(a,p')  }
		}}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{Register F}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{register}(\mathsf{false},a,p')}
					\theta',e' ~ \mathsf{matchMapReg}(\M, a,p') = false} {\Gamma;\tuple{p,(\theta,e),q}\comp \Pi; \M \hoo
					\Gamma;\tuple{p,(\theta,regFail),q}\comp \Pi; \M}
		}}\\[4ex]      
		
		\mathcolorbox{yellow}{(\mathit{UnregisterT}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{unregister}(\mathsf{true},a)}
					\theta',e' ~ \mathsf{matchMapUnreg}(\M, a) = p'} {\Gamma;\tuple{p,(\theta,e),q}\comp \Pi; \M \hoo
					\Gamma;\tuple{p,(\theta',e'),q}\comp \Pi; \M\backslash\!\!\backslash(a,p')  }
		}}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{UnregisterF}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{unregister}(\mathsf{false},a)}
					\theta',e' ~ \mathsf{matchMapUnreg}(\M,a) = false} {\Gamma;\tuple{p,(\theta,e),q}\comp \Pi; \M \hoo
					\Gamma;\tuple{p,(\theta,unregFail),q}\comp \Pi; \M  }
		}}\\[4ex]
	
		\mathcolorbox{yellow}{(\mathit{Catch}) ~ {\displaystyle
				\frac{ \theta,e \arro{\bot}  fail  }{\Gamma;\tuple{p,(\theta,e),q}\comp \Pi; \M \hoo
					\Gamma;\tuple{p,(\theta,fail),q}\comp \Pi; \M}
		}}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{End}) ~ {\displaystyle
				\frac{ \mathsf{matchEnd}(\M,p)=a'  ~~  }{\Gamma;\tuple{p,(\theta,\epsilon),q}\comp \Pi; \M \hoo
					\Gamma;\tuple{p,(\theta,\epsilon),q}\comp \Pi; \M\backslash\!\!\backslash (a' ,p)}
		}}
		\end{array}
	\]
	\caption{Regole standard della semantica del sistema che utilizzano la mappa} \label{fig:system-rules-map}
\end{figure}

Nella figura \ref{fig:system-rules-map} si può notare che sono state aggiunte anche le regole per la $\mathsf{register}$ e per l'$\mathsf{unregister}$.
Queste regole sono divise in 2 casi:
\begin{itemize}
	\item il caso di successo;
	\item il caso di fallimento (che introduce come prossima espressione da valutare un atomo che descrive un fallimento).
\end{itemize}
Il caso di successo corrisponde alle regole $\mathit{RegisterT}$ e $\mathit{UnregisterT}$ che rispettivamente aggiungono la coppia $(a,p')$ alla mappa e tolgono la coppia $(a,p')$ dalla mappa.
Mentre il caso di fallimento corrisponde alle regole $\mathit{RegisterF}$ e $\mathit{UnregisterF}$. 

La regola $\mathit{Catch}$ serve per gestire il caso di fallimento di un processo. In questo caso il fallimento viene catturato al top-level.

La regola $End$ serve per gestire il caso di fine di un processo. In caso di fallimento o terminazione di un processo se il processo è registrato viene deregistrato. 

Questa scelta è stata fatta per essere il più possibili fedeli al comportamento di Erlang, visto che nel linguaggio utilizzato non sono presenti le eccezioni.

\subsection*{Concorrenza in Erlang}

Per definire una semantica reversibile per Erlang abbiamo bisogno non solo di una semantica come quella appena presentata, ma anche di una nozione di concorrenza (o, equivalentemente, della nozione opposta di conflitto). 

Dati i sistemi $ s_1, s_2 $, chiamiamo $ s_1 \hoo ^ \ast s_2 $ una \emph {derivazione}.
%
Le derivazioni in un passaggio sono chiamate semplicemente \emph {transizioni}. Usiamo $ d, d ', d_1, \ldots $ per indicare le derivazioni e $ t, t', t_1, \ldots $ per le transizioni.

Le transizioni vengono etichettate con: $s_1 \hoo_{p,r} s_2$ dove:
\begin{itemize}
	\item $p$ è il pid del processo selezionato nella transizione o del processo a cui viene consegnato un messaggio (se la regola applicata è  $\mathit{Sched})$;
	\item $r$ è l'etichetta della regola di transizione applicata. 
\end{itemize}
Data una derivazione $ d = (s_1 \hoo ^\ast s_2) $, definiamo $ \init(d) = s_1 $ e $ \final(d) = s_2 $.
Due derivazioni, $ d_1 $ e $ d_2 $, sono \emph{componibili} se $\final(d_1) = \init (d_2) $. In questo caso, $ d_1; d_2 $ corrisponde alla composizione $d_1; d_2=(s_1\hoo s_2\hoo\cdots\hoo s_n\hoo s_{n + 1}\hoo\cdots\hoo s_m)$ se $d_1 = (s_1 \hoo s_2 \hoo \cdots \hoo s_n) $ e $ d_2 = (s_n \hoo s_ {n + 1} \hoo \cdots \hoo s_m)$.
Due derivazioni, $ d_1 $ e $ d_2 $, sono dette \emph{coiniziali} se $\init(d_1) = \init (d_2) $ e \emph {cofinali} se $\final(d_1) = \final( d_2)$.

\begin{definition}[Transizioni concorrenti] \label{def:concurrent1}
	Date due transizioni coiniziali, $t_1 = (s \hoo_{p_1,r_1} s_1)$
	e $t_2 = (s \hoo_{p_2,r_2} s_2)$, si dice che sono
	\emph{in conflitto} se:
  \begin{itemize}
	\item considerano lo stesso processo, i.e., $p_1 = p_2$, e anche $r_1 = r_2 = \mathit{Sched}$ o se una transizione applica la regola $\mathit{Sched}$ e l'altra applica la regola $\mathit{Receive}$ \cite{Lanese};
	\item entrambe sono operazioni sulla mappa e una delle due regole accede in scrittura sulla mappa ($\mathsf{RegisterT}$, $\mathsf{UnregisterT}$, $\mathsf{End}$) e l'altra accede o in scrittura o in lettura ($\mathsf{SendA}$, $\mathsf{SendF}$, $\mathsf{RegisterF}$, $\mathsf{UnregisterF}$, $\mathsf{Call3}$) sulla mappa, in modo che una delle funzioni ($\mathsf{matchPid}$, $\mathsf{matchMapReg}$, $\mathsf{matchMapUnreg}$, $\mathsf{matchEnd}$, $\mathsf{evalM}$) utilizzate non abbia più lo stesso risultato. I casi in cui questo accade sono presenti nella tabella~\ref{tab:conflitti}.
	\begin{table}[h]
		\hspace{-15ex}
		\begin{tabular}{|l|l|lllllll}
			\hline
			\backslashbox{$~r_1~~$} {$~~r_2~$} & $\mathsf{Call3}$ & \multicolumn{1}{l|}{$\mathsf{UnregisterF}$} & \multicolumn{1}{l|}{$\mathsf{RegisterF}$} & \multicolumn{1}{l|}{$\mathsf{SendF}$} & \multicolumn{1}{l|}{$\mathsf{SendA}$} & \multicolumn{1}{l|}{$\mathsf{End}$} & \multicolumn{1}{l|}{$\mathsf{UnregisterT}$} & \multicolumn{1}{l|}{$\mathsf{RegisterT}$} \\ \hline
			$\mathsf{RegisterT}$   &    \begin{tabular}[c]{@{}l@{}}$a'  \in \mathsf{M'} ~\lor$ \\ $ p' \in \mathsf{M'}$\end{tabular}   & \multicolumn{1}{l|}{$a'=a''$}            & \multicolumn{1}{l|}{}          & \multicolumn{1}{l|}{$a'=a''$}      & \multicolumn{1}{l|}{}      & \multicolumn{1}{l|}{}    & \multicolumn{1}{l|}{}            & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}$a'=a'' ~\lor$ \\ $ p'=p''$\end{tabular}}          \\ \hline
			$\mathsf{UnregisterT}$ &  \begin{tabular}[c]{@{}l@{}}$a'  \in \mathsf{M'} ~\lor$ \\ $ p' \in \mathsf{M'}$\end{tabular}      & \multicolumn{1}{l|}{}            & \multicolumn{1}{l|}{$a'=a''$}          & \multicolumn{1}{l|}{}      & \multicolumn{1}{l|}{$a'=a''$}& \multicolumn{1}{l|}{$a'=a''$}    & \multicolumn{1}{l|}{$a'=a''$}            &                                \\ \cline{1-8}
			$\mathsf{End}$         &    \begin{tabular}[c]{@{}l@{}}$a'  \in \mathsf{M'} ~\lor$ \\ $ p' \in \mathsf{M'}$\end{tabular}   & \multicolumn{1}{l|}{}            & \multicolumn{1}{l|}{$a'=a''$}          & \multicolumn{1}{l|}{}      & \multicolumn{1}{l|}{$a'=a''$}      & \multicolumn{1}{l|}{}    &                                  &                                \\ \cline{1-7}
			$\mathsf{SendA}$       &       & \multicolumn{1}{l|}{}            & \multicolumn{1}{l|}{}          & \multicolumn{1}{l|}{}      & \multicolumn{1}{l|}{}      &                          &                                  &                                \\ \cline{1-6}
			$\mathsf{SendF}$       &       & \multicolumn{1}{l|}{}            & \multicolumn{1}{l|}{}          & \multicolumn{1}{l|}{}      &                            &                          &                                  &                                \\ \cline{1-5}
			$\mathsf{RegisterF}$   &       & \multicolumn{1}{l|}{}            & \multicolumn{1}{l|}{}          &                            &                            &                          &                                  &                                \\ \cline{1-4}
			$\mathsf{UnregisterF}$ &       & \multicolumn{1}{l|}{}            &                                &                            &                            &                          &                                  &                                \\ \cline{1-3}
			$\mathsf{Call3}$       &       &                                  &                                &                            &                            &                          &                                  &                                \\ \cline{1-2}
		\end{tabular}
		\caption{\label{tab:conflitti} Tabella dei conflitti}
	\end{table}

	Nella Tabella~\ref{tab:conflitti} sono presenti i casi in cui si verificano i conflitti, $a'$ e $p'$ rappresentano l'atomo e il pid coinvolti da $r_1$, mentre $a''$ e $p''$ rappresentano l'atomo e il pid coinvolto da $r_2$. $\mathsf{M'}$ rappresenta gli elementi letti nella mappa dalla regola $\mathsf{Call3}$. Le celle vuote rappresentano transizioni coiniziali che non vanno in conflitto.\\
	Da notare che non tutte le operazioni in scrittura sulla mappa sono in conflitto fra di loro questo perché in quei casi le transizioni non possono essere coiniziali e in conflitto. 
\end{itemize}
Due transizioni coiniziali sono \emph{concorrenti} se non sono in conflitto. \qed
\end{definition}
	\begin{example}
	Nel caso $\mathsf{RegisterT}, ~ \mathsf{UnregisterT}$ non può essere presente un conflitto quando le due transizioni sono coiniziali perché si dovrebbe avere che $a'$ non dovrebbe appartenere alla mappa di atomi e pid per applicare $\mathsf{RegisterT}$, $a''$ dovrebbe appartenere alla mappa di atomi e pid per poter applicare $\mathsf{UnregisterT}$ e per essere in conflitto $a'$ dovrebbe essere uguale ad $a''$ il che è impossibile. 
\end{example}

Questa definizione è utile per la dimostrazione del prossimo lemma.

\begin{lemma}[\textbf{Square lemma}] \label{lemma:square1} Date due transizioni coiniziali concorrentu $t_1 = (s \hoo_{p_1,r_1} s_1)$ e
	$t_2 = (s \hoo_{p_2,r_2} s_2)$, allora esistono due transizioni cofinali $t_2/t_1 = (s_1 \hoo_{p_2,r_2} s')$ e
	$t_1/t_2 = (s_2 \hoo_{p_1,r_1} s')$.  Graficamente,
	\[
	\begin{minipage}{50ex}
		\xymatrix@C=50pt@R=20pt{
			s \ar@{^{(}->}[r]^{p_1,r_1} \ar@<1pt>@{^{(}->}[d]_{p_2,r_2} & s_1\\
			s_2 & 
		}
	\end{minipage}
	~~
	\Longrightarrow
	~~
	\begin{minipage}{50ex}
		\xymatrix@C=50pt@R=20pt{
			s \ar@{^{(}->}[r]^{p_1,r_1} \ar@{^{(}->}[d]_{p_2,r_2} & s_1 \ar@{^{(}->}[d]^{p_2,r_2}\\
			s_2 \ar@{^{(}->}[r]_{p_1,r_1} &  s'
		}
	\end{minipage}
	\]
\end{lemma}
\begin{proof}
	Abbiamo i seguenti casi:
	\begin{itemize}
		\item entrambe le transizioni non applicano regole sulla mappa:
			\begin{itemize}
		\item due transizioni $ t_1 $ e $ t_2 $ dove $r_1\neq\mathit{Sched}$ e $r_2\neq\mathit{Sched}$. Banalmente, si applicano a processi diversi, ad esempio $p_1\neq p_2$. Quindi, possiamo facilmente dimostrare che applicando la regola $r_2$ a $p_1$ in $s_1$ e la regola $r_1$ a $p_2$ in $s_2$ abbiamo due transizioni $t_1/t_2$ e $t_2/t_1$ che sono cofinali \cite{Lanese};
		\item una transizione $t_1$ che applica la regola $r_1=\mathit{Sched}$ per consegnare il messaggio $v_1$ all'elaborazione $p_1=\mathrm{p}$, e un'altra transizione che applica una regola $r_2$ diversa da $\mathit{Sched}$. Tutti i casi tranne $r_2=\mathit{Ricevi}$ con $p_2=\mathrm{p}$ sono semplici. Quest'ultimo caso, tuttavia, non può accadere poiché le transizioni che utilizzano le regole $\mathit{Sched}$ e $\mathit{Ricevi}$ non sono simultanee \cite{Lanese};
		\item due transizioni $ t_1 $ e $ t_2 $ con le regole $ r_1 = r_2 = \mathit {Sched} $ che consegnano rispettivamente i messaggi $ v_1 $ e $ v_2 $. Poiché le transizioni sono simultanee, dovrebbero consegnare i messaggi a processi differenti, cioè $ p_1 \neq p_2 $. Pertanto, possiamo vedere che consegnando $ v_2 $ da $ s_1 $ e $ v_1 $ da $ s_2 $ otteniamo due transizioni cofinali \cite{Lanese}; 
				\end{itemize}
		\item due transizioni $t_1$ e $t_2$ dove $r_1 = $ operazione sulla mappa e $r_2 \neq $ operazione sulla mappa. Quindi, possiamo facilmente dimostrare che applicando la regola $r_2$ a $p_1$ in $s_1$ e la regola $r_1$ a $p_2$ in $s_2$ abbiamo due transizioni $t_1 / t_2$ e $t_2 / t_1$ che sono cofinali;
		\item vale anche se entrambe le operazioni $r$ sono eseguite sulla mappa, questo perché se andassero a modificare gli stessi elementi della mappa non potrebbero essere concorrenti per la definizione data: 
		\begin{itemize}
			\item se $r_1 = r_2 = \mathsf{UnregisterT}$ e deregistrano gli atomi $a_1$ e $a_2$ se le due operazioni sono concorrenti (quindi $a_1 \not= a_2$), deregistrare prima $a_1$ e poi $a_2$ o viceversa non cambia (in $s'$ la mappa sarà la stessa);
			\item  questo ragionamento lo si può fare con tutte le regole sulla mappa. 
		\end{itemize}
	\end{itemize}
\end{proof} 

Notiamo qui che sono possibili altre definizioni di transizioni concorrenti. La modifica del modello di concorrenza richiederebbe la modifica delle informazioni memorizzate nella semantica reversibile al fine di preservare la coerenza causale. Abbiamo scelto la nozione sopra poiché è ragionevolmente semplice da definire e perché è facile lavorarci.

\section{Semantica reversibile}\label{sect:semreversibile}

In questa sezione, introduciamo una semantica reversibile (non controllata) per il linguaggio considerato. Grazie al design modulare della semantica concreta, non è necessario modificare le regole di transizione per le espressioni del linguaggio per definire la semantica reversibile.

Per essere precisi, in questa sezione introduciamo due relazioni di transizione: $ \rh $ e $ \lh $. La prima relazione, $ \rh $, è un'estensione conservativa della semantica standard $ \hoo $ (Figure~\ref {fig:system-rules} e \ref{fig:system-rules-map}) per includere anche alcune informazioni aggiuntive negli stati, seguendo un tipico incorporamento di Landauer. Ci riferiamo a $ \rh $ come alla semantica reversibile \emph{forward} (o semplicemente alla semantica forward). Al contrario, la seconda relazione, $ \lh $, procede nella direzione all'indietro, ``annullando'' le azioni passo dopo passo. Ci riferiamo a $ \lh $ come semantica \emph{backward} (reversibile). Indichiamo l'unione $ \rh \cup \lh $ con $ \rlh $.

Per evitare di annullare tutte le azioni fino all'inizio del processo, lasceremo anche che il programmatore introduca \emph{checkpoints}. Sintatticamente, sono indicati con la funzione incorporata \textsf{check}, che accetta un identificatore $ \mathtt{t} $ come argomento. Tali identificatori dovrebbero essere univoci nel programma. Data un'espressione, $ expr $, possiamo introdurre un checkpoint sostituendo $ expr $ con `` $\mathsf {let} ~ X = \mathsf {check} (\mathtt {t}) ~ \mathsf {in} ~ expr $''. Una chiamata nella forma $ \mathsf {check} (\mathtt {t}) $ restituisce semplicemente $ \mathtt {t} $ (vedi sotto).
Di seguito, consideriamo che le regole per valutare le espressioni del linguaggio (Figure~\ref {fig:seq-rules} e \ref{fig:concurrent-rules}) sono estese con la seguente regola:
\[
(\mathit{Check}) ~~ 
{\displaystyle 
   	\frac{}{\theta,\mathsf{check}(\mathtt{t}) \arro{\mathsf{check}(\mathtt{t})} \theta,\mathtt{t}}}
\]

Le principali modifiche effettuate sono state l'aggiunta di una storia al processo, di un identificatore per i messaggi (un timestamp $\lambda$)~\cite{Lanese} e di una storia della mappa. 
L'aggiunta della storia del processo e della mappa è un tipico incorporamento di Laundered in cui viene aggiunta la cronologia delle operazioni eseguite dal processo (nel primo caso) e delle operazioni eseguite sulla mappa. Il sistema ora include una memoria (storia) che registra gli stati intermedi della mappa. Questo è stato fatto perché in questo modo è possibile tenere traccia delle operazioni che sono state eseguite sulla mappa e del loro ordine di esecuzione.

Al messaggio è stato aggiunto un timestamp perché  se si considera un processo $ \mathrm {p1} $ che invia due messaggi identici ad un altro processo $ \mathrm {p2} $ (il che non è insolito, ad esempio un ``ack'' dopo aver ricevuto una richiesta), per annullare la prima azione $ \mathrm {p2} \:! \: \mathrm {v} $ del processo $ \mathrm {p1} $ è necessario annullare tutte le azioni del processo $ \mathrm {p2 } $ fino alla ricezione del primo messaggio. Tuttavia, non possiamo distinguere il primo messaggio dal secondo a meno che non si tenga conto di alcune informazioni aggiuntive. Pertanto, è necessario introdurre un identificatore univoco per distinguere con precisione questo caso.

\begin{figure}[htp]
	\footnotesize
	\[
	\begin{array}{c}
		(\mathit{Seq}) ~ {\displaystyle
			\frac{\theta,e\arro{\tau} \theta',e'
			}{\Gamma;\tuple{p,\h,(\theta,e),q}\comp \Pi;\mathcolorbox{yellow}{\M;\s} \rh
				\Gamma;\tuple{p,\tau(\theta,e)\cons\h,(\theta',e'),q}\comp \Pi;\mathcolorbox{yellow}{\M;\s} }
		}\\[4ex]
	
			\mathcolorbox{yellow}{(\mathit{Call3}) ~ {\displaystyle
			\frac{\theta,e\arro{\tau\M\M'} \theta',e'}
			{      \begin{split}
					\Gamma;\tuple{p,\h,(\theta,e),q}\comp \Pi;\M;\s 
					\rh \Gamma;\tuple{p,\tau\M\M'(\theta,e,p)\cons\h,(\theta',e'),q}\comp \Pi;\\
					\M;\tau\mathsf{MM'}(\theta,e,p)\cons\s
				\end{split}
			}
	}}\\[7ex]
		
		(\mathit{Check}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{check}(\mathtt{t})} \theta',e'}{\Gamma;\tuple{p,\h,(\theta,e),q} 
				\comp \Pi;\mathcolorbox{yellow}{\M;\s} \rh \Gamma;\tuple{p,\mathsf{check}(\theta,e,\mathtt{t})\cons\h,(\theta',e'),q} 
				\comp \Pi;\mathcolorbox{yellow}{\M;\s} }
		}\\[4ex]
		
		(\mathit{Send}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{send}(p'',v)}
				\theta',e'~~~\k~\mbox{is a fresh identifier} ~\mathcolorbox{yellow}{\mathsf{isAtom}(p'')=false ~~ }}
			{
				\begin{split}
					\Gamma;\tuple{p,\h,(\theta,e),q} 
					\comp \Pi;\mathcolorbox{yellow}{\M;\s} \rh
					\Gamma\cup (p'',\{v,\k\});\tuple{p,\mathsf{send}(\theta,e,p'',\{v,\k\})\cons
						\h,(\theta',e'),q}\comp \Pi;
					\mathcolorbox{yellow}{\M;\s}
				\end{split}
			}
		}\\[8ex]
		
		\mathcolorbox{yellow}{(\mathit{SendA}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{send}(a,v)}
					\theta',e'~~~\k~\mbox{is a fresh identifier} ~\mathcolorbox{yellow}{\mathsf{isAtom}(a)=true ~~ \mathsf{matchPid}(\M, a) = p''}}
				{
					\begin{split}
						\Gamma;\tuple{p,\h,(\theta,e),q} 
						\comp \Pi;\M;\s \rh
						\Gamma\cup (p'',\{v,\k\});\tuple{p,\mathsf{sendA}(\theta,e,p'',\{v,\k\},a,p)\cons
							\h,(\theta',e'),q}\comp \Pi;\\
						\M;\mathsf{sendA}(\theta,e,p'',\{v,\k\},a,p)\cons\s
					\end{split}
				}
		}}\\[8ex]
		
		\mathcolorbox{yellow}{(\mathit{SendF}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{send}(a,v)}
					\theta',e'~~~\mathcolorbox{yellow}{\mathsf{isAtom}(a)=true ~~ \mathsf{matchPid}(\M, a) = false}}
				{\begin{split}
						\Gamma;\tuple{p,\h,(\theta,e),q} 
						\comp \Pi;\M;\s \rh
						\Gamma;\tuple{p,\mathsf{sendF}(\theta,e,a,p)\cons
							\h,(\theta,sendFail),q}\comp \Pi;\\
						\M;\mathsf{sendF}(\theta,e,a,p)\cons\s
					\end{split}
			}}
		}\\[8ex]
		
		(\mathit{Receive}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{rec}(\kappa,\ol{cl_n})}
				\theta',e'~~~ \mathsf{matchrec}(\theta,\ol{cl_n},q) = (\theta_i,e_i,\{v,\k\})}{\Gamma;\tuple{p,\h,(\theta,e),q}\comp \Pi;\mathcolorbox{yellow}{\M;\s} \rh
				\Gamma;\tuple{p,\mathsf{rec}(\theta,e,\{v,\k\},q)\cons\h,(\theta'\theta_i,e'\{\kappa\mapsto e_i\}),q\backslash\!\!\backslash\{v,\k\}}\comp \Pi;\mathcolorbox{yellow}{\M;\s}}
		}\\[4ex]
		
		(\mathit{Spawn}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{spawn}(\kappa,a/n,[\ol{v_n}])}
				\theta',e'~~~ p'~\mbox{is a fresh pid}}%%~~~\mbox{and $\mathtt{t}$ is fresh}}
			{\begin{array}{ll}
					\Gamma;\tuple{p,\h,(\theta,e),q} 
					\comp \Pi;\mathcolorbox{yellow}{\M;\s} \rh &
					\Gamma;\tuple{p,\mathsf{spawn}(\theta,e,p')\cons\h,(\theta',e'\{\kappa\mapsto
						p'\}),q} \\
					& \comp \tuple{p',\nil,(\id,\mathsf{apply}~a/n~(\ol{v_n})),\nil} 
					\comp \Pi;\mathcolorbox{yellow}{\M;\s}
			\end{array}}
		}\\[6ex]
		
		(\mathit{Self}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{self}(\kappa)} \theta',e'}
			{\Gamma;\tuple{p,\h,(\theta,e),q} \comp \Pi;\mathcolorbox{yellow}{\M;\s} 
				\rh 
				\Gamma;\tuple{p,\mathsf{self}(\theta,e)\cons\h,(\theta',e'\{\kappa\mapsto p\}),q} 
				\comp \Pi;\mathcolorbox{yellow}{\M;\s} }
		}\\[4ex]
		
		(\mathit{Sched}) ~ {\displaystyle
			\frac{~}
			{\Gamma\cup\{(p,\{v,\k\})\};\tuple{p,\h,(\theta,e),q}\comp\Pi;\mathcolorbox{yellow}{\M;\s} 
				\rh \Gamma;\tuple{p,\h,(\theta,e),\{v,\k\}\cons q}\comp\Pi;\mathcolorbox{yellow}{\M;\s}}
		}
	\end{array}
	\]
	\caption{Semantica reversibile forward} \label{fig:forwardsem}
\end{figure}

Le regole di transizioni della semantica forward si possono trovare nelle Figure~\ref{fig:forwardsem} e \ref{fig:forwardsem1}. Ai processi è stata aggiunta una \emph{storia} (o memoria) $\h$ che registra gli stati intermedi del processo e dei messaggi con l'identificatore (univoco) a loro associato. \\~\\
Nella storia per identificare le operazioni eseguite si utilizzano dei costruttori $\tau$, $\mathsf{check}$, $\mathsf{send}$,
$\mathsf{rec}$, $\mathsf{spawn}$, $\mathsf{self}$, $\tau\M\M'$, $\mathsf{sendA}$, $\mathsf{sendF}$, $\mathsf{regT}$, $\mathsf{regF}$, $\mathsf{unregT}$, $\mathsf{unregF}$, $\mathsf{fail}$ e $\mathsf{end}$  che identificano le regole applicate nella semantica forward. 
%Si nota che si potrebbero diminuire le informazioni salvate nella storia utilizzando una strategia simile a quella utilizzata in \cite{MHNHT07,NPV16,TA15} ma questo è un problema diverso da quello discusso nella tesi.
Nella regola $ \mathit {Receive} $ si può notare che la funzione ausiliare  $\mathsf{matchrec}$ prende in input un messaggio del tipo $\{v,\k\}$, che è l'estensione originale che ignora $\k$ quando elabora il match col primo messaggio.

\begin{figure}[htp]
	\footnotesize
	\[
	\begin{array}{c}
	
		\mathcolorbox{yellow}{(\mathit{RegisterT}) ~ {\displaystyle
				\frac{\theta,e\arro{\mathsf{register}(\mathsf{true},a,p')} \theta',e'~ \mathsf{matchMapReg}(\M, a,p') = true}
				{    
					\begin{split}
						\Gamma;\tuple{p,\h,(\theta,e),q}\comp \Pi;\M;\s 
						\rh \Gamma;\tuple{p,\mathsf{regT}(\theta,e,a,p',p)\cons\h,(\theta',e'),q}\comp \Pi;\\
						\M\cup(a,p'); \mathsf{regT}(\theta,e,a,p',p) \cons\s
					\end{split}
			}}
		}\\[7ex]
		
		\mathcolorbox{yellow}{(\mathit{RegisterF}) ~ {\displaystyle
				\frac{\theta,e\arro{\mathsf{register}(\mathsf{false},a,p')} \theta',e' ~ \mathsf{matchMapReg}(\M, a,p') = false}
				{\begin{split}
						\Gamma;\tuple{p,\h,(\theta,e),q}\comp \Pi;\M;\s 
						\rh \Gamma;\tuple{p,\mathsf{regF}(\theta,e,a,p',p)\cons\h,(\theta,regFail),q}\comp \Pi;\\
						\M; \mathsf{regF}(\theta,e,a,p',p) \cons\s 
			\end{split}}}
		}\\[7ex]
		
		\mathcolorbox{yellow}{(\mathit{UnregisterT}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{unregister}(\mathsf{true},a)}
					\theta',e' ~ \mathsf{matchMapUnreg}(\M, a,p) = p'} 
				{      \begin{split}
						\Gamma;\tuple{p,h,(\theta,e),q}\comp \Pi;\M;\s 
						\rh \Gamma;\tuple{p,\mathsf{unregT}(\theta,e,a,p',p)\cons\h, (\theta',e'),q}\comp \Pi; \\
						\M\backslash\!\!\backslash(a,p'); \mathsf{unregT}(\theta,e,a,p',p)\cons\s  
				\end{split}}
		}}\\[7ex]
		
		\mathcolorbox{yellow}{(\mathit{UnregisterF}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{unregister}(\mathsf{false},a)}
					\theta',e' ~ \mathsf{matchMapUnreg}(\M, a,p) = false} 
				{
					\begin{split}
						\Gamma;\tuple{p,h,(\theta,e),q}\comp \Pi; \M;\s 
						\rh \Gamma;\tuple{p,\mathsf{unregF}(\theta,e,a,p)\cons\h,(\theta,unregFail),q}\comp \Pi;\\
						\M;\mathsf{unregF}(\theta,e,a,p) \cons\s  
					\end{split}
				}
		}}\\[7ex]
		
		\mathcolorbox{yellow}{(\mathit{Catch}) ~ {\displaystyle
				\frac{ \theta,e \arro{\bot}  fail  }{\Gamma;\tuple{p,\h,(\theta,e),q}\comp \Pi; \M;\s \rh
					\Gamma;\tuple{p,\mathsf{fail}(\theta,e)\cons\h,(\theta,fail),q}\comp \Pi; \M;\s}
		}}\\[3ex]

		\mathcolorbox{yellow}{(\mathit{End}) ~ {\displaystyle
				\frac{\mathsf{matchEnd}(\M,p)=a'}{
						\Gamma;\tuple{p,\h,(\theta,\epsilon),q}\comp \Pi;\M;\s \rh
						\Gamma;\tuple{p,\mathsf{end}(\theta,\epsilon,a',p)\cons\h,(\theta,\epsilon),q}\comp \Pi,
						\M\backslash\!\!\backslash (a' ,p); \mathsf{end}(\theta,\epsilon,a',p)\cons\s
				}
		}}\\[3ex]
	
\mathcolorbox{yellow}{(\mathit{End}) ~ {\displaystyle
\frac{\mathsf{matchEnd}(\M,p)=\emptyset}{
	\Gamma;\tuple{p,\h,(\theta,\epsilon),q}\comp \Pi;\M;\s \rh
	\Gamma;\tuple{p,\mathsf{end}(\theta,\epsilon,\mathsf{undefined},p)\cons\h,(\theta,\epsilon),q}\comp \Pi,
	\M; \mathsf{end}(\theta,\epsilon,\mathsf{undefined},p)\cons\s
}
}}								
	\end{array}
	\]
	\caption{Semantica reversibile forward} \label{fig:forwardsem1}
\end{figure}
~\\
Per dimostrare che la semantica forward $\rh$ estende la semantica standard $\hoo$ bisogna introdurre $ \del(s) $.
 Si può vedere che $ \del(s) $ denoti il sistema risultante da $ s $ rimuovendo le cronologie dei processi; formalmente,
$\del(\Gamma;\Pi;\mathsf{M;S}) = \Gamma;\del'(\Pi);\M$, dove
\[
\begin{array}{lll}
	\del'(\tuple{p,\h,(\theta,e),q}) & = &
	\tuple{p,(\theta,e),q}
	\\
	\del'(\tuple{p,\h,(\theta,e),q}\:\comp\:\Pi) & = &
	\tuple{p,(\theta,e),q}\:\comp\:\del'(\Pi)
	\\
\end{array}
\]
si assume che $\Pi$ non sia vuoto. \\

\begin{theorem} \label{th:conservative}
	Sia $s_1$ un sistema nella semantica forward senza occorrenze di ``$\mathsf{check}$'' e $s'_1=\del(s_1)$ un sistema nella semantica standard. Allora, $s'_1 \hoo^\ast s'_2$ sse $s_1 \rh^\ast s_2$
	e $\del(s_2) = s'_2$.
\end{theorem}

\begin{proof}
	La dimostrazione avviene mostrando che le regole della semantica standard nelle Figure~\ref{fig:forwardsem} e \ref{fig:forwardsem1} sono la versione con la storia delle regole corrispondenti presenti nelle Figure~\ref{fig:system-rules} e \ref{fig:system-rules-map}. L'unico punto complicato è capire che l'introduzione dell'identificatore univoco nel messaggio non cambia il comportamento della regola $\mathit{Receive}$ poiché la funzione $\mathsf{matchrec}$ ha come risultato sempre l'occorrenza più vecchia (in termini di posizione nella coda) del messaggio selezionato \cite{Lanese}.
\end{proof}

In alcune delle regole di transizione della semantica backward, nelle side condition si richiederà che non siano presenti alcune delle regole di lettura o scrittura. 

 \begin{definition}[$\varepsilon$ e $\cancel{\varepsilon}$]\label{def:coinvolgimento}
	Per le operazioni sulla mappa diciamo che $x ~ \varepsilon ~op$ se l'operazione coinvolge l'elemento $x$ cioè se l'operazione aggiunge, rimuove o legge l'elemento $x$ dalla mappa. Si indica con $x~\cancel{\varepsilon}~op$ se l'operazione non coinvolge l'elemento $x$.
	Di seguito verrà mostrato l'elenco di come nella storia della mappa le regole vengono rappresentate e di quali sono gli elementi coinvolti.
\begin{itemize}
	\item se $op=\mathsf{regT}(\theta,e,a,p,p')$ allora $a ~\varepsilon~ \mathsf{regT}$, $p ~\varepsilon~ \mathsf{regT}$;% e $p'$ è il pid corrispondente al processo che esegue l'operazione
	\item se $op=\mathsf{unregT}(\theta,e,a,p,p')$ allora $a ~\varepsilon~ \mathsf{unregT}$, $p ~\varepsilon ~\mathsf{unregT}$;% e $p'$ è il pid corrispondente al processo che esegue l'operazione
	\item se $op=\mathsf{regF}(\theta,e,a,p,p')$ allora $a~ \varepsilon~ \mathsf{regF}$, $p~ \varepsilon~ \mathsf{regF}$;% e $p'$ è il pid corrispondente al processo che esegue l'operazione
	\item se $op=\mathsf{unregF}(\theta,e,a,p')$ allora  $a~ \varepsilon~ \mathsf{unregF}$;% e $p'$ è il pid corrispondente al processo che esegue l'operazione
	\item se $op=\mathsf{sendA}(\theta,e,p,\{v,\k\},a,p')$ allora $a ~\varepsilon~ \mathsf{sendA}$, $p~ \varepsilon~ \mathsf{sendA}$;% $p'$ è il pid corrispondente al processo che esegue l'operazione e la coppia $\{v,\k\}$ rappresenta il messaggio inviato
	\item se $op=\mathsf{sendF}(\theta,e,a,p')$ allora $a ~\varepsilon~ \mathsf{sendF}$; %e $p'$ è il pid corrispondente al processo che esegue l'operazione
	\item se $op=\mathsf{end}(\theta,e,p')$ allora $a~ \varepsilon~ \mathsf{end}$, $p' ~\varepsilon ~\mathsf{end}$;% e $p$ è il pid corrispondente al processo che esegue l'operazione, da notare che 
	\item se $op=\tau\mathsf{MM'}(\theta,e,p')$ allora $\forall~ p,a\in \mathsf{M'}; ~ p~\varepsilon ~ \tau\mathsf{MM'} \land a~\varepsilon ~ \tau\mathsf{MM'}$.\qed% e $p'$ è il pid corrispondente al processo che esegue l'operazione 
\end{itemize}
\end{definition}

\begin{definition}[Operazioni lettura e scrittura]\label{def:lettura-scrittura}
	
	Per la semantica standard si era detto che:
	\begin{itemize}
		\item per operazioni in scrittura si intendono le operazioni che modificano la mappa (cioè quelle regole che aggiungono o tolgono coppie alla mappa) e sono $\mathsf{RegisterT}$, $\mathsf{UnregisterT}$, $\mathsf{End}$.
		\item per operazioni in lettura si intendono le operazioni che  accedono alla mappa senza modificarla e sono $\mathsf{SendA}$, $\mathsf{SendF}$, $\mathsf{RegisterF}$, $\mathsf{UnregisterF}$, $\mathsf{Call3}$.
	\end{itemize}
	Questo vale anche per la semantica forward. 
	Per la semantica backward invece:
	\begin{itemize}
		\item le operazioni in scrittura sulla mappa sono $\ol{\mathsf{RegisterT}}$, $\ol{\mathsf{UnregisterT}}$ e $\ol{\mathsf{End}}$, da notare che anche queste operazioni vanno a modificare la mappa nel modo apposto alla regola forward corrispondente. 
		\item Mentre le operazioni in lettura sulla mappa nel caso della semantica backward sono $\ol{\mathsf{SendA}}$, $\ol{\mathsf{SendF}}$, $\ol{\mathsf{RegisterF}}$, $\ol{\mathsf{UnregisterF}}$ e $\ol{\mathsf{Call3}}$. 
		Le operazioni di backward in lettura vengono considerate come operazioni che leggono gli stessi elementi dell'operazione forward corrispondenti.\\\qed
	\end{itemize}
\end{definition}
Scegliere di dire che un'operazione all'indietro sia un'operazione in lettura è una scelta insolita ma è dovuta al fatto che si vuole evitare un ``annullamento'' di un'operazione di lettura sulla mappa quando la mappa è stata modificata.
\begin{example}
	Se si considera il caso in cui la storia ha una forma:
	\begin{center}
		$\mathsf{RegT}(a,p);\mathsf{Call3}(a);\mathsf{unregT}(a)$
	\end{center}
	se fosse possibile fare un operazione di annullamento di call3 ($\ol{\mathsf{Call3}(a)}$) allora si otterrebbe una storia
	\begin{center}
		$\mathsf{RegT}(a,p);\mathsf{unregT}(a)$
	\end{center}
	Però in questo modo si sarebbe annullata un operazione di lettura sulla mappa dopo che la mappa è stata modificata e si potrebbe riapplicare l'operazione $\mathsf{Call3}(a)$ che fallirebbe (o darebbe un risultato diverso) ottenendo una storia 
	\begin{center}
		$\mathsf{RegT}(a,p);\mathsf{unregT}(a);\mathsf{Call3}(a)$
	\end{center}
	In questo modo non si potrebbe far vedere che facendo operazioni di \textit{undo-redo} si ritornerebbe in uno stato equivalente, una proprietà importante che è richiesta.
\end{example}

Nelle Figure \ref{fig:backwardsem} e \ref{fig:backwardsem1} sono presenti le regole di transizione della semantica backward.


\begin{figure}[ht]
	\footnotesize
	\[
	\begin{array}{lc}
		(\mathit{\ol{Seq}}) ~ {\displaystyle
			\Gamma;
			\tuple{p,\tau(\theta,e)\cons\h,(\theta',e'),q}
			\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
			\lh  \Gamma;\tuple{p,\h,(\theta,e),q}\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
		}\\[2ex]
		
				\mathcolorbox{yellow}{(\mathit{\ol{Call3}}) ~ {\displaystyle
				\begin{array}{l}
					\Gamma;
					\tuple{p,\tau\mathsf{MM'}(\theta,e,p)\cons\h,(\theta',e'),q}
					\:\comp\: \Pi;\mathsf{M;S' : \tau\mathsf{MM'}(\theta,e,p):S}
					\lh  \Gamma;\tuple{p,\h,(\theta,e),q}\:\comp\: \Pi;\mathsf{M;S'}\cons\mathsf{S}\\
					\mbox{Se in S' non sono presenti operazioni di scrittura su elementi presenti in M'}    
				\end{array}
		}}
		\\[3ex]
		
		(\mathit{\ol{Check}}) ~ {\displaystyle
			\Gamma;
			\tuple{p,\mathsf{check}(\theta,e,\mathtt{t})\cons\h,(\theta',e'),q}
			\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
			\lh  \Gamma;\tuple{p,\h,(\theta,e),q}\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
		} 
		\\[2ex]
		
		(\mathit{\ol{Send}}) ~ {\displaystyle
			\begin{array}{lc }
				\Gamma\cup\{(p'',\{v,\k\})\};\tuple{p,\mathsf{send}(\theta,e,p'',\{v,\k\})\cons\h,(\theta',e'),q}\:\comp\:
				\Pi;\mathcolorbox{yellow}{\mathsf{M;}\mathsf{S}}
				\lh \Gamma;\tuple{p,\h,(\theta,e),q} 
				\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}\\
				
			\end{array}
		}\\[2ex]
		
		\mathcolorbox{yellow}{(\mathit{\ol{SendA}}) ~ {\displaystyle
				\begin{array}{lc }
					\Gamma\cup\{(p'',\{v,\k\})\};\tuple{p,\mathsf{sendA}(\theta,e,p'',\{v,\k\},a,p)\cons\h,(\theta',e'),q}\:\comp\:
					\Pi;\mathsf{M;S'}\cons \mathsf{sendA}(\theta,e,p'',\{v,\k\},a,p)\cons\mathsf{S}\\
					\hspace{20ex}
					\lh \Gamma;\tuple{p,\h,(\theta,e),q} 
					\:\comp\: \Pi;\mathsf{M;S'}\cons\mathsf{S}\\
					Se ~ \forall ~ op ~ \mbox{in scrittura} \in \mathsf{S'} ~  a~\cancel{\varepsilon} ~op ~ \mathsf{o} ~ p''~\cancel{\varepsilon} ~op
				\end{array}
		}}\\[6ex]
		
		\mathcolorbox{yellow} {(\mathit{\ol{SendF}}) ~ {\displaystyle
				\begin{array}{lc }
					\Gamma;\tuple{p,\mathsf{sendF}(\theta,e,a,p)\cons\h,(\theta,sendFail),q}\:\comp\:
					\Pi;\mathsf{M;S'}\cons \mathsf{sendF}(\theta,e,a,p)\cons\mathsf{S}\\
					\hspace{20ex}
					\lh \Gamma;\tuple{p,\h,(\theta,e),q} 
					\:\comp\: \Pi;\mathsf{M;S'}\cons\mathsf{S}\\
					Se ~ \forall ~ op ~ \mbox{in scrittura} \in \mathsf{S'} ~  a~\cancel{\varepsilon} ~op
			\end{array}}
		}\\[6ex]
		
		(\mathit{\ol{Receive}}) ~ {\displaystyle
			\Gamma;\tuple{p,\mathsf{rec}(\theta,e,\{v,\k\},q)\cons\h,(\theta',e'), q\backslash\!\!\backslash\{v,\k\}}\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
			\lh  \Gamma;\tuple{p,\h,(\theta,e),q}\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
		}
		\\[2ex]
		
		(\mathit{\ol{Spawn}}) ~ {\displaystyle
			\begin{array}{l}
				\Gamma;\tuple{p,\mathsf{spawn}(\theta,e,p')\cons\h,(\theta',e'),q}
				\:\comp\: 
				\tuple{p',\nil,(\id,e''),\nil}
				\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}} 
				\\
				\hspace{20ex}\lh
				\Gamma;\tuple{p,\h,(\theta,e),q}
				\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}} 
			\end{array}
		}\\[5ex]
		
		(\mathit{\ol{Self}}) ~ {\displaystyle
			\Gamma;\tuple{p,\mathsf{self}(\theta,e)\cons\h,(\theta',e'),q} 
			\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}} \lh
			\Gamma;\tuple{p,\h,(\theta,e),q} 
			\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}  
		}\\[2ex]
		
		(\mathit{\ol{Sched}}) ~ {\displaystyle
			\begin{array}{l}
				\Gamma;\tuple{p,\h,(\theta,e),\{v,\k\}\cons q} \: \comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}} \lh 
				\Gamma\cup(p,\{v,\k\});\tuple{p,\h,(\theta,e),q}\:\comp\:\Pi;\mathcolorbox{yellow}{\mathsf{M;S}}\\
				\hspace{20ex}\mbox{if the topmost $\mathsf{rec}(\ldots)$ item in
					$\h$ (if any) has the}\\ 
				\hspace{20ex}\mbox{form}~\mathsf{rec}(\theta',e',\{v',\k'\},q')~\mbox{with}~q'\backslash\!\!\backslash\{v',\k'\}\neq \{v,\k\}\cons q
			\end{array}
		} \\[5ex]
		
	\end{array}
	\]
	\caption{Backward reversible semantics } \label{fig:backwardsem}
\end{figure}
Ora verranno discusse brevementealcune situazioni particolari:
\begin{itemize}
	\item Innanzitutto, si osserva che la regola $\ol{\mathit{Send}}$ può essere applicata solo quando il messaggio inviato si trova nella casella di posta globale. Se questo non è il caso (cioè, il messaggio è stato consegnato usando la regola $\mathit{Sched}$), allora dovremo prima applicare i passaggi a ritroso al processo del destinatario fino alla fine; l'applicazione della regola $\ol{\mathit{Sched}}$ rimette il messaggio nella casella di posta globale e la regola $\ol{\mathit{Send}}$ diventa applicabile. Ciò è necessario per garantire la coerenza causale. Nella sezione successiva, introdurremo una strategia particolare che ottiene questo effetto in modo controllato \cite{Lanese}.
\end{itemize}
\begin{itemize}
	\item Si può notare che la regola $\ol{\mathit{SendA}}$ (come la regola $\ol{\mathit{Send}}$) può essere applicata solo quando il messaggio inviato si trova nella casella di posta globale (cioè, il messaggio non è stato ancora consegnato usando la regola $\mathit{Sched}$). Inoltre essendo un'operazione sulla mappa in lettura si richiede che non siano presenti operazioni in scrittura sulla mappa eseguite successivamente che coinvolgono l'atomo $a$ o il pid $p$, questo è necessario per rispettare la coerenza causale.
\end{itemize}
\begin{itemize}
	\item La regola $\ol{\mathit{SendF}}$ è anch'essa in lettura sulla mappa quindi per rispettare la consistenza causale verrà richiesto che non ci siano operazioni in scrittura sulla mappa eseguite successivamente che coinvolgono l'atomo $a$.
\end{itemize}
\begin{itemize}
	\item La regola $\ol{\mathit{Call3}}$ come $\ol{\mathit{SendA}}$ e $\ol{\mathit{SendF}}$ è una regola in lettura sulla mappa, però come side-condidtion richiede  che non ci siano operazioni in scrittura sulla mappa eseguite successivamente che coinvolgono atomi o pid presenti $\M'$.
\end{itemize}
	\begin{itemize}
	\item Una situazione simile si verifica con la regola $\ol{\mathit{Spawn}}$. Dato un processo $ p $ con un elemento della cronologia $\mathsf{spawn}(\theta,e,p')$, la regola $ \ol{\mathit{Spawn}}$ non può essere applicata finché la cronologia e la coda del processo $ p '$ sono entrambi vuoti. Pertanto, si dovrebbe prima applicare una serie di passaggi all'indietro per elaborare $ p '$ in modo da poter annullare l'elemento $\mathsf{spawn}$.
	%
	Notiamo che non è necessario richiedere che nessun messaggio indirizzato al processo $ p '$ (che diventerebbe un messaggio \emph{orfano}) è nella casella di posta globale: per inviare un tale messaggio il pid $ p' $ è necessario, quindi l'invio del messaggio dipende da $\mathsf {spawn}$ e, quindi, deve essere annullato in anticipo \cite{Lanese}.
\end{itemize}
\begin{itemize}
	\item Osserva anche che la regola $\ol{\mathit{Receive}}$ può essere applicata solo quando la coda del processo è esattamente la stessa che è stata ottenuta dopo aver applicato il corrispondente passaggio $\mathit{Receive}$. Ciò è necessario per garantire che la coda ripristinata sia effettivamente quella giusta (notare che l'aggiunta del messaggio a una coda arbitraria non funzionerebbe poiché non conosciamo la posizione ``giusta'' per il messaggio) \cite{Lanese}.
\end{itemize}
\begin{itemize}
	\item L'applicazione della regola $\ol{\mathit{Sched}}$ può essere cambiata con l'applicazione di qualsiasi altra regola all'indietro eccetto $\ol{\mathit{Receive}}$ o un altro $\ol{\mathit{Sched}}$, poiché non interferisce con le regole rimanenti. Il fatto che due $ \ol{\mathit{Sched}}$ (che coinvolgono lo stesso processo) non si spostino è garantito poiché $\ol{\mathit{Sched}}$ si applica sempre al messaggio più recente di una coda. Il fatto che $\ol{\mathit{Sched}}$ e $\ol{\mathit{Receive}}$ non si spostino è garantito poiché la condizione secondaria di $\ol{\mathit{Sched}}$ controlla che non ci sia nessun elemento $\mathsf{rec}(\ldots)$ nella cronologia del processo che può essere utilizzato per applicare la regola $\ol{Receive}$ con la coda corrente. Pertanto, le loro condizioni di applicabilità non si sovrappongono \cite{Lanese}.
\end{itemize}

\begin{figure}[ht]
	\footnotesize
	\[
	\begin{array}{lc}
		
		\mathcolorbox{yellow}{ (\mathit{\ol{RegisterT}}) ~ {\displaystyle
				\begin{array}{l}	
					\Gamma;\tuple{p,\mathsf{regT}(\theta,e,a,p',p)\cons\h,(\theta',e'),q}\comp \Pi;\M\cup(a,p') ; \s'\cons\mathsf{regT}(\theta,e,a,p',p) \cons\s \\
					\hspace{20ex} \lh  \Gamma;\tuple{p,\h,(\theta,e),q}\:\comp\: \Pi;\M;\s'\cons\s\\
					Se ~ \forall ~ op ~ \mbox{in scrittura o lettura} \in \s' ~  a \cancel{\varepsilon} op ~ \mathsf{o} ~ p'~\cancel{\varepsilon}~op    
					\end{array}		
		}}
		\\[6ex]
		
		\mathcolorbox{yellow}{ (\mathit{\ol{RegisterF}}) ~ {\displaystyle
				\begin{array}{l}
					\Gamma;\tuple{p,\mathsf{regF}(\theta,e,a,p',p)\cons\h,(\theta,regFail),q}\comp \Pi;
					\M; \s'\cons\mathsf{regF}(\theta,e,a,p',p) \cons\s \\    
					\hspace{20ex} \lh  \Gamma;\tuple{p,\h,(\theta,e),q}\:\comp\: \Pi;\M;\s'\cons\s\\
					Se ~ \forall ~ op ~ \mbox{in scrittura} \in \s' ~  a~\cancel{\varepsilon} ~op ~ \mathsf{o} ~ p'~\cancel{\varepsilon}~op  
				\end{array}
		}}
		\\[6ex]
		
	\mathcolorbox{yellow}{ (\mathit{\ol{UnregisterT}}) ~ {\displaystyle
				\begin{array}{l}
					\Gamma;\tuple{p,\mathsf{unregT}(\theta,e,a,p',p)\cons\h,(\theta',e'),q}\comp \Pi; \M\backslash\!\!\backslash(a,p') ;
					\s'\cons\mathsf{unregT}(\theta,e,a,p',p)\cons\s \\
					\hspace{20ex}
					\lh  \Gamma;\tuple{p,\h,(\theta,e),q}\:\comp\: \Pi;\M;\s'\cons\s\\
					Se ~ \forall ~ op ~ \mbox{in scrittura o lettura} \in \s' ~  a~\cancel{\varepsilon}~op ~ \mathsf{o} ~ p'~\cancel{\varepsilon}~op
				\end{array}
		}}
		\\[6ex]
		
		\mathcolorbox{yellow}{ (\mathit{\ol{UnregisterF}}) ~ {\displaystyle
				\begin{array}{l}	
					\Gamma;\tuple{p,\mathsf{unregF}(\theta,e,a,p)\cons\h,(\theta,unregFail),q}\comp \Pi; \M; 
					\s'\cons\mathsf{unregF}(\theta,e,a,p) \cons\s  \\
					\hspace{20ex}  \lh  \Gamma;\tuple{p,\h,(\theta,e),q}\:\comp\: \Pi;\M;\s'\cons\s\\
					Se ~ \forall ~ op ~ \mbox{in scrittura} \in \s' ~  a~\cancel{\varepsilon}~op                  	
				\end{array}
				
		}}
		\\[5ex]
		
		\mathcolorbox{yellow}{ (\mathit{\ol{Catch}}) ~ {\displaystyle
				\begin{array}{l}
					\Gamma;\tuple{p,\mathsf{fail}(\theta,e)\cons\h,(\theta,fail),q}\comp \Pi; \M;\s
					\lh
					\Gamma;\tuple{p,\h,(\theta,e),q}\comp \Pi; \M;\s
				\end{array}	
		}}\\[3ex]
	
		\mathcolorbox{yellow}{ (\mathit{\ol{End}}) ~ {\displaystyle
			\begin{array}{l}
				\Gamma;\tuple{p,\mathsf{end}(\theta,\epsilon,a',p)\cons\h,(\theta,\epsilon),q}\comp \Pi,
				\M\backslash\!\!\backslash (a' ,p), \s'\cons\mathsf{end}(\theta,\epsilon,a',p)\cons\s
				\lh  \Gamma;\tuple{p,\h,(\theta,\epsilon),q}\:\comp\: \Pi;\M;\s'\cons\s\\
				Se ~ \forall ~ op ~ \mbox{in scrittura o lettura} \in \s' ~  a'~\cancel{\varepsilon}~op ~ \mathsf{o} ~ p~\cancel{\varepsilon}~op                  
			\end{array}		
	}}
	\end{array}
	\]
	\caption{Backward reversible semantics } \label{fig:backwardsem1}
\end{figure}

\begin{itemize}
	\item Le regole $\ol{\mathit{RegisterT}}$, $\ol{\mathit{RegisterF}}$, $\ol{\mathit{UnregisterT}}$ e $\ol{\mathit{End}}$ sono tutte regole in scrittura sulla mappa che annullano la corrispondente regola forward restituendo il controllo al processo (come tutte le altre regole). Essendo regole in scrittura sulla mappa richiederanno prima di poter essere eseguite l'annullamento di tutte le regole che coinvolgono atomi o pid  coinvolti dalla regola che si vuole annullare.
\end{itemize}
\begin{itemize}
	\item Anche $\ol{\mathit{UnregisterF}}$ è una regola in scrittura ma al contrario delle altre non coinvolge solo un atomo (e non un pid) e quindi da questa regola la side-condidtion richiederà solo che non siano presenti nella storia della mappa operazioni più recenti che coinvolgano l'atomo coinvolto dalla regola.
\end{itemize}

\subsection*{Proprietà della semantica reversibile incontrollata}
Di seguito, dimostriamo diverse proprietà della semantica reversibile mostrata precedentemente.
Dati i sistemi $s_1,s_2$ chiamiamo $s_1\rh^\ast s_2$ derivazione \emph {forward} e $s_2\lh^\ast s_1$ derivazione \emph {backward}.
La derivazione che potenzialmente include sia i passi avanti che quelli indietro è indicata da $s_1\rlh^\ast s_2$.
%
Etichettiamo le transizioni come segue: $s_1\rlh_ {p, r, k} s_2$ dove:
\begin{itemize}
	\item $ p, r $ sono rispettivamente il pid del processo selezionato e l'etichetta della regola applicata,
	\item $ k $ è un elemento della cronologia se la regola applicata è diversa da $ \mathit {Sched} $ e $ \ol {\mathit {Sched}} $ e
	\item $ k = \mathsf {sched} (\{v, \k \}) $ quando la regola applicata è $ \mathit {Sched} $ o $ \ol {\mathit {Sched}} $, dove $ \{v, \ k \} $ è il messaggio consegnato o reinserito in $ \Gamma $. Si nota che le informazioni sono disponibili quando si applica la regola.
\end{itemize}
Si ingnorano alcune etichette quando sono chiare dal contesto.

Estendiamo le definizioni delle funzioni $ \init $ e $ \final $ date nella Sezione~\ref{sect:semantica} a derivazioni reversibili in modo naturale. Anche le nozioni di derivazione componibile, coiniziale e cofinale sono estese in modo semplice.
Data un'etichetta di regola $ r $, lasciamo che $\ol{r} $ denoti la sua versione inversa, ovvero se $ r=\mathit{Send} $ allora $\ol{r}=\ol{\mathit {Send}}$ e viceversa (se $r=\ol{\mathit{Send}}$ allora $\ol{r}=\mathit{Send}$).
		%
Inoltre, data una transizione $ t $, lasciamo che $ \ol{t} =(s'\lh_{p, \ol{r},k} s) $ se $ t = (s \rh_ {p, r, k} s ') $ e $ \ol {t} = (s' \rh_ {p, r, k} s) $ se $ t = (s \lh_ {p, \ol {r}, k} s ') $. Diciamo che $ \ol {t} $ è \emph {inverso} di $ t $.
Questa notazione è naturalmente estesa alle derivazioni.
		
Di seguito limitiamo l'attenzione ai sistemi raggiungibili dall'esecuzione di un programma.

\begin{definition}[Sistema raggiungibile]\label{def:reachable}
	Un sistema è \emph{iniziale} se è composto da un singolo processo, e questo processo ha una cronologia vuota e una coda vuota; inoltre la mailbox globale è vuota. Un sistema $s$ è raggiungibile se esiste un sistema iniziale $s_0$ e una derivazione $s_0 \rlh^\ast s$ utilizzando le regole corrispondenti a un dato programma.\qed
\end{definition}

Le definizioni e i lemmi successivi sono utilizzati per dimostrare che ogni transizione in avanti (risp. indietro) può essere annullata da una transizione all'indietro (risp. avanti), che viene dimostrato nel Lemma~\ref{lemma:loop} .

\begin{definition}[Equivalenza fra storie ($\equiv$)]\label{def:equivS}
Date due storie $\Hi= \Hi_1 : \Hi_2 : op :\Hi_3$ e $\Hi'= \Hi_1 : op : \Hi_2 : \Hi_3$ diciamo che:
	\begin{itemize}
		\item se $op$ è un operazione in lettura tale che $a ~ \varepsilon ~ op $ e $ p ~ \varepsilon ~ op$ e se per ogni  operazione in scrittura $op_1 \in \Hi_2$ vale che $a \cancel{\varepsilon} op_1 $ e $ p  \cancel{\varepsilon} op_1$ allora $\Hi \cong \Hi'$.
		\item se $op$ è un operazione in scrittura tale che $a ~ \varepsilon ~ op $ e $ p ~ \varepsilon ~ op$ e se per ogni operazione in lettura o scrittura $op_1 \in \Hi_2$ vale che $a \cancel{\varepsilon} op_1 $ e $ p  \cancel{\varepsilon} op_1$ allora $\Hi \cong \Hi'$.
		
	\end{itemize} 
	La relazione di equivalenza fra due storie viene indicata col simbolo $\equiv$ ed è la chiusura transitiva e simmetrica della relazione $\cong$ \qed
\end{definition}
\begin{definition}[Trasposizione]
	Data una storia $h=\Hi_1 : \Hi_2 : op :\Hi_3$ e una storia $h'=\Hi_1 : op : \Hi_2 : \Hi_3$ tali per cui $h\cong h'$ si dice che c'è stata la \textbf{trasposizione} di $op$ (con $\Hi_2$).   \qed 
\end{definition}
\begin{corollary}
	La relazione $\equiv$ fra due storie è anche riflessiva.
\end{corollary}
\begin{proof}
	Per vedere che una storia $h$ sia equivalente a se stessa si può sempre considerare $h = \Hi_1 : op : \Hi_2 :\Hi_3 $ con $\Hi_2 = [~]$ ($\Hi_2$ vuoto) e quindi si può mostrare che $\Hi_1 : op : [~] :\Hi_3 \cong \Hi_1 : [~]  : op :\Hi_3$ e quindi che $h \equiv h$
\end{proof}

\begin{lemma}\label{myCorollario0}
	Se $\Hi_1: op : \Hi_2 \cong \Hi_1': op : \Hi_2'$ con trasposizione di $op$ allora $\Hi_1: \Hi_2= \Hi_1': \Hi_2'$.
\end{lemma}
\begin{proof}
	Visto che c'è stata la trasposizione di $op$ togliendo $op$ si ottiene una storia $\Hi_1: \Hi_2= \Hi_1': \Hi_2'$ dove non è presente nessuna trasposizione.
\end{proof}
\begin{lemma}\label{myCorollario1}
	Se $\Hi_1: op : \Hi_2 \cong \Hi_1': op : \Hi_2'$ con trasposizione di $op'\not=op$ con $\Hi_3$(dove $\Hi_3$ parte della storia) allora $\Hi_1: \Hi_2\cong \Hi_1': \Hi_2'$ mediante la trasposizione di $op'$ con $\Hi_3$ o con $\Hi_3$ senza $op$.
\end{lemma}
\begin{proof}
	~
	\begin{itemize}
		\item se $op\in \Hi_3$ la trasposizione di $op'$ con $\Hi_3$ senza $op$ è sempre possibile perché applicata su un sottoinsieme di $\Hi_3$ e quindi la Definizione~\ref{def:equivS} è sempre rispettata;  
		\item se $op\notin \Hi_3$ la trasposizione di $op'$ con $\Hi_3$ è la medesima.
	\end{itemize}
\end{proof}

\begin{corollary}\label{myCorollario2}
	Se  $\Hi_1: op : \Hi_2 \cong \Hi_1': op : \Hi_2'$ allora $\Hi_1: \Hi_2\cong \Hi_1': \Hi_2'$.
\end{corollary}
\begin{proof}
	~
	\begin{itemize}
		\item se c'è trasposizione di $op$ per    Lemma~\ref{myCorollario0};  
		\item se non c'è trasposizione di $op$ per Lemma~\ref{myCorollario1}. 
	\end{itemize}
\end{proof}

\begin{lemma}\label{myCorollario3}
	Se  $\Hi_1: op : \Hi_2 \equiv \Hi_1': op : \Hi_2'$ allora $\Hi_1: \Hi_2\equiv \Hi_1': \Hi_2'$.
\end{lemma}
\begin{proof}
	Per induzione strutturale sull'albero di derivazione della chiusura contestuale la dimostrazione è:\\
	\begin{itemize}
		\item Caso Base:\\
		
		\begin{prooftree} 
			\hypo[]{\Hi_1:op:\Hi_2 \cong \Hi_1':op :\Hi_2'}
			% Conclusion
			\Infer1[]{\Hi_1:op:\Hi_2 \equiv \Hi_1':op :\Hi_2'}           
		\end{prooftree}
		~\\~\\
		
		Da $\Hi_1':op:\Hi_2' \cong \Hi_1:op :\Hi_2$, per il Corollario~\ref{myCorollario2} vale che $\Hi_1:\Hi_2 \cong \Hi_1':\Hi_2'$. Quindi costruisco l'albero:\\ 
		
		\begin{prooftree} 
			\hypo[]{\Hi_1:\Hi_2 \cong \Hi_1':\Hi_2'}
			% Conclusion
			\Infer1[]{\Hi_1:\Hi_2 \equiv \Hi_1':\Hi_2'}           
		\end{prooftree}
		
		
		\item Caso Induttivo:\\
		\begin{itemize}
			\item caso riflessivo:\\
			
			\begin{prooftree} 
				\hypo[]{\Hi_1':op:\Hi_2' \equiv \Hi_1:op :\Hi_2}
				% Conclusion
				\Infer1[]{\Hi_1:op:\Hi_2 \equiv \Hi_1':op :\Hi_2'}           
			\end{prooftree}
			~\\~\\
			
			Per l'ipotesi induttiva su $\Hi_1':op:\Hi_2' \equiv \Hi_1:op :\Hi_2$ si ha $\Hi_1':\Hi_2' \equiv \Hi_1:\Hi_2$. Quindi costruisco l'albero:\\
			
			\begin{prooftree} 
				\hypo[]{\Hi_1':\Hi_2' \equiv \Hi_1:\Hi_2}
				% Conclusion
				\Infer1[]{\Hi_1:\Hi_2 \equiv \Hi_1':\Hi_2'}           
			\end{prooftree}
			
			\item caso transitivo:\\
			
			\begin{prooftree} 
				\hypo[]{\Hi_1:op:\Hi_2 \equiv \Hi_1'':op:\Hi_2''}
				\hypo[]{\Hi_1'':op:\Hi_2'' \equiv \Hi_1':op:\Hi_2'}
				% Conclusion
				\Infer2[]{\Hi_1:op:\Hi_2 \equiv \Hi_1':op:\Hi_2'}           
			\end{prooftree}
			~\\~\\
			
			Per l'ipotesi induttiva su $\Hi_1:op:\Hi_2 \equiv \Hi_1'':op :\Hi_2''$ e\\ $\Hi_1'':op:\Hi_2'' \equiv \Hi_1':op :\Hi_2'$ si ha $\Hi_1:\Hi_2 \equiv \Hi_1'':\Hi_2''$ e $\Hi_1'':\Hi_2'' \equiv \Hi_1':\Hi_2'$. Quindi costruisco l'albero:\\
			
			\begin{prooftree} 
				\hypo[]{\Hi_1:\Hi_2 \equiv \Hi_1'':\Hi_2''}
				\hypo[]{\Hi_1'':\Hi_2'' \equiv \Hi_1':\Hi_2'}
				% Conclusion
				\Infer2[]{\Hi_1:\Hi_2 \equiv \Hi_1':\Hi_2'}           
			\end{prooftree}
		\end{itemize}
			\end{itemize}
\end{proof}

Due processi nella forma $\tuple{p,\h,(\theta,e),q}$ sono equivalenti se tutti gli elementi sono uguali (la lista $\h$ di operazione deve essere uguale perché se no i processi avrebbero fatto operazioni diverse e quindi non sarebbero uguali).

\begin{definition} [Equivalenza fra sistemi ($\equiv$)]\label{def:equiv} Due sistemi $s_1 = (\Gamma_1,\Pi_1,\M_1,\Hi) $ e $s_2 = (\Gamma_2,\Pi_2,\M_2,\Hi')$ sono equivalenti se: 
	\begin{itemize}
		\item $\Gamma_1 = \Gamma_2$
		\item $ \Pi_1 = \Pi_2$
		\item $ \M_1 = \M_2$
		\item $ \Hi \equiv \Hi' $ 
	\end{itemize}
	Due sistemi $s_1, s_2$ equivalenti vengono  indicati con $s_1 \equiv s_2$.\qed
\end{definition}

\begin{lemma} \label{lemma:my3}
	Dato un sistema $s$ con storia $h = \Hi_2~op~\Hi_1 $ in cui è possibile applicare $\ol{op}$ e un sistema $s'\equiv s$ con storia	$h' = \Hi_2'~op~\Hi_1' $  allora  è possibile applicare $\ol{op}$ a $s'$. 
\end{lemma}
\begin{proof}
	In $s$ è possibile applicare $\ol{op}$ quindi:
	\begin{itemize}
		\item se $\ol{op}$ è in lettura e $a~\varepsilon~\ol{op}$ e $p~\varepsilon~\ol{op}$, allora in $\Hi_2$ non sono presenti operazioni in scrittura tali che $a~\varepsilon~op_1$ o $p~\varepsilon~op_1$;
		\item se $\ol{op}$ è in scrittura e $a~\varepsilon~\ol{op}$ e $p~\varepsilon~\ol{op}$, allora in $\Hi_2$ non sono presenti operazioni in scrittura o lettura tali che $a~\varepsilon~op_1$ o $p~\varepsilon~op_1$.
	\end{itemize}
	Visto che $s\equiv s'$ allora anche $h\equiv h'$ per la Definizione~\ref{def:equiv}.
	Per applicare $\ol{op}$ in $s'$ bisogna che le side-condition della regola vengano rispettate in $h'$ e quindi che:
	\begin{itemize}
		\item se $\ol{op}$ è in lettura e $a~\varepsilon~\ol{op}$ e $p~\varepsilon~\ol{op}$  allora in $\Hi_2'$ non devono essere presenti operazioni in scrittura tali che $a~\varepsilon~op_1$ o $p~\varepsilon~op_1$;
		\item se $\mathsf{\ol{op}}$ è in scrittura e $a~\varepsilon~\ol{op}$ e $p~\varepsilon~\ol{op}$  allora in $\Hi_2'$ non devono essere presenti operazioni in scrittura o lettura tali che $a~\varepsilon~op_1$ o $p~\varepsilon~op_1$;
	\end{itemize}
	questo è rispettato in entrambi i casi per la Definizione~\ref{def:equivS} (di equivalenza fra storie), visto che è possibile applicare $\ol{op}$ in $s$ allora non ci possono essere trasposizioni in $h'$ che violino le side-condition della regola $\ol{op}$, e quindi è possibile applicare $\ol{op}$ a $s'$. 
\end{proof}

\begin{lemma} \label{lemma:my4}
	
	Dato un sistema $s_1$ con storia $h = \Hi_2~op~\Hi_1$ in cui è possibile applicare $\ol{op}$ ottenendo $s_1'$ e un sistema $s_2\equiv s_1$ con  storia $h' = \Hi_2'~op~\Hi_1'$ allora applicando $\ol{op}$ a $s_2$ si ottiene un sistema $s_2'\equiv s_1'$.
\end{lemma}
\begin{proof}
	Per il Lemma~\ref{lemma:my3} è possibile applicare $\ol{op}$ anche ad $s_2$. \\
	Applicando $\ol{op}$ a $s_1$ si ottiene $s_1'$ con storia $\Hi_2:\Hi_1$, mentre applicando $\ol{op}$ a $s_2$  si ottiene $s_2'$ con storia $\Hi_2':\Hi_1'$.\\
	Per il Lemma~\ref{myCorollario3} si vede che $\Hi_2:\Hi_1\equiv\Hi_2':\Hi_1'$ e quindi che $s_1'\equiv s_2'$.
\end{proof}

\begin{lemma}\label{lemma:my1}
	Se $s_1 \equiv s_1' $ e $ s_1 \rlh_ {p, r, k} s_2$ allora $\exists~s_2'$  t.c. $s_2\equiv s_2'$  e $s_1' \rlh_ {p, r, k} s_2'$
\end{lemma}
\begin{proof}
	La dimostrazione si divide in due parti:
	\begin{itemize}
		\item se $r$ è forward la dimostrazione si divide in due casi:
		\begin{itemize}
			\item nel caso l'operazione non sia sulla mappa è facile mostrare che  applicando a $s_1'$  la stessa transizione, applicata a $s_1$, muova in uno stato $s_2'$ equivalente a $s_2$.  Se la modifica effettuata al sistema è la stessa allora anche $\Gamma $ e $\Pi$ saranno uguali a quelli di $s_2$ e non essendo stata modificata la mappa allora anch'essa e la sua storia saranno equivalenti;
			\item nel caso l'operazione sia sulla mappa invece per dimostrare l'equivalenza di $s_2$ e $s_2'$ bisognerà mostrare l'equivalenza fra le storie della dei due sistemi.\\
			In questo caso sappiamo che la storia di $s_1$ indicata con $\Hi_1$ è equivalente alla storia di $s_1'$ indicata con $\Hi_1'$. Inoltre sappiamo anche che applicando a $s_1'$ la regola $r$ si muoverà in $s_2'$ con storia $\Hi_2'= \Hi_1' : op$. Applicando la regola a $s_1$ si muoverà in uno stato $s_2$ con storia $\Hi_2 = \Hi_1 : op$. È facile vedere che $\Hi_2 \equiv \Hi_2'$ visto che $\Hi_1 \equiv \Hi_1'$ ed è stato aggiunto alla fine della storia lo stesso elemento;
		\end{itemize}
		\item se $r$ è backward la dimostrazione si divide in due casi:
		\begin{itemize}
			\item nel caso l'operazione non sia sulla mappa se si applica la stessa regola backward a due sistemi equivalenti allora muoveranno in due sistemi equivalenti visto che le modifiche al sistema sono le stesse (la mappa e la sua storia non vengono modificate per questo rimarranno equivalenti);
			\item nel caso l'operazione sia sulla mappa per il Lemma~\ref{lemma:my3} è possibile applicare a $s_1'$ la regola backward $r$. L'equivalenza di $s_2$ e $s_2'$ si può vedere grazie al Lemma~\ref{lemma:my4}.
		\end{itemize}
	\end{itemize}
\end{proof}

\begin{lemma}[Loop lemma] \label{lemma:loop} Per ogni coppia di sistemi raggiungibili,
	$s_1$ e $s_2$, si ha $s_1 \rh_{p,r,k} s_2$ sse $s_2
	\lh_{p,\ol{r},k} s_1'$ tale per cui  $s_1\equiv s_1'$.
\end{lemma}
\begin{proof}
	La prova è l'analisi dei casi sulla regola applicata. 
	Discutiamo di seguito i casi più interessanti.
	\begin{itemize}
		\item Regola forward sulla mappa: in questo caso applicare successivamente la regola backward corrispondente è possibile perché vengono rispettate tutte le condizioni richieste, visto che l'ultima regola applicata alla mappa è quella forward. In questo caso si può facilmente vedere che si torna allo stato originale.
		\item  Regola backward sulla mappa: in questo caso se si può applicare la regola backward vuol dire che sono rispettate tutte le condizioni richieste dalla regola. Al sistema quindi sarà possibile applicare la regola forward successivamente tornado ad uno stato equivalente al precedente, questo perché se sono state rispettate le condizioni imposte dalla regola allora nella storia, nel caso in cui la regola di backward sia in lettura, non sono presenti operazioni in scrittura che coinvolgono gli stessi atomi o pid coinvolti dalla regola forward, nel caso in cui la regola sia in scrittura allora nella storia non sono presenti operazioni in scrittura o lettura che coinvolgono gli stessi atomi o pid coinvolti dalla regola forward.
	\end{itemize}
\end{proof}


\begin{definition}[Transizioni concorrenti] \label{def:concurrent}
	Date due transizioni coiniziali, $t_1 = (s \rlh_{p_1,r_1,k_1} s_1)$
	e $t_2 = (s \rlh_{p_2,r_2,k_2} s_2)$, diciamo che sono
	\emph{in conflitto} se almeno una delle seguenti condizioni sussiste:
	\begin{itemize}
		\item Le regole viste nella Tabella~\ref{tab:conflitti} presente nella definizione~\ref{def:concurrent1} + definizione articolo 
		\item nel caso in cui entrambe le transizioni siano sulla mappa, le transizioni accedono agli stessi pid o atomi e se una delle due transizioni è in scrittura sulla mappa (se entrambe le transizioni sono in lettura il conflitto non è presente).
		\item nel caso in cui entrambe le transizioni siano sulla mappa e inoltre una transizione sia \textbf{forward} e l'altra transizione sia \textbf{backward} tali per cui:
		
		\begin{table}[h!]
			\hspace{-17ex}
			\begin{tabular}{@{}|l|l|l|l|l|l|l|l|l|@{}}
				\hline
				\backslashbox{$~r_1~~$} {$~~r_2~$} &  $\ol{\mathsf{RegisterT}}$&  $\ol{\mathsf{UnregisterT}}$& $\ol{\mathsf{End}}$ & $\ol{\mathsf{SendA}}$ & $\ol{\mathsf{SendF}}$ & $\ol{\mathsf{RegisterF}}$ & $\ol{\mathsf{UnregisterF}}$ & $\ol{\mathsf{Call3}}$ \\ \hline
				$\mathsf{RegisterT}$   &       & \begin{tabular}[c]{@{}l@{}}$a'=a'' ~\lor$ \\ $ p' =p''$ \end{tabular}              &      \begin{tabular}[c]{@{}l@{}}$a'=a'' ~\lor$ \\ $ p' =p''$ \end{tabular}     &       &   $a' = a''$    &     &      $a' = a''$       & \begin{tabular}[c]{@{}l@{}}$a'  \in \M' ~\lor$ \\ $ p' \in \M'$\end{tabular}        \\ \hline
				
				$\mathsf{UnregisterT}$ &    \begin{tabular}[c]{@{}l@{}}$a'=a'' ~\lor$ \\ $ p' =p''$ \end{tabular}    &             &           &   \begin{tabular}[c]{@{}l@{}}$a'=a'' ~\lor$ \\ $ p' =p''$ \end{tabular}    &  &  \begin{tabular}[c]{@{}l@{}}$a'=a'' ~\lor$ \\ $ p' =p''$ \end{tabular}   &             &               \begin{tabular}[c]{@{}l@{}}$a'  \in \M' ~\lor$ \\ $ p' \in \M'$\end{tabular}                 \\ \hline
				
				$\mathsf{End}$         &    \begin{tabular}[c]{@{}l@{}}$a'=a'' ~\lor$ \\ $ p' =p''$ \end{tabular}    &             &           &   \begin{tabular}[c]{@{}l@{}}$a'=a'' ~\lor$ \\ $ p' =p''$ \end{tabular}    &  &  \begin{tabular}[c]{@{}l@{}}$a'=a'' ~\lor$ \\ $ p' =p''$ \end{tabular}   &             &               \begin{tabular}[c]{@{}l@{}}$a'  \in \M' ~\lor$ \\ $ p' \in \M'$\end{tabular}                 \\ \hline
				
				$\mathsf{SendA}$       &   \begin{tabular}[c]{@{}l@{}}$a'=a'' ~\lor$ \\ $ p' =p''$ \end{tabular}    &            &           &       &       &                          &                                  &                                \\ \hline
				
				$\mathsf{SendF}$       &       &          $a'=a''$    &      $a'=a''$      &       &                            &                          &                                  &                                \\ \hline
				
				$\mathsf{RegisterF}$   &  \begin{tabular}[c]{@{}l@{}}$a'=a'' ~\lor$ \\ $ p' =p''$ \end{tabular}     &             &           &                            &                            &                          &                                  &                                \\ \hline
				
				$\mathsf{UnregisterF}$ &       &    $a'=a''$         &   $a'=a''$                              &                            &                            &                          &                                  &                                \\ \hline
				
				$\mathsf{Call3}$       &     \begin{tabular}[c]{@{}l@{}}$a'  \in \M' ~\lor$ \\ $ p' \in \M'$\end{tabular}  &                 \begin{tabular}[c]{@{}l@{}}$a'  \in \M' ~\lor$ \\ $ p' \in \M'$\end{tabular}                 &          \begin{tabular}[c]{@{}l@{}}$a'  \in \M' ~\lor$ \\ $ p' \in \M'$\end{tabular}                      &                            &                            &                          &                                  &                                \\ \hline
			\end{tabular}
			\caption{\label{tab:conflitti1} Tabella dei conflitti.}
		\end{table}
		
		Nella Tabella~\ref{tab:conflitti1} sono presenti i casi in cui si verificano i conflitti, $a'$ e $p'$ rappresentano l'atomo e il pid coinvolti da $r_1$, mentre $a''$ e $p''$ rappresentano l'atomo e il pid coinvolto da $r_2$. $\M'$ rappresenta gli elementi letti nella mappa dalla regola $\mathsf{Call3}$ o $\ol{\mathsf{Call3}}$. Le celle vuote rappresentano transizioni coiniziali che non vanno in conflitto.\\
		Da notare che,anche in questo caso, non tutte le operazioni in scrittura sulla mappa sono in conflitto fra di loro, questo perché in quei casi le transizioni non possono essere coiniziali e in conflitto. 
	\end{itemize}
	%
	Due transizioni coiniziali sono \emph{concorrenti} se non sono in conflitto. \qed
\end{definition}
%
Il seguente lemma è la controparte del Lemma~\ref{lemma:square} per la semantica standard.

\begin{lemma}[Square lemma] \label{lemma:square} Date due operazioni coiniziali concorrenti $t_1 = (s \rlh_{p_1,r_1,k_1} s_1)$ e
	$t_2 = (s \rlh_{p_2,r_2,k_2} s_2)$, allora esistono due transizioni $t_2/t_1 = (s_1 \rlh_{p_2,r_2,k_2} s')$,
	$t_1/t_2 = (s_2 \rlh_{p_1,r_1,k_1} s'')$ tali per cui $s' \equiv s''$.  Graficamente,
	\[
	\begin{minipage}{50ex}
		\xymatrix@C=50pt@R=20pt{
			s \ar@<1pt>@^{->}[r]^{p_1,r_1,k_1} \ar@<1pt>@^{->}[d]_{p_2,r_2,k_2} & s_1 \ar@<1pt>@^{->}[l]\\
			s_2 \ar@<1pt>@^{->}[u]& 
		}
	\end{minipage}
	~~
	\Longrightarrow
	~~
	\begin{minipage}{50ex}
		\xymatrix@C=50pt@R=20pt{
			s \ar@<1pt>@^{->}[r]^{p_1,r_1,k_1} \ar@<1pt>@^{->}[d]_{p_2,r_2,k_2} & s_1 \ar@<1pt>@^{->}[d]^{p_2,r_2,k_2} \ar@<1pt>@^{->}[l]\\
			s_2 \ar@<1pt>@^{->}[r]_{p_1,r_1,k_1} \ar@<1pt>@^{->}[u] & s'' \equiv s' ~~~~~~ \ar@<1pt>@^{->}[u] \ar@<1pt>@^{->}[l]
		}
	\end{minipage}
	\]
\end{lemma}

\begin{proof}
	Distinguiamo i seguenti casi a seconda delle regole applicate: \\ [1ex]
	(1) Due transizioni forward. Quindi, abbiamo i seguenti casi:
	\begin{itemize}
		\item $r_1= \mathsf{End}$ e $r_2=\mathsf{RegisterF}$ nel caso in cui %(accedono a pid e atomi diversi) 
		$a~\varepsilon~r_1$, $p_1~\varepsilon~r_1$, $a'~\varepsilon~r_2$ e $p'~\varepsilon~r_2$ dove $a$ e $a'$ sono atomi e $p'$ è un pid:
		\begin{itemize}
			\item se $a\not= a'$ e $p_1 \not= p'$ si può vedere che applicando prima la transizione $t_1$ e poi la $t_2$ o viceversa si arriva in due stati rispettivamente $s'$ e $s''$ che sono equivalenti perché la mappa è la stessa mentre la storia della mappa differisce per gli ultimi elementi che sono scambiati ma visto che $a\not= a'$ e $p_1 \not= p'$ rispetta la Definizione~\ref{def:equivS} (equivalenza fra storie) e quindi $s'\equiv s''$. 
			\item  se $a= a'$ o $p_1 = p'$ le due operazioni sono in conflitto (vedere Tabella~\ref{tab:conflitti}).
		\end{itemize}
		\item questo ragionamento si può effettuare su tutte le regole sulla mappa 
	\end{itemize}
	(2) Una transizione forward e una transizione backward. Quindi, distinguiamo i seguenti casi:
	\begin{itemize}
		\item $r_1 = \mathsf{RegisterT}$ e $r_2= \mathsf{\ol{UnregisterT}}$ nel caso in cui %(accedono a pid e atomi diversi) 
		$a~\varepsilon~r_1$, $p~\varepsilon~r_1$, $a'~\varepsilon~r_2$ e $p'~\varepsilon~r_2$ dove $a$ e $a'$ sono atomi e $p$ e $p'$ sono pid:
		\begin{itemize}
			\item se $a\not= a'$ e $p \not= p'$ allora applicando prima la transizione $t_1$ e poi $t_2$ o viceversa si ottengono due transizioni $t_1/t_2$ e $t_2/t_1$ che finiscono in due stati che sono equivalenti (la storia della mappa sarà la stessa sia in $s'$ che in $s''$).
			\item se $a= a'$ o $p = p'$ le due operazioni sono in conflitto (vedere Tabella~\ref{tab:conflitti1}).
		\end{itemize}
		\item questo ragionamento si può effettuare su tutte le regole sulla mappa 
	\end{itemize}
	(3) Due transizioni backward. Quindi, distinguiamo i seguenti casi:
	\begin{itemize}
		\item Nel caso di due operazioni sulla mappa (o anche in cui solo una è sulla mappa) è sempre verificato: 
		\begin{itemize}
			\item nel caso in cui entrambe le operazioni backward sono sulla mappa allora vuol dire che le condizioni di entrambe le regole sono rispettate, quindi sarà indifferente applicare prima una o l'altra (la storia della mappa sarà la stessa sia in $s'$ che in $s''$).
			\item nel caso in cui una regola è sulla mappa e l'altra non lo è allora le condizioni di entrambe le regole sono rispettate, applicare prima la regola sulla mappa o prima la regola non sulla mappa non cambia il risultato (la storia della mappa sarà la stessa sia in $s'$ che in $s''$). 
		\end{itemize}
	\end{itemize}
\end{proof}

\begin{lemma}[Confluenza] \label{lemma:square*} Date due operazioni coiniziali concorrenti $t_1 = (s \rlh^* s_1)$ e
	$t_2 = (s \rlh^* s_2)$, allora $t_2/t_1^* = (s_1 \rlh^* s')$,
	$t_1/t_2^* = (s_2 \rlh* s'')$ tali per cui $s' \equiv s''$.  Graficamente,
	\[
	\begin{minipage}{50ex}
		\xymatrix@C=50pt@R=20pt{
			s \ar@<1pt>@^{->}[r]^{*} \ar@<1pt>@^{->}[d]_{*} & s_1 \ar@<1pt>@^{->}[l]\\
			s_2 \ar@<1pt>@^{->}[u]& 
		}
	\end{minipage}
	~~
	\Longrightarrow
	~~
	\begin{minipage}{50ex}
		\xymatrix@C=50pt@R=20pt{
			s \ar@<1pt>@^{->}[r]^{*} \ar@<1pt>@^{->}[d]_{*} & s_1 \ar@<1pt>@^{->}[d]^{*} \ar@<1pt>@^{->}[l]\\
			s_2 \ar@<1pt>@^{->}[r]_{*} \ar@<1pt>@^{->}[u] & s'' \equiv s' ~~~~~~ \ar@<1pt>@^{->}[u] \ar@<1pt>@^{->}[l]
		}
	\end{minipage}
	\]
\end{lemma}
\begin{proof}
	Per il Lemma~\ref{lemma:my1} è possibile applicare una stessa regola a stati equivalenti e ottenere due stati equivalenti. Quindi è possibile iterare più volte il Lemma \ref{lemma:square} a stati equivalenti. Formalmente la prova avviene per induzione sul numero di passi e poi applicando il Lemma~\ref{lemma:my1} e \ref{lemma:square}, $m$ volte (dove $m$ è il numero di passi su cui non si è fatta induzione).   
\end{proof}
La dimostrazione è per induzione sul numero di passi:
\begin{itemize}
	\item Caso base:
	\[
	\begin{minipage}{50ex}
		\xymatrix@C=50pt@R=20pt{
			s \ar@<1pt>@^{->}[r]^{m} \ar@<1pt>@^{->}[d]_{0} & s_1 \ar@<1pt>@^{->}[d]^{0} \ar@<1pt>@^{->}[l]\\
			s \ar@<1pt>@^{->}[r]_{m} \ar@<1pt>@^{->}[u] & s_1 \ar@<1pt>@^{->}[u] \ar@<1pt>@^{->}[l]
		}
	\end{minipage}
	\]
	\item Caso induttivo ($n+1$)
	\[
	\begin{minipage}{50ex}
		\xymatrix@C=50pt@R=20pt{
			s \ar@<1pt>@^{->}[r]^{m} \ar@<1pt>@^{->}[d]_{n} & s_1 \ar@<1pt>@^{->}[d]^{n} \ar@<1pt>@^{->}[l]\\
			i \ar@<1pt>@^{->}[r]_{m} \ar@<1pt>@^{->}[u] \ar@<1pt>@^{->}[d] & i'' \equiv i' ~~~~~~ \ar@<1pt>@^{->}[u]  \ar@<1pt>@^{->}[d]^{1}\ar@<1pt>@^{->}[l]\\
			s_2 \ar@<1pt>@^{->}[r] \ar@<1pt>@^{->}[u]^{1}   & s'' \equiv s' ~~~~~\ar@<1pt>@^{->}[u] \ar@<1pt>@^{->}[l]^{m} 
		}
	\end{minipage}
	\]
	\[
	\begin{minipage}{50ex}
		\xymatrix@C=50pt@R=20pt{
			i \ar@<1pt>@^{->}[r]^{1} \ar@<1pt>@^{->}[d]_{1} & i_1 \ar@<1pt>@^{->}[d]_{1} \ar@<1pt>@^{->}[l] \ar@<1pt>@^{->}[r]^{1} \ar@<1pt>@^{->}[d]\ar@<1pt>@^{->}[l]& \dots \ar@<1pt>@^{->}[r]^{1} \ar@<1pt>@^{->}[d] \ar@<1pt>@^{->}[d]_{1}\ar@<1pt>@^{->}[l]& i''\equiv i'~~~~ \ar@<1pt>@^{->}[d]_{1} \ar@<1pt>@^{->}[l]\\
			s_2 \ar@<1pt>@^{->}[r]_{1} \ar@<1pt>@^{->}[u] & i_1'\equiv i_1''~~~ \ar@<1pt>@^{->}[u] \ar@<1pt>@^{->}[l] \ar@<1pt>@^{->}[r]_{1} & \dots \ar@<1pt>@^{->}[u] \ar@<1pt>@^{->}[u] \ar@<1pt>@^{->}[l] \ar@<1pt>@^{->}[r]_{1} & s''\equiv s' ~~~~~\ar@<1pt>@^{->}[u] \ar@<1pt>@^{->}[l] 
		}
	\end{minipage}
	\]
	
\end{itemize}

\section{Semantica rollback}\label{sect:semrollback}

In questa sezione introdurremo un operatore di rollback che avvia un calcolo reversibile per un processo.
L'operazione di annullamento (non deterministica) ha alcune somiglianze con l'operatore di rollback di \cite{LMSS11, GLM14}.
I processi vengono messi in modalità di ``rollback'' utilizzando $\lfloor ~ \rfloor_\Psi$, dove $ \Psi $ è l'insieme di rollback. 
Un tipico rollback si riferisce a un checkpoint che deve essere superato da una computazione backward del processo prima di riprendere una computazione forward.
Per essere precisi, distinguiamo le seguenti tipologie di rollback:

\begin{itemize}
	\item $\#_\mathsf{ch}^\mathtt{t}$, dove ``$\mathsf{ch}$'' sta per ``checkpoint'': un rollback per annullare le azioni di un processo fino a che non ha raggiunto il checkpoint con identificatore $\mathtt {t}$;
	\item $\#_\mathsf{sp}$, dove ``$ \mathsf{sp}$'' sta per ``spawn'': un rollback per annullare \emph{tutte} le azioni di un processo, infine cancellandolo dal sistema;
	\item $ \#_\mathsf {sch}^{\k}$, dove ``$\mathsf{sch}$'' sta per ``sched'': un rollback per annullare le azioni di un processo fino alla consegna di un messaggio nella forma $\{v, \k \}$ non è annullata.
	\item $\#_\mathsf{op}^\mathtt{par}$: richiede un rollback per annullare le azioni di un processo fino a quando non viene raggiunto l'operatore con identificatore $\mathtt{op(par)}$;
	\item $\#_\mathsf{([a],[p]),t}^\mathsf{S'}$: si applica ad un insieme di processi $\Pi$, 
	\begin{itemize}
		\item se $S'=\emptyset$ allora $\lfloor\Pi\rfloor_{\#_\mathsf{([a],[p]),t}^\emptyset} = \Pi$
		\item se $S'\not=\emptyset$ allora $\lfloor\Pi\rfloor_{\#_\mathsf{([a],[p]),t}^{\mathsf{S'}}} = \lfloor\Pi'\rfloor_{\#_\mathsf{([a],[p]),t}^{\mathsf{S''}}}$ dove $\mathsf{S'} = op(par):\mathsf{S''}$ e dove:
		\begin{itemize}
			\item se $a \centernot\varepsilon op(par)$ e $p \centernot\varepsilon op(par)$ allora $\Pi' = \Pi$
			\item se $a~ \varepsilon~op(par)$ o $p ~\varepsilon~op(par)$ allora $\Pi' = \Pi~\cup~\{newproc\}~\backslash~\{proc\}$ dove:
			\begin{itemize}
				\item $proc = \lfloor\tuple{p',(\theta,e),q,h}\rfloor_{\Psi} \in \Pi$ (è il processo che ha eseguito l'operazione $op(par)$ che viene identificato da $p'$ che è presente in $par$);
				\item $newproc = \lfloor\tuple{p',(\theta,e),q,h}\rfloor_{\Psi'}$ con $\Psi' = \Psi\cup \#_{op}^{par}$ se $\#_{op}^{par}\not\in\Psi$, o altrimenti $\Psi' = \Psi$
			\end{itemize}
		\end{itemize}
		Se $t=l$ allora $\Pi' = \Pi$ anche se $op(par)$ è un'operazione in lettura.
	\end{itemize}
\end{itemize}

Di seguito, al fine di semplificare le regole di riduzione, consideriamo che la nostra semantica soddisfa la seguente \emph{equivalenza strutturale}:
\[
\begin{array}{ll}
	(\mathit{SC}) & {\displaystyle
		\Gamma;
		\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_{\emptyset}
		\:\comp\: \Pi
		~\equiv~
		\Gamma;\tuple{p,\h,(\theta,e),q}\:\comp\: \Pi
	}
\end{array}
\]
Nota che solo il primo dei tipi di rollback sopra indicati è destinato a un ~checkpoint. Questo tipo di checkpoint è introdotto in modo non deterministico dalla regola seguente, dove indichiamo con $\lhh$ la nuova relazione di riduzione che modella i movimenti all'indietro della semantica di rollback:
\[
\begin{array}{ll}
	(\mathit{\ol{Undo}}) & {\displaystyle
		\Gamma;
		\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_{\Psi}
		\:\comp\: \Pi
		\lhh
		\Gamma;\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_{\Psi\cup\{\#_\mathsf{ch}^\mathtt{t}\}}\:\comp\: \Pi
	}
	\\[1ex] & \mbox{if } \mathsf{check}(\theta',e',\mathtt{t}) \mbox{ occurs
		in } \h, ~\mbox{for some $\theta'$ and $e'$}
\end{array}
\]
Solo dopo l'applicazione di questa regola i passaggi possono essere annullati, poiché il calcolo predefinito nella semantica di rollback è in avanti.

Le regole backward della semantica di rollback sono mostrate nelle Figure~\ref{fig:rollsem0},~\ref{fig:rollsem1}~e~\ref{fig:rollsem2}. Si assume che $\Psi\neq\emptyset$ (ma $\Psi'$ potrebbe essere vuoto).

\begin{figure}[h!]
	\footnotesize
	\[
	\hspace{-3ex}
	\begin{array}{r@{~~}l}
		(\mathit{\ol{Seq}}) & {\displaystyle
			\Gamma;
			\lfloor\tuple{p,\tau(\theta,e)\cons\h,(\theta',e'),q}\rfloor_{\Psi}
			\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
			\lhh  \Gamma;\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_{\Psi}\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
		}
		\\[2ex]
		
		(\mathit{\ol{Check}}) & {\displaystyle
			\Gamma;
			\lfloor\tuple{p,\mathsf{check}(\theta,e,\mathtt{t})\cons\h,(\theta',e'),q}\rfloor_{\Psi}
			\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
			\lhh  \Gamma;\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_{\Psi\setminus\{\#_\mathsf{ch}^\mathtt{t}\}}\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
		} 
		\\[2ex]
		
		(\mathit{\ol{Send1}}) & {\displaystyle
			\begin{array}{l}
				\Gamma\cup\{(p',\{v,\k\})\};\lfloor\tuple{p,\mathsf{send}(\theta,e,p',\{v,\k\})\cons\h,(\theta',e'),q}\rfloor_{\Psi}\:\comp\:
				\Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
				\lhh \Gamma;\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_{\Psi} 
				\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}\\
			\end{array}
		}\\[2ex]
		
		(\mathit{\ol{Send2}}) & {\displaystyle
			\begin{array}{l}
				\Gamma;\lfloor\tuple{p,\mathsf{send}(\theta,e,p',\{v,\k\})\cons\h,(\theta',e'),q}\rfloor_{\Psi}\:\comp\:
				\lfloor\tuple{p',\h',(\theta'',e''),q'}\rfloor_{\Psi'}\:\comp\:\Pi;\mathcolorbox{yellow}{\mathsf{M;S}}\\
				\lhh 
				\Gamma;\lfloor\tuple{p,\mathsf{send}(\theta,e,p',\{v,\k\})\cons\h,(\theta',e'),q}\rfloor_{\Psi}\:\comp\:
				\lfloor\tuple{p',\h',(\theta'',e''),q'}\rfloor_{\Psi'\cup\{\#_\mathsf{sch}^\k\}}\:\comp\:
				\Pi;\mathcolorbox{yellow}{\mathsf{M;S}}\\
				\hspace{20ex}\mbox{if}~(p',\{v,\k\})~\mbox{does not
					occur
					in}~\Gamma~\mbox{and}~\#_\mathsf{sch}^{\k}\not\in\Psi'
			\end{array}
		}\\[5ex]
		
		(\mathit{\ol{Receive}}) & {\displaystyle
			\Gamma;\lfloor\tuple{p,\mathsf{rec}(\theta,e,\{v,\k\},q)\cons\h,(\theta',e'), q\backslash\!\!\backslash\{v,\k\}}\rfloor_{\Psi}\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
			\lhh  \Gamma;\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_{\Psi}\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
		}
		\\[2ex]
		
		(\mathit{\ol{Spawn1}}) & {\displaystyle
			\begin{array}{l}
				\Gamma;\lfloor\tuple{p,\mathsf{spawn}(\theta,e,p'')\cons\h,(\theta',e'),q}\rfloor_{\Psi}
				\:\comp\: 
				\lfloor\tuple{\nil,p'',(\theta'',e''),\nil}\rfloor_{\Psi'}
				\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
				\\
				\hspace{20ex}\lhh
				\Gamma;\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_{\Psi}
				\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}} 
			\end{array}
		}\\[3ex]
		
		(\mathit{\ol{Spawn2}}) & {\displaystyle
			\begin{array}{l}
				\Gamma;\lfloor\tuple{p,\mathsf{spawn}(\theta,e,p'')\cons\h,(\theta,e),q}\rfloor_{\Psi}
				\:\comp\: 
				\lfloor\tuple{p'',\h'',(\theta'',e''),q''}\rfloor_{\Psi'}
				\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}} 
				\\
				\hspace{0ex}\lhh
				\Gamma;\lfloor\tuple{p,\mathsf{spawn}(\theta,e,p'')\cons\h,(\theta,e),q}\rfloor_{\Psi}
				\:\comp\: 
				\lfloor\tuple{p'',\h'',(\theta'',e''),q''}\rfloor_{\Psi'\cup\{\#_\mathsf{sp}\}}
				\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}} \\
				\hspace{20ex}\mbox{if}~\h''\neq\nil \lor q''\neq\nil~\mbox{and}~\#_\mathsf{sp}\not\in\Psi'
			\end{array}
		}\\[4ex]
		
		
		(\mathit{\ol{Self}}) & {\displaystyle
			\Gamma;\lfloor\tuple{p,\mathsf{self}(\theta,e)\cons\h,(\theta',e'),q}\rfloor_{\Psi} 
			\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}} \lhh
			\Gamma;\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_{\Psi} 
			\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}  
		}\\[2ex]
		
		(\mathit{\ol{Sched}}) & {\displaystyle
			\begin{array}{l}
				\Gamma;\lfloor\tuple{p,\h,(\theta,e),\{v,\k\}\cons q}\rfloor_{\Psi} \: \comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}} \lhh 
				\Gamma\cup(p,\{v,\k\});\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_{\Psi\setminus\{\#_\mathsf{sch}^\k\}}\:\comp\:\Pi;\mathcolorbox{yellow}{\mathsf{M;S}}\\
				\hspace{20ex} %%\mbox{if}~\#_\mathsf{sch}^\k\not\in\Psi
				%%~\mbox{and 
				\mbox{if the topmost $\mathsf{rec}(\ldots)$ item in
					$\h$ (if any) has the}\\ 
				\hspace{20ex}\mbox{form}~\mathsf{rec}(\theta',e',\{v',\k'\},q')~\mbox{with}~q'\backslash\!\!\backslash\{v',\k'\}\neq
				\{v,\k\}\cons q
			\end{array}
		}
	\end{array}
	\]
	\caption{Rollback semantics: backward reduction rules} \label{fig:rollsem0}
\end{figure}

\begin{figure}[h!]
	\footnotesize
	\[
	\hspace{-3ex}
	\begin{array}{l@{~~}l}
		
		
		\mathcolorbox{yellow}{ (\mathit{\ol{SendA1}}) ~~ {\displaystyle
				\begin{array}{l}
					\Gamma\cup\{(p',\{v,\k\})\};\lfloor\tuple{p,\mathsf{sendA}(\theta,e,p',\{v,\k\})\cons\h,(\theta',e'),q}\rfloor_{\Psi}\:\comp\:
					\Pi;\\\mathsf{S'}\cons\mathsf{sendA}(\theta,e,p',\{v,\k\},a,p)\cons\mathsf{S}
					\lhh \Gamma;\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_{\Psi} 
					\:\comp\: \Pi ; \mathsf{S'}\cons\mathsf{S}\\
					Se ~ \forall ~ op ~ \mbox{in scrittura} \in \mathsf{S'} ~  a \centernot\varepsilon op        
					%\mbox{Se in S' non sono presenti operazioni di scrittura sulla mappa che coinvolgono l'atomo a}
				\end{array}
		}}\\[4ex]
		
		\mathcolorbox{yellow}{ (\mathit{\ol{SendA2}}) ~~ {\displaystyle
				\begin{array}{l}
					\Gamma\cup\{(p',\{v,\k\})\};\lfloor\tuple{p,\mathsf{sendA}(\theta,e,p',\{v,\k\})\cons\h,(\theta',e'),q}\rfloor_{\Psi}\:\comp\: \Pi;
					\mathsf{S'}\cons\mathsf{sendA}(\theta,e,p',\{v,\k\},a,p)\cons\mathsf{S}\lhh \\
					\Gamma\cup\{(p',\{v,\k\})\};\lfloor\tuple{p,\mathsf{sendA}(\theta,e,p',\{v,\k\})\cons\h,(\theta,e),q}\rfloor_{\Psi} 
					\:\comp\: \lfloor\Pi \rfloor_{\#_\mathsf{([a],\emptyset),l}^\mathsf{S'}};\\
					\mathsf{S'}\cons\mathsf{sendA}(\theta,e,p',\{v,\k\},a,p)\cons\mathsf{S}\\
					Se ~ \exists ~ op ~ \mbox{in scrittura} \in \mathsf{S'} ~  a~ \varepsilon ~op 
					%\mbox{Se in S' sono presenti operazioni di scrittura sulla mappa che coinvolgono l'atomo a}
				\end{array}
		}}\\[6ex]
		
		
		\mathcolorbox{yellow}{ (\mathit{\ol{SendA3}}) ~~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{sendA}(\theta,e,p',\{v,\k\})\cons\h,(\theta',e'),q}\rfloor_{\Psi}\:\comp\:\lfloor\tuple{p',\h',(\theta'',e''),q'}\rfloor_{\Psi'}\:\comp\:\Pi;\\\mathsf{S'}\cons\mathsf{sendA}(\theta,e,p',\{v,\k\},a,p)\cons\mathsf{S}\\
					\lhh 
					\Gamma;\lfloor\tuple{p,\mathsf{sendA}(\theta,e,p',\{v,\k\})\cons\h,(\theta',e'),q}\rfloor_{\Psi}\:\comp\:\lfloor\tuple{p',\h',(\theta'',e''),q'}\rfloor_{\Psi'\cup\{\#_\mathsf{sch}^\k\}}\:\comp\:
					\Pi;\\
					\mathsf{S'}\cons\mathsf{sendA}(\theta,e,p',\{v,\k\},a,p)\cons\mathsf{S}\\
					\hspace{20ex}\mbox{se}~(p',\{v,\k\})~\mbox{non occorre
						in}~\Gamma~\mbox{e}~\#_\mathsf{sch}^{\k}\not\in\Psi'
				\end{array}
		}}\\[7ex]
		
		\mathcolorbox{yellow}{(\mathit{\ol{SendF1}}) ~~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{sendF1}(\theta,e,p,a)\cons\h,(\theta',e'),q}\rfloor_{\Psi}\:\comp\:
					\Pi;\mathsf{M;S'}\cons \mathsf{sendF1}(\theta,e,p,a)\cons\mathsf{S}\\
					\lhh         \Gamma;\lfloor\tuple{p,\h,(\theta',e'),q}\rfloor_{\Psi}\:\comp\:
					\Pi;
					\mathsf{M;S'}\cons \mathsf{S}\\
					Se ~ \forall ~ op ~ \mbox{in scrittura} \in \mathsf{S'} ~  a \centernot\varepsilon op        
					% \mbox{Se in S' non sono presenti operazioni di scrittura sulla mappa che coinvolgono l'atomo a}
				\end{array}
		}}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{\ol{SendF2}}) ~~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{sendF1}(\theta,e,p,a)\cons\h,(\theta',e'),q}\rfloor_{\Psi}\:\comp\:
					\Pi;\mathsf{M;S'}\cons \mathsf{sendF1}(\theta,e,p,a)\cons\mathsf{S}\\
					\lhh         \Gamma;\lfloor\tuple{p,\mathsf{sendF1}(\theta,e,p,a)\cons\h,(\theta',e'),q}\rfloor_{\Psi}\:\comp\:
					\lfloor\Pi\rfloor_{\#_\mathsf{([a],\emptyset),l}^\mathsf{S'}};
					\mathsf{M;S'}\cons \mathsf{sendF1}(\theta,e,p,a)\cons\mathsf{S}\\
					Se ~ \exists ~ op ~ \mbox{in scrittura} \in \mathsf{S'} ~  a~ \varepsilon ~op
					%\mbox{Se in S'  sono presenti operazioni di scrittura sulla mappa che coinvolgono l'atomo a}
				\end{array}
		}}\\[5ex]
		
		\mathcolorbox{yellow}{ (\mathit{\ol{RegisterT1}}) ~~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{regT}(\theta,e,a,p',p)\cons\h,(\theta',e'),q} \rfloor_{\Psi} \comp \Pi;\M\cup(a,p') ; \s'\cons\mathsf{regT}(\theta,e,a,p',p) \cons\s \\
					\lhh  \Gamma;\lfloor\tuple{p,\h,(\theta,e),q} \rfloor_{\Psi}\:\comp\: \Pi;\M;\s'\cons\s\\
					Se ~ \forall ~ op ~ \mbox{in scrittura o lettura} \in \s' ~  a \centernot\varepsilon op ~ \mathsf{o} ~ p' \centernot\varepsilon op
					%\mbox{Se in S' non sono presenti operazioni sulla mappa che coinvolgono il pid p' o l'atomo a}                  
				\end{array}
		}}
		\\[5ex]
		
		\mathcolorbox{yellow}{(\mathit{\ol{RegisterT2}}) ~~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{regT}(\theta,e,a,p',p)\cons\h,(\theta',e'),q} \rfloor_{\Psi} \comp \Pi;\M; \s'\cons\mathsf{regT}(\theta,e,a,p',p) \cons\s \\
					\lhh  \Gamma;\lfloor\tuple{p,\mathsf{regT}(\theta,e,a,p',p)\cons\h,(\theta,e),q} \rfloor_{\Psi}\:\comp\: \lfloor\Pi \rfloor_{\#_\mathsf{([a],[p']),s}^{\s'}};\M;\s'\cons\mathsf{regT}(\theta,e,a,p',p)\cons\s\\
					Se ~ \exists ~ op ~ \mbox{in scrittura o lettura} \in \s' ~  a~ \varepsilon ~ op ~ \mathsf{o} ~ p'~ \varepsilon ~ op
					%\mbox{Se in S' sono presenti operazioni sulla mappa che coinvolgono il pid p' o l'atomo a}                  
				\end{array}
		}}
		\\[5ex]
		
		\mathcolorbox{yellow}{(\mathit{\ol{RegisterF1}}) ~~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{regF1}(\theta,e,a,p',p)\cons\h,(\theta',e'),q}\rfloor_{\Psi}\comp \Pi;
					\M; \s'\cons\mathsf{regF1}(\theta,e,a,p',p) \cons\s \\    
					\hspace{20ex} \lhh  \Gamma;\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_{\Psi}\:\comp\: \Pi;\M;\s'\cons\s\\
					Se ~ \forall ~ op ~ \mbox{in scrittura} \in \s' ~  a \centernot\varepsilon op ~ \mathsf{o} ~ p' \centernot\varepsilon op
					%\mbox{Se in S' non sono presenti operazioni sulla mappa che coinvolgono il pid p' o l'atomo a}                  
				\end{array}
		}}\\[5ex]
		
		\mathcolorbox{yellow}{(\mathit{\ol{RegisterF2}}) ~~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{regF1}(\theta,e,a,p',p)\cons\h,(\theta',e'),q}\rfloor_{\Psi}\comp \Pi;
					\M; \s'\cons\mathsf{regF1}(\theta,e,a,p',p) \cons\s \\    
					\lhh \Gamma;\lfloor\tuple{p,\mathsf{regF1}(\theta,e,a,p',p)\cons\h,(\theta',e'),q}\rfloor_{\Psi}\comp \lfloor\Pi\rfloor_{\#_\mathsf{([a],[p']),l}^{\s'}};
					\M; \s'\cons\mathsf{regF1}(\theta,e,a,p',p) \cons\s \\    
					Se ~ \exists ~ op ~ \mbox{in scrittura} \in \s' ~  a~ \varepsilon ~ op ~ \mathsf{o} ~ p'~ \varepsilon ~ op
					% \mbox{Se in S' sono presenti operazioni sulla mappa che coinvolgono il pid p' o l'atomo a}                  
				\end{array}
		}}\\[5ex]
		
	\end{array}
	\]
	\caption{Rollback semantics: backward reduction rules} \label{fig:rollsem1}
\end{figure}

\begin{figure}[h!]
	\footnotesize
	\[
	\hspace{-3ex}
	\begin{array}{l@{~~}l}
		
		\mathcolorbox{yellow}{ (\mathit{\ol{UnregisterT1}}) ~~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{unregT}(\theta,e,a,p',p)\cons\h,(\theta',e'),q} \rfloor_{\Psi} \comp \Pi;\M\backslash\!\!\backslash(a,p') ; \s'\cons\mathsf{unregT}(\theta,e,a,p',p) \cons\s \\
					\lhh  \Gamma;\lfloor\tuple{p,\h,(\theta,e),q} \rfloor_{\Psi}\:\comp\: \Pi;\M;\s'\cons\s\\
					Se ~ \forall ~ op ~ \mbox{in scrittura o lettura} \in \s' ~  a \centernot\varepsilon op ~ \mathsf{o} ~ p' \centernot\varepsilon op
					%\mbox{Se in S' non sono presenti operazioni sulla mappa che coinvolgono il pid p' o l'atomo a}                  
				\end{array}
		}}
		\\[5ex]
		
		\mathcolorbox{yellow}{ (\mathit{\ol{UnregisterT2}}) ~~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{unregT}(\theta,e,a,p',p)\cons\h,(\theta',e'),q} \rfloor_{\Psi} \comp \Pi;\M; \s'\cons\mathsf{unregT}(\theta,e,a,p',p) \cons\s \\
					\lhh  \Gamma;\lfloor\tuple{p,\mathsf{unregT}(\theta,e,a,p',p)\cons\h,(\theta,e),q} \rfloor_{\Psi}\:\comp\: \lfloor\Pi \rfloor_{\#_\mathsf{([a],[p']),s}^{\s'}};\M;\s'\cons\mathsf{unregT}(\theta,e,a,p',p)\cons\s\\
					Se ~ \exists ~ op ~ \mbox{in scrittura o lettura} \in \s' ~  a~ \varepsilon ~ op ~ \mathsf{o} ~ p'~ \varepsilon ~ op
					%\mbox{Se in S' sono presenti operazioni sulla mappa che coinvolgono il pid p' o l'atomo a}                  
				\end{array}
		}}
		\\[5ex]
		
		\mathcolorbox{yellow}{ (\mathit{\ol{UnregisterF1}}) ~~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{unregF1}(\theta,e,a,p)\cons\h,(\theta',e'),q}\rfloor_{\Psi}\comp \Pi;
					\M; \s'\cons\mathsf{unregF1}(\theta,e,a,p) \cons\s \\    
					\lhh \Gamma;\lfloor\tuple{p,\h,(\theta',e'),q}\rfloor_{\Psi}\comp \Pi;
					\M; \s'\cons\s \\    
					Se ~ \forall ~ op ~ \mbox{in scrittura} \in \s' ~  a \centernot\varepsilon op 
					%\mbox{Se in S' non sono presenti operazioni sulla mappa che coinvolgono l'atomo a}                  
				\end{array}
		}}\\[5ex]
		
		\mathcolorbox{yellow}{(\mathit{\ol{UnregisterF2}}) ~~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{unregF1}(\theta,e,a,p)\cons\h,(\theta',e'),q}\rfloor_{\Psi}\comp \Pi;
					\M; \s'\cons\mathsf{unregF1}(\theta,e,a,p) \cons\s \\    
					\lhh \Gamma;\lfloor\tuple{p,\mathsf{unregF1}(\theta,e,a,p)\cons\h,(\theta',e'),q}\rfloor_{\Psi}\comp \lfloor\Pi\rfloor_{\#_\mathsf{([a],[\emptyset]),l}^{\s'}};
					\M; \s'\cons\mathsf{unregF1}(\theta,e,a,p) \cons\s \\    
					Se ~ \exists ~ op ~ \mbox{in scrittura} \in \s' ~  a~ \varepsilon ~ op
					%\mbox{Se in S' sono presenti operazioni sulla mappa che coinvolgono l'atomo a}                  
				\end{array}
		}}\\[5ex]
		
		\mathcolorbox{yellow}{(\mathit{\ol{Call3-1}}) ~ {\displaystyle
				\begin{array}{l}
					\Gamma;
					\lfloor\tuple{p,\tau\M\M'(\theta,e,p)\cons\h,(\theta',e'),q}\rfloor_\Psi
					\:\comp\: \Pi;\mathsf{M;S' : \tau\M\M'(\theta,e,p):S}
					\\ \lhh \Gamma;\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_\Psi\:\comp\: \Pi;\M;\s'\cons\s\\
					\mbox{Se in S' non sono presenti operazioni di scrittura su elementi presenti in M'}     \end{array}
		}}
		\\[5ex]
		
		\mathcolorbox{yellow}{(\mathit{\ol{Call3-2}}) ~ {\displaystyle
				\begin{array}{l}
					\Gamma;
					\lfloor\tuple{p,\tau\M\M'(\theta,e,p)\cons\h,(\theta',e'),q}\rfloor_\Psi
					\:\comp\: \Pi;\M;\s'\cons\mathsf{\tau\M\M'(\theta,e,p)}\cons\s
					\lhh \\
					\Gamma;
					\lfloor\tuple{p,\tau\M\M'(\theta,e,p)\cons\h,(\theta',e'),q}\rfloor_\Psi
					\:\comp\: \lfloor\Pi\rfloor_{\#_\mathsf{(\M'),l}^\mathsf{S'}};\mathsf{M;S' : \tau\mathsf{MM'}(\theta,e,p):S}\\
					\mbox{Se in S' sono presenti operazioni di scrittura su elementi presenti in M'}     \end{array}
		}}
		\\[5ex]
		
		\mathcolorbox{yellow}{ (\mathit{\ol{Catch}}) ~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{fail}(\theta,e)\cons\h,(\theta,fail),q}\rfloor_\Psi \comp \Pi; \M;\s
					\lhh
					\Gamma;\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_\Psi\comp \Pi; \M;\s
				\end{array}
		}}  \\[2ex]
		
		\mathcolorbox{yellow}{ (\mathit{\ol{End1}}) ~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{end}(\theta,\epsilon,a',p)\cons\h,(\theta,\epsilon),q}\rfloor_\Psi \comp \Pi,
					\M\backslash\!\!\backslash (a' ,p), \s'\cons\mathsf{end}(\theta,\epsilon,a',p)\cons\s
					\lhh  \Gamma;\lfloor\tuple{p,\h,(\theta,\epsilon),q}\rfloor_\Psi\:\comp\: \Pi;\M;\s'\cons\s\\
					Se ~ \forall ~ op ~ \mbox{in scrittura o lettura} \in \s' ~  a' \centernot\varepsilon op ~ \mathsf{o} ~ p \centernot\varepsilon op
					% \mbox{Se in S' non sono presenti operazioni di scrittura e lettura sulla mappa}\\\mbox{ che coinvolgono il pid p o l'atomo a'}                  
					
				\end{array}
				
		}}
		\\[4ex]
		
		\mathcolorbox{yellow}{ (\mathit{\ol{End2}}) ~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{end}(\theta,\epsilon,a',p)\cons\h,(\theta,\epsilon),q}\rfloor_\Psi\comp \Pi,
					\M, \s'\cons\mathsf{end}(\theta,\epsilon,a',p)\cons\s
					\lhh \\ \Gamma;\lfloor\tuple{p,\mathsf{end}(\theta,\epsilon,a',p)\cons\h,(\theta,\epsilon),q}\rfloor_\Psi\comp \lfloor\Pi \rfloor_{\#_\mathsf{([a'],[p]),s}^{\s'}};
					\M, \s'\cons\mathsf{end}(\theta,\epsilon,a',p)\cons\s\\
					Se ~ \exists ~ op ~ \mbox{in scrittura o lettura} \in \s' ~  a'~ \varepsilon ~ op ~ \mathsf{o} ~ p~ \varepsilon ~ op  			
				\end{array}
				
		}}
		
	
	\end{array}
	\]
	\caption{Rollback semantics: backward reduction rules} \label{fig:rollsem2}
\end{figure}

Si può notare che i rollback fino ai checkpoint vengono generati non deterministicamente dalla regola $\mathit{\ol{Undo}}$, gli altri due tipi di rollback sono generati dalle regole di riduzione backward in un certo ordine per garantire la coerenza causale. Questo è chiarito dalla discussione seguente, dove si spiegano brevemente le principali differenze rispetto a semantica backward descritta precedentemente:
\begin{itemize}
	\item Come nella semantica nella Figura~\ref{fig:backwardsem}, l'invio di un messaggio può essere annullato quando il messaggio è ancora nella casella di posta globale (regola $\ol{\mathit{Send1}}$). Altrimenti, potrebbe essere necessario applicare prima la regola $\ol{\mathit{Send2}}$ per ``propagare'' la modalità di rollback fino al destinatario del messaggio, in modo che le regole $\ol{\mathit{Sched}}$ e $\ol{\mathit{Send1}}$ possano essere eventualmente applicate.
	
	\item Per l'annullamento della generazione di un processo $p''$, la regola $\ol{\mathit{Spawn1}}$ si applica quando sia la cronologia che le code del processo generato $p''$ sono vuote, eliminando sia l'elemento della cronologia in $p$ che il processo $p''$. Altrimenti, si applica la regola $\ol{\mathit{Spawn2}}$ che propaga la modalità di rollback in modo che, alla fine, la regola $\ol{\mathit{Spawn1}}$ si possa applicare a $p''$.
	
	\item Si osserva che la regola $\ol{\mathit{Sched}}$ richiede la stessa side-condition della semantica incontrollata. Questo è necessario per evitare la commutazione delle regole $\mathit{\ol{Receive}}$ e $\mathit{\ol{Sched}}$.
	
	\item Infine, si può notare inoltre che per ogni nuova regola $\lh$ sulla mappa sono state aggiunte due regole $\lhh$: una per il caso in cui in $\s'$ siano presenti operazioni eseguite sugli stessi pid e/o atomi che inseriscono gli operatori di rollback ove necessario, l'altra che effettuasse effettivamente la regola di rollback dell'operazione, visto che in $\s'$ non sono presenti le regole che non consentono il rollback. 
	
\end{itemize}

La semantica di rollback è modellata dalla relazione $\looparrowright$, che è definita come l'unione della relazione reversibile diretta $\rh$ (Figure~\ref {fig:forwardsem} e \ref {fig:forwardsem1}) e la relazione a ritroso $\lhh$ definita nelle Figure~\ref {fig:rollsem0},~\ref {fig:rollsem1} e~\ref {fig:rollsem2}. Si noti che, in contrasto con la semantica reversibile (non controllata) della Sezione~\ref{sect:semreversibile}, la semantica di rollback data dalla relazione $\looparrowright$ ha meno scelte non deterministiche: tutti i calcoli vengono eseguiti in avanti tranne quando un'azione di rollback richiede alcuni passi all'indietro per ripristinare uno stato precedente di un processo (che può essere propagato ad altri processi al fine di annullare la generazione di un processo o l'invio di un messaggio).\\
Si noti, tuttavia, che oltre all'introduzione dei rollback, c'è ancora un certo non determinismo nelle regole all'indietro della semantica del rollback: da un lato, la selezione del processo quando ci sono diversi rollback in corso è non deterministica; inoltre, in molti casi, sia la regola $\mathit{\ol{Sched}}$ sia un'altra regola sono applicabili allo stesso processo. La semantica potrebbe essere resa deterministica utilizzando una particolare strategia per selezionare i processi (es. Round robin) e applicando la regola $\mathit{\ol{Sched}}$ ogniqualvolta possibile (es. dare a $\mathit{\ol{Sched}}$ una priorità più alta rispetto alle restanti regole all'indietro).\\
Dichiariamo di seguito la validità della semantica di rollback. Per farlo, lasciamo che $\rolldel(s)$ denoti il sistema che risulta da $s$ rimuovendo i rollback in corso; formalmente, $\rolldel(\Gamma;\Pi;\M;\s) = \Gamma; \rolldel'(\Pi);\M;\s$, dove:
\[
\begin{array}{lll}
	\rolldel'(\tuple{p,\h,(\theta,e),q}) & = &
	\tuple{p,\h,(\theta,e),q}\\
	\rolldel'(\lfloor \tuple{p,\h,(\theta,e),q}\rfloor_{\Psi}) & = &
	\tuple{p,\h,(\theta,e),q}\\
	\rolldel'(\tuple{p,\h,(\theta,e),q}\:\comp\:\Pi) & = &
	\tuple{p,\h,(\theta,e),q}\:\comp\:\rolldel'(\Pi)\\
	\rolldel'(\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_{\Psi}\:\comp\:\Pi) & = &
	\tuple{p,\h,(\theta,e),q}\:\comp\:\rolldel'(\Pi)
	\\                                              
\end{array}
\]
dove assumiamo che $ \Pi $ non sia vuoto.
Estendiamo anche la definizione di sistemi iniziali e raggiungibili alla semantica di rollback.

\begin{definition} [Sistemi raggiungibili sotto il rollback
	semantica] \label {def:reachableroll} \mbox {} \\
	Un sistema è \emph {iniziale} sotto la semantica di rollback, se è
	composto da un unico processo con un set vuoto $ \Psi $ di rollback attivi; inoltre, la storia, la coda dei massaggi, la mail-box globale, la storia della mappa e la mappa sono vuote. Un sistema $ s $ è
	\emph {raggiungibile} sotto la semantica di rollback se esiste un sistema
	iniziale $ s_0 $ e una derivazione $ s_0 \looparrowright ^ \ast s $
	utilizzando le regole corrispondenti a un determinato programma.
\end{definition}

\begin{theorem} [Soundness] \label{thm:soundness-rollback}
	Sia $ s $ un sistema raggiungibile con la semantica di rollback. Se
	$ s \looparrowright ^ \ast s '$, allora $ \rolldel (s) \rlh^ \ast \rolldel (s') $.
\end{theorem}
\begin{proof}
	Per le transizioni in avanti la dimostrazione è banale poiché le regole in avanti sono le stesse in entrambe le semantiche e si applicano solo ai processi che non sono in fase di rollback. Per le transizioni all'indietro la dimostrazione è per casi analizzando la regola applicata, tramite l'equivalenza strutturale e l'utilizzo di $\rolldel$:
	\begin{itemize}
		\item Regola $ \mathit {\ol{Undo}} $: l'effetto viene rimosso da $ \rolldel $, quindi un'applicazione di questa regola corrisponde a un file derivazione a passo zero sotto la semantica incontrollata;
		\item Regole $ \mathit {\ol{Seq}} $, $ \mathit {\ol{Check}} $, $ \mathit {\ol {Send1}} $, $ \mathit {\ol{Receive}} $, $ \mathit {\ol{Spawn1}} $, $ \mathit {\ol {Self}} $, $ \mathit {\ol{Sched}} $, $\mathit{\ol{SendA1}}$, $\mathit{\ol{SendF1}}$, $\mathit{\ol{Call3-1}}$, $\mathit{\ol{RegisterT1}}$, $\mathit{\ol{RegisterF1}}$, $\mathit{\ol{UnregisterT1}}$, $\mathit{\ol{UnregisterF1}}$,  $\mathit{\ol{Catch}}$ e $\mathit{\ol{End1}}$:
		corrispondono, rispettivamente, alle regole $ \mathit {\ol{Seq}} $, $ \mathit {\ol{Check}} $, $ \mathit{\ol{Send}} $, $ \mathit {\ol{Receive}} $, $ \mathit {\ol{ Spawn}} $, $ \mathit {\ol{Self}} $, $ \mathit {\ol{Sched}} $, $\mathit{\ol{SendA}}$, $\mathit{\ol{SendF}}$, $\mathit{\ol{Call3}}$, $\mathit{\ol{RegisterT}}$, $\mathit{\ol{RegisterF}}$, $\mathit{\ol{UnregisterT}}$, $\mathit{\ol{UnregisterF}}$,  $\mathit{\ol{Catch}}$ e $\mathit{\ol{End}}$ della semantica incontrollata;
		\item Regole $\mathit{\ol{Send2}}$, $\mathit{\ol{Spawn2}}$, $\mathit{\ol{SendA2}}$, $\mathit{\ol{SendA3}}$, $\mathit{\ol{SendF2}}$, $\mathit{\ol{Call3-2}}$,\\ $\mathit{\ol{RegisterT2}}$, $\mathit{\ol{RegisterF2}}$, $\mathit{\ol{UnregisterT2}}$, $\mathit{\ol{UnregisterF2}}$ e $\mathit{\ol{End2}}$: l'effetto viene rimosso da $ \rolldel $, quindi un'applicazione di una qualsiasi di queste regole corrisponde a una derivazione a passo zero sotto semantica incontrollata. 
	\end{itemize}
\end{proof}

Ora possiamo mostrare la completezza della semantica di rollback a condizione che il processo coinvolto sia in modalità rollback:

\begin{lemma} [Completezza in modalità rollback] \label{lemma:completezza-rollback}
	Sia $ s $ un sistema raggiungibile. Se $ s \lh s '$ allora un qualsiasi sistema $ s_r $ tale che $ \rolldel (s_r) = s $ e dove il processo che ha eseguito la transizione $ s \lh s '$ è in modalità rollback per un insieme non vuoto di rollback. Allora esiste $ s'_r $ tale che $ s_r \lhh s'_r $ e $ \rolldel (s'_r) = s '$.
\end{lemma}
\begin{proof}
	La prova è l'analisi dei casi sulla regola applicata. Ogni passaggio è corrispondente alla regola omonima, ma per $ \mathit{\ol{Send}} $, $ \mathit{\ol{Spawn}} $, $\mathit{\ol{SendA}}$, $\mathit{\ol{SendF}}$, $\mathit{\ol{Call3}}$, $\mathit{\ol{RegisterT}}$, $\mathit{\ol{RegisterF}}$, $\mathit{\ol{UnregisterT}}$, $\mathit{\ol{UnregisterF}}$ e $\mathit{\ol{End}}$  a cui corrispondono rispettivamente le regole $ \mathit {\ol{Send1}} $, $ \mathit {\ol{Spawn1}} $, $\mathit{\ol{SendA1}}$, $\mathit{\ol{SendF1}}$, $\mathit{\ol{Call3-1}}$, $\mathit{\ol{RegisterT1}}$, $\mathit{\ol{RegisterF1}}$, $\mathit{\ol{UnregisterT1}}$, $\mathit{\ol{UnregisterF1}}$ e $\mathit{\ol{End1}}$.
\end{proof}


\clearpage{\pagestyle{empty}\cleardoublepage}
\chapter{Conclusione}


\clearpage{\pagestyle{empty}\cleardoublepage}
\begin{thebibliography}{}
		
	\bibitem{CoreErlang}
	Richard Carlsson.
	\newblock An introduction to core {E}rlang.
	\newblock In {\em In Proceedings of the PLI'01 Erlang Workshop}, 2001.
	
	\bibitem{Lanese}
	Ivan Lanese, Naoki Nishida, Adri{\'{a}}n Palacios, and Germ{\'{a}}n Vidal.
	\newblock A theory of reversibility for {E}rlang.
	\newblock {\em Journal of Logical and Algebraic Methods in Programming},
	100:71--97, November 2018.
	
	\bibitem{Landauer}
	R.~Landauer.
	\newblock Irreversibility and heat generation in the computing process.
	\newblock {\em {IBM} Journal of Research and Development}, 5(3):183--191, July
	1961.
	
	\bibitem{Bennett}
	C.~H. Bennett.
	\newblock Logical reversibility of computation.
	\newblock {\em {IBM} Journal of Research and Development}, 17(6):525--532,
	November 1973.
	
	\bibitem{Danos}
	Vincent Danos and Jean Krivine.
	\newblock Reversible communicating systems.
	\newblock In {\em {CONCUR} 2004 - Concurrency Theory}, pages 292--307. Springer
	Berlin Heidelberg, 2004.
	
	\bibitem{CMRT13tr}
	R.~Caballero, E.~Mart{\'{\i}}n-Mart{\'{\i}}n, A.~Riesco, and S.~Tamarit.
	\newblock A declarative debugger for concurrent erlang programs (extended
	version).
	\newblock Technical Report SIC-15/13, Dpto.\ Sistemas Inform\'aticos y
	Computaci\'on, Universidad Complutense de Madrid, 2013.
	
	\bibitem{Engblom}
	Engblom, J. (2012, September). 
	\newblock A review of reverse debugging.
	\newblock In System, Software, SoC and Silicon Debug Conference (S4D), 2012 (pp. 1-6). IEEE.
	
	\bibitem{NPV16b}
	N.~Nishida, A.~Palacios, and G.~Vidal.
	\newblock A reversible semantics for {E}rlang.
	\newblock In M.~Hermenegildo and P.~L\'opez-Garc\'{\i}a, editors, {\em Proc.\
		of the 26th International Symposium on Logic-Based Program Synthesis and
		Transformation, LOPSTR 2016}, volume 10184 of {\em LNCS}, pages 259--274.
	Springer, 2017.
	\newblock Preliminary version available from
	\texttt{https://arxiv.org/abs/1608.05521}.
	
	\bibitem{LMSS11}
	I.~Lanese, C.~A. Mezzina, A.~Schmitt, and J.~Stefani.
	\newblock Controlling reversibility in higher-order pi.
	\newblock In J.~Katoen and B.~K{\"{o}}nig, editors, {\em Proceedings of the
		22nd International Conference on Concurrency Theory ({CONCUR} 2011)}, volume
	6901 of {\em Lecture Notes in Computer Science}, pages 297--311. Springer,
	2011.
	
	\bibitem{GLM14}
	E.~Giachino, I.~Lanese, and C.~A. Mezzina.
	\newblock Causal-consistent reversible debugging.
	\newblock In S.~Gnesi and A.~Rensink, editors, {\em Proc.\ of the 17th
		International Conference on Fundamental Approaches to Software Engineering
		({FASE} 2014)}, volume 8411 of {\em Lecture Notes in Computer Science}, pages
	370--384. Springer, 2014.
	

\end{thebibliography}
\end{document}
