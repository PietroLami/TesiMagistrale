\documentclass[12pt,a4paper,openright,twoside]{report}
\usepackage[italian]{babel}
\usepackage[latin1]{inputenc}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{amsthm}
\usepackage{xcolor}
\oddsidemargin=30pt \evensidemargin=20pt%impostano i margini

\usepackage[all]{xy}
\usepackage{pdfpages}
\usepackage{titlesec}
\usepackage{fancyhdr}
\pagestyle{fancy}

\usepackage{color}



\newcommand{\id}{id}
% Terms
\newcommand{\nil}{[\:]}
\newcommand{\ol}[1]{\overline{#1}}  % sequence of objects

% New symbols:
\newcommand{\cons}{\!:\!}


% Arrows
\newcommand{\h}{\mathit{h}}
\renewcommand{\k}{\lambda}
\newcommand{\init}{\mathsf{init}}
\newcommand{\final}{\mathsf{final}}
\newcommand{\rlh}{\rightleftharpoons}
\newcommand{\lh}{\leftharpoondown}
\newcommand{\rh}{\rightharpoonup}
\newcommand{\lhh}{\leftharpoondown\hspace{-1.8ex}\leftharpoondown}
\newcommand{\rlhh}{\rightleftharpoons\hspace{-1.8ex}\rightleftharpoons}
\newcommand{\M}{\mathsf{M}}
\newcommand{\s}{\mathsf{S}}


\newcommand{\remark}[1]{\mbox{}\\\fbox{\begin{minipage}{.95\linewidth}
			Remark: \textsf{#1} \end{minipage}}\\}

\def \tuple#1{\langle #1 \rangle}


\usepackage{xcolor}
\newcommand{\mathcolorbox}[2]{\colorbox{#1}{$\displaystyle #2$}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand{\chaptermark}[1]{%
	\markboth{ #1}{}}

\renewcommand{\sectionmark}[1]{
	\markright{\thesection\ #1}}

\newcommand{\too}{\longrightarrow}
\newcommand{\arro}[1]{\xrightarrow{#1}} 
\newcommand{\hoo}{\hookrightarrow} 
\newcommand{\del}{\mathsf{del}}
\newcommand{\rolldel}{\mathsf{rolldel}} 
\newcommand{\comp}{\:|\:} 


\usepackage{thmtools}

\newtheorem{theorem}{Teorema}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollario}
\newtheorem{example}[theorem]{Esempio}


\newtheoremstyle{theoremdd}
  {\topsep}% measure of space to leave above the theorem. E.g.: 3pt
{\topsep}% measure of space to leave below the theorem. E.g.: 3pt
{}% name of font to use in the body of the theorem
{0pt}% measure of space to indent
{\bfseries}% name of head font
{. }% punctuation between head and body
{ }% space after theorem head; " " = normal interword space
{\thmname{#1}\thmnumber{ #2}\thmnote{ (#3)}}
\theoremstyle{theoremdd}
\newtheorem{definition}[theorem]{Definizione}

\renewcommand{\ttdefault}{cmtt}
\usepackage{url}
\usepackage{tikz}
\usepackage{diagbox}
\usepackage{multirow}



%\usepackage{ebproof}
% \usepackage{tikz} % Useless, but might be handy to draw fancier lines.
\usepackage{amssymb} % To provide the \varnothing symbol
\newcommand{\nothing}{\varnothing} % different from \emptyset
\usepackage{cancel}



\begin{document}

\tableofcontents
\thispagestyle{empty}                   %elimina il numero della pagina
\clearpage{\pagestyle{empty}\cleardoublepage}
\chapter{Introduzione}
Erlang è un linguaggio di programmazione funzionale e concorrente basato sul paradigma ad attori (concorrenza basata sul \textit{message-passing}). \\
BEAM è la macchina virtuale al centro di Erlang, fa parte dell'Erlang Run-Time System (ERTS), che compila il codice sorgente di Erlang in bytecode, che viene quindi eseguito su BEAM.
Core Erlang \cite{CoreErlang} è uno dei linguaggi intermedi in cui Erlang viene compilato.

In questa tesi si mostra un estensione della semantica descritta nell'articolo ``A theory of reversibility for Erlang'' \cite{Lanese} con delle feature imperative.

Nella Sezione \ref{sect:linguaggio} viene modificato il linguaggio presentato nell'articolo~\cite{Lanese} aggiungendo le operazione di registrazione di atomi e pid, deregistrazione di pid e di lookup, inoltre viene aggiunto un non terminale \textit{end} per poter identificare quando un processo è arrivato in uno stato finale. 

Nella Sezione \ref{sect:semantica} viene modificata la nozione di sistema data nell'articolo \cite{Lanese} in cui viene introdotta una mappa formata dalle coppie di atomi-pid che sono stati registrati. Inoltre sono state introdotte le regole per la semantica del linguaggio, in questo caso sono state aggiunte le regole per la valutazione delle nuove espressioni e inoltre sono state aggiunte le regole per descrivere il fallimento di un'espressione, che nell'articolo \cite{Lanese} non erano presenti. Inoltre sono state aggiunte le regole di sistema per le nuove espressioni e per i casi di fallimento.

Nella Sezione \ref{sect:semreversibile} viene descritta la semantica reversibile divisa in semantica \textit{forward} e \textit{backward}. La prima è un'estensione delle regole introdotte precedentemente in cui nell'articolo \cite{Lanese} viene aggiunta una storia dei processi mentre in questo lavoro è stata l'aggiunta di una storia della mappa. La semantica \textit{backward} invece descrive come viene fatto un passo all'indietro. In questo caso viene introdotta una nozione di operazione in lettura e scrittura per generalizzare le \textit{side-condition} delle regole inserite e per dare una nozione di operazione concorrente più generale. 

Nella Sezione \ref{sect:semrollback} è stato esteso l'operatore di reversibilità che può essere utilizzato per annullare le azioni di un dato processo fino a raggiungere un determinato punto di controllo, introdotto dal programmatore. Per garantire la coerenza causale, l'azione di rollback potrebbe essere propagata ad altri processi dipendenti. 

\section{Reversibilità}
Normalmente la computazione avviene in una direzione, in un programma le istruzioni vengono eseguite in un determinato ordine, per computazione reversibile ci si riferisce alla possibilità di eseguire un programma sia in avanti (o anche computazione \textit{forward}) che indietro (o anche computazione \textit{backward}).

Dato un programma non è ovvio che sia possibile eseguire una computazione backward, infatti tutti i linguaggi di programmazione tradizionali consentono operazioni con perdita di informazione. \\
Durante l'esecuzione di un programma, a meno che non sia reversibile o senza perdita di informazioni, i dati intermedi vengono persi mentre viene calcolato l'output finale.

\begin{example}
	L'assegnamento \texttt{$\mathtt{x}$ = 96}  elimina il vecchio valore di $\mathtt{x}$ che deve essere memorizzato se si vuole annullare questa assegnazione.
\end{example}

Landauer \cite{Landauer} notò anche che ogni computazione irreversibile può essere trasformata in una computazione reversibile, includendola in una computazione più ampia nella quale nessuna informazione viene persa, salvando ogni volta gli stati intermedi della computazione così da non avere perdita di informazione.\\
L'idea alla base di questo lavoro \cite{Landauer} è che qualsiasi linguaggio di programmazione o formalismo può essere reso reversibile aggiungendo la cronologia del calcolo a ogni stato, questo metodo è di solito chiamato incorporamento di Landauer.

Questa idea fu ulteriormente migliorata da Bennett \cite{Bennett} al fine di evitare la generazione di dati ``spazzatura'', applicando una serie di analisi al fine di limitare il più possibile le informazioni richieste nella storia.

La reversibilità in un contesto sequenziale è facile da capire, per invertire l'esecuzione di un programma sequenziale è sufficiente annullare ricorsivamente l'ultima azione eseguita dal programma. La definizione di reversibilità in un contesto in cui vengono considerati anche i sistemi distribuiti è più complicata, poiché non esiste il concetto di ``ultima azione'', dato che, molte azioni vengono eseguite contemporaneamente.

Una definizione adeguata di reversibilità in uno scenario concorrente è stata proposta da Danos e Krivine nel loro articolo \cite{Danos}. Intuitivamente, la definizione afferma che qualsiasi azione può essere annullata a condizione che tutte le sue eventuali conseguenze siano annullate preventivamente.

Il calcolo reversibile potrebbe essere applicato per migliorare il modo in cui alcune attività vengono risolte, per esempio nel debug.

\section{Debugger reversibile}

I Debugger non sono altro che programmi, che consento di analizzare se un programma è sintatticamente corretto, in modo tale da effettuare una ricerca del bug in modo più veloce e accurato possibile. Grazie ai Debugger si ha la possibilità di scovare errori o malfunzionamenti all'interno del programma sfruttando funzioni specifiche per il debugging: l'attività che consiste proprio nell'individuazione della porzione di software affetta da bug.

Generalmente il tipo di debugger più utilizzato è il debugger a runtime che consente la ricerca dei bug tramite funzionalità standard come \textit{breackpoint}, \textit{controlpoint} e \textit{viste da watch}, che consentono al programmatore di analizzare più accuratamente determinate parti di codice per identificare gli errori con una scansione in avanti del codice.

Di contro però, la maggior parte dei debugger fornisce (infatti), un'assistenza limitata all'esecuzione in avanti del codice per la navigazione temporale, per cui i programmatori devono spesso ricorrere alla simulazione dell'esecuzione del programma mentalmente per cercare di immaginare i flussi di istruzioni che vengono eseguiti. Infatti, con un debugger a \textit{runtime}, il programmatore può cercare il bug inserendo dei breackpoint all'interno dei thread e sperare di scovare il bug facendo dei tentativi, magari entrando in watch per osservare come vengono modificate le variabili durante l'esecuzione del programma. A tal proposito sono nati anche debug più complessi i cosidetti: debugger reversibili che a differenza dei debugger tradizionali, consentono agli sviluppatori di registrare le attività del programma in esecuzione, per poi riavvolgere e riprodurre tali istruzioni, compresi eventuali errori, per ispezionare lo stato del programma, questi debugger sono molto utili negli scenari concorrenti \cite{Engblom}.\\
Riavvolgere le azioni di un particolare processo significa anche annullare ogni conseguenza dell'operazione (cioè  tutte le azioni ``collegate'' a quell'operazione) che si vuole annullare. Questa nozione è chiamata \textit{consistenza causale} \cite{Danos}.

\clearpage{\pagestyle{empty}\cleardoublepage}
\chapter{Estensione con feature imperative}

Nel seguito di questo capitolo, verrà presentata la sintassi del linguaggio esteso supportato, seguita dalla semantica (reversibile).
In contrasto con la semantica descritta nell'articolo ``A theory of reversibility for Erlang'' \cite{Lanese} quella che verrà presentata qui includerà funzioni imperative integrate.
Le modifiche effettuate all'articolo \cite{Lanese} sono evidenziate in giallo.

\section{Sintassi del linguaggio}\label{sect:linguaggio}
In questa sezione, verrà mostrata la sintassi di un linguaggio funzionale di prim'ordine, concorrente e distribuito basato sul paradigma ad attori utilizzato. Questo linguaggio è un sotto insieme di Core Erlang \cite{CoreErlang}, che è uno dei linguaggi intermedi in cui un programma Erlang viene compilato.
\begin{figure}[ht]
	\begin{center}
		$
		\begin{array}{rcl@{~~~~~~}l}
			
			\mathit{module} & ::= & \mathsf{module} ~ Atom = %%[fname_1,\ldots,fname_n] =
			\mathit{fun}_1~\ldots~\mathit{fun}_n\\
			{\mathit{fun}} & ::= & \mathit{fname} = \mathsf{fun}~(\mathit{Var}_1,\ldots,\mathit{Var}_n) \to expr \\
			{\mathit{fname}} & ::= & Atom/\mathit{Integer} \\
			lit & ::= & Atom \mid \mathit{Integer} \mid \mathit{Float} \mid
			\mathit{Pid} \mid \nil \\
			expr & ::= & \mathit{Var}  \mid \mathit{fname} \mid [expr_1|expr_2]
			\mid   \{expr_1,\ldots,expr_n\} \\
			& \mid & \mathsf{call}~Op~(expr_1,\ldots,expr_n) 
			\mid \mathsf{apply}~\mathit{fname}~(expr_1,\ldots,expr_n) \\
			& \mid &
			\mathsf{case}~expr~\mathsf{of}~clause_1;\ldots;clause_m~\mathsf{end}\\
			& \mid & \mathsf{let}~\mathit{Var}=expr_1~\mathsf{in}~expr_2 
			\mid \mathsf{receive}~clause_1;\ldots;clause_n~\mathsf{end}\\
			& \mid & \mathsf{spawn}(\mathit{fname},[expr_1,\ldots,expr_n])  
			\mid expr \:!\: expr \mid \mathsf{self}()\\
			& \mid &   \mathcolorbox{yellow}{ \mathsf{register}(expr, expr)} \mid    \mathcolorbox{yellow}{ \mathsf{unregister}(expr)}  \mid \mathcolorbox{yellow}{end} \\
			clause & ::= & pat ~\mathsf{when}~expr_1 \to expr_2
			\\
			pat & ::= & \mathit{Var} \mid lit \mid [pat_1|pat_2] \mid
			\{pat_1,\ldots,pat_n\} \\
			Op & ::= & \dots \mid \mathcolorbox{yellow} { \mathsf{whereis}} \mid \mathcolorbox{yellow} {\mathsf{registered}}\\
			\mathcolorbox{yellow}{end} & ::= & lit \mid [end_1|end_2] \mid
			\{end_1,\ldots,end_n\} 
		\end{array}
		$
	\end{center}
	\caption{Regole di sintassi del linguaggio} \label{ErlangSyntax}
\end{figure}
\newline
\newline
Nella Figura~\ref{ErlangSyntax} viene presentata la sintassi del linguaggio, si può notare che vengono considerate solo espressioni di prim'ordine quindi il primo argomento delle applicazioni di funzioni e della spawn è un nome di funzione (invece che un'espressione o chiusura arbitraria) e il primo argomento nelle chiamate è un'operazione built-in $Op$. Rispetto alla sintassi precedente sono state aggiunte le funzioni built-in: 
\begin{itemize}
	\item $\mathsf{whereis}$ che dato in input un atomo restituisce il pid associato, se non è registrato l'atomo \textbf{undefined};
	\item $\mathsf{registered}$ che restituisce una lista di tutti gli atomi nella mappa, se non sono presenti atomi registrati restituisce una lista vuota;
\end{itemize}
sono anche state aggiunte le funzioni:
\begin{itemize}
	\item $\mathsf{register}$ che dati in input un atomo e un pid inserisce la in una mappa la coppia atomo,pid e restituisce l'atomo \textbf{true}. Altrimenti se l'atomo o il pid sono già presenti nella mappa il processo fallisce;
	\item $\mathsf{unregister}$ che dato in input un atomo toglie dalla mappa la coppia atomo,pid e restituisce l'atomo \textbf{true}. Altrimenti se l'atomo non è presente nella mappa il processo fallisce.
\end{itemize}
Inoltre è stato creato il non terminale \textit{end} per riuscire a determinare quando un processo è in uno stato finale, così è possibile determinare se un processo è fallito. In questo modo si è riusciti ad avere un comportamento il più fedele possibile a quello di Erlang nel caso delle funzioni aggiunte. Nelle regole che verranno descritte successivamente il simbolo $\epsilon$ rappresenterà un non terminale \textit{end}. 

\section{Semantica del linguaggio}\label{sect:semantica}
In questa sezione descriveremo formalmente la semantica del linguaggio presentato nella sezione \ref{sect:linguaggio}.

\begin{definition} [Processo]
	Un processo è indicato da una tupla $\tuple {p, (\theta, e), q}$ dove $p$ è il pid del processo (ed è unico), $(\theta, e)$ è il controllo, che consiste di un ambiente (una sostituzione) e di un'espressione da valutare, e $q$ è la casella di posta del processo, una coda FIFO con la sequenza di messaggi che sono stati inviati al processo.
	
	Consideriamo le seguenti operazioni sulle cassette postali locali. Dato un messaggio $v$ e una casella di posta locale $q$, $v:q$ denota una nuova casella di posta con il messaggio $v$ sopra (cioè $v$ è il messaggio più recente). Indichiamo anche con $q \backslash\! \! \backslash v$ una nuova coda che risulta da $q$ rimuovendo l'occorrenza più vecchia del messaggio $v$ (che non è necessariamente il messaggio più vecchio nel
	coda). \qed
\end{definition}
%
Un \emph{sistema} in esecuzione può quindi essere visto come un insieme di processi, che definiamo formalmente come segue:

\begin{definition} [Sistema] \label{sistema}
	Un sistema è indicato da $\Gamma;\Pi;\M$, dove $\Gamma$, la \emph{casella di posta globale}, è un insieme di coppie nella forma $(destinazione,$ $messaggio)$ e $\Pi$ è un insieme di processi, indicato da un'espressione della forma
	\[
	\tuple{p_1, (\theta_1, e_1), q_1} ~ \comp \cdots
	\comp ~ \tuple {p_n, (\theta_n, e_n), q_n}
	\]
	dove `` $\comp$ '' denota un operatore associativo e commutativo.
	%
	Data una casella di posta globale $\Gamma $, $\Gamma \cup \{(p, v) \} $ denota una nuova casella di posta che include anche la coppia $(p, v)$, usiamo ``$\cup$'' come unione multiset.
	Spesso denotiamo un sistema con un'espressione nella forma $\Gamma;\tuple{p,(\theta, e),q}\comp \Pi;\M$ per far notare che $ \tuple {p, (\theta, e), q} $ è un processo arbitrario del pool (grazie al fatto che `` $\comp $ '' è associativo e commutativo).
	Infine $\M$ rappresenta l'insieme delle coppie $(atomo,pid)$ registrate, indicheremo con ``$\cup$'' l'aggiunta di una coppia alla mappa e con ``$\backslash\! \! \backslash$'' la rimozione di una coppia dalla mappa.\qed 
\end{definition}
%
Intuitivamente, $\Gamma$ memorizza i messaggi dopo che sono stati inviati e prima che vengano inseriti nella casella di destinazione, quindi rappresenta i messaggi che si trovano nella rete.
\newline

La semantica è definita tramite due relazione di transizione: $\too$ per le espressioni e $\hoo$ per il sistema. Mostreremo prima la relazione di transizione etichettata 
\[
\too\; : (Env,Exp)\times Label\times(Env,Exp)
\]
dove $Env$ e $Exp$ rappresentano rispettivamente l'ambiente (cioè le sostituzioni) e le espressioni mentre $Label$ denota un elemento dell'insieme
\[
\begin{array}{l}
	\hspace{-11ex}
	\{\tau, \mathsf{send}(v_1,v_2),
	\mathsf{rec}(\kappa,\ol{cl_n}), \mathsf{spawn}(\kappa,a/n,[\ol{v_n}]),
	\mathsf{self}(\kappa),
	\mathsf{register}(\kappa,a,p),
	\mathsf{unregister}(\kappa,a),
	\tau \M\M',
	\bot
	\}
\end{array}
\]
Verrà utilizzato $\ell$ per indicare un'etichetta fra quelle appena indicate.\\ Per chiarezza le regole di transizione della semantica verranno divise in quattro insiemi: quelle per le espressioni sequenziali sono raffigurate nella Figura~\ref{fig:seq-rules}, quelle per i fallimenti delle espressioni sequenziali che si trovano nella Figura~\ref{fig:seq-rules-fail}, quelle per le espressioni concorrenti sono nella Figura~\ref{fig:concurrent-rules} e infine quelle per i fallimenti delle espressioni concorrenti che sono nella Figura~\ref{fig:concurrent-rules-fail}.

\begin{figure}[h]
	\footnotesize
	\[
	\begin{array}{c}
		(\mathit{Var}) ~ {\displaystyle \frac{}{\theta,X
				\arro{\tau} \theta,\theta(X)}} 
		
		\hspace{2ex}
		
		(\mathit{Tuple}) ~ {\displaystyle 
			\frac{\theta,e_i \arro{\ell}
				\theta',e'_i}{\theta,\{\ol{v_{1,{i-1}}},e_i,\ol{e_{{i+1},n}}\}
				\arro{\ell} \theta',
				\{\ol{v_{1,{i-1}}},e'_i,\ol{e_{{i+1},n}}\}}}\\[4ex] 
		
		(\mathit{List1})  ~{\displaystyle 
			\frac{\theta,e_1 \arro{\ell}
				\theta',e'_1}{\theta,[e_1|e_2]
				\arro{\ell} \theta',
				[e'_1|e_2]}} 
		
		\hspace{2ex}
		
		(\mathit{List2}) ~ {\displaystyle 
			\frac{\theta,e_2 \arro{\ell}
				\theta',e'_2}{\theta,[v_1|e_2]
				\arro{\ell} \theta',
				[v_1|e'_2]}} \\[4ex]
		
		(\mathit{Let1}) ~ {\displaystyle \frac{\theta,e_1
				\arro{\ell} \theta',e'_1 }{\theta,\mathsf{let}~ 
				X=e_1~\mathsf{in}~e_2
				\arro{\ell} \theta',\mathsf{let}~ 
				X=e'_1~\mathsf{in}~e_2}}
		
		\hspace{1ex}
		
		(\mathit{Let2}) ~ {\displaystyle \frac{}{\theta,\mathsf{let}~ 
				X=v~\mathsf{in}~e
				\arro{\tau} \theta[X\mapsto v],e}} \\[4ex]
		
		(\mathit{Case1}) ~ {\displaystyle
			\frac{\theta,e\arro{\ell}
				\theta',e'}{\begin{array}{l}
					\theta,\mathsf{case}~e~\mathsf{of}~cl_1;\ldots;cl_n~\mathsf{end}
					\arro{\ell}
					\theta',\mathsf{case}~e'~\mathsf{of}~cl_1;\ldots;cl_n~\mathsf{end}\\
		\end{array}}}\\[4ex]
		
		(\mathit{Case2}) ~ {\displaystyle
			\frac{\mathsf{match}(\theta,v,cl_1,\ldots,cl_n) = \tuple{\theta_i,e_i}}{\theta,\mathsf{case}~v~\mathsf{of}~cl_1;\ldots;cl_n~\mathsf{end}
				\arro{\tau} \theta\theta_i,e_i}} \\[4ex]
		
		(\mathit{Call1}) ~ {\displaystyle
			\frac{\theta,e_i\arro{\ell}
				\theta',e'_i~~~i\in\{1,\ldots,n\}}{\theta,\mathsf{call}~op~(\ol{v_{1,i-1}},e_i,\ol{e_{i+1,n}})
				\arro{\ell}
				\theta',\mathsf{call}~op~(\ol{v_{1,i-1}},e'_i,\ol{e_{i+1,n}})}} \\[5ex]
		
		(\mathit{Call2}) ~ {\displaystyle
			\frac{\mathsf{eval}(op,v_1,\ldots,v_n)=v}{\theta,\mathsf{call}~op~(v_1,\ldots,v_n)
				\arro{\tau} \theta,v}} \\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{Call3}) ~ {\displaystyle
				\frac{\mathsf{evalM}(\M,op,v_1,\ldots,v_n)= (v,\M') }{\theta,\mathsf{call}~op~(v_1,\ldots,v_n)
					\arro{\tau\M\M'} \theta,v}} }\\[4ex]
		
		(\mathit{Apply1}) ~ {\displaystyle
			\frac{\theta,e_i\arro{\ell}
				\theta',e'_i~~~i\in\{1,\ldots,n\}}{\theta,\mathsf{apply}~a/n~(\ol{v_{1,i-1}},e_i,\ol{e_{i+1,n}}) 
				\arro{\ell}
				\theta',\mathsf{apply}~a/n~(\ol{v_{1,i-1}},e'_i,\ol{e_{i+1,n}})}}\\[5ex] 
		
		(\mathit{Apply2}) ~ {\displaystyle
			\frac{\mu(a/n) = \mathsf{fun}~(X_1,\ldots,X_n)\to e}{\theta,\mathsf{apply}~a/n~(v_1,\ldots,v_n)
				\arro{\tau} \theta\cup\{X_1\mapsto v_1,\ldots,X_n\mapsto v_n\},e}} %\{\ol{X_n\mapsto v_n}\},e}} 
	\end{array}
	\]
	\caption{Semantica standard: valutazione espressioni sequenziali} \label{fig:seq-rules}
\end{figure}

Le transizioni sono etichettate con $ \tau$ (una riduzione sequenziale senza side-effects), o con $\tau\M\M'$ che indica una riduzione che accede alla mappa senza side-effects, o con l'etichetta $\bot$ che indica la propagazione di un fallimento, o con un'etichetta che identifica la riduzione di un'azione con alcuni side-effects. Le etichette sono usate nelle regole di sistema (Figure~\ref {fig:system-rules}, \ref{fig:system-rules-map}) per determinare gli effetti collaterali associati e/o le informazioni da recuperare.
\newline
Nella Figura~\ref{fig:seq-rules} sono presenti le regole di transizione per la valutazione delle espressioni sequenziali.
\newline
Come in Erlang, consideriamo che l'ordine di valutazione degli argomenti in una tupla, lista, ecc. È fisso da sinistra a destra.
\newline
Per la valutazione dei case, si assume una funzione ausiliaria $\mathsf{match}$ che seleziona la prima clausola, $cl_i = (pat_i ~\mathsf{when} ~ e'_i \to e_i)$, in modo tale che $v$ corrisponda a $pat_i$, ovvero $ v = \theta_i (pat_i)$, e che la guardia sia soddisfatta, cioè, $\theta \theta_i, e'_i \too^\ast \theta ', true$. Come in Core Erlang, assumiamo che i patterns possano solo contenere nuove variabili (ma le guardie potrebbero avere variabili legate, quindi passiamo l'ambiente corrente $ \theta $ alla funzione $ \mathsf {match} $).
\newline
Le funzioni possono essere definite nel programma (in questo caso sono invocate da $\mathsf {apply}$) o essere un built-in (invocate da $\mathsf{call}$). In quest'ultimo caso vengono valutati utilizzando la funzione ausiliaria $\mathsf {eval}$.
\newline
Nella regola $\mathit {Apply2}$, si considera che la mappatura $\mu$ memorizza tutte le definizioni di funzione nel programma, cioè, mappa ogni nome di funzione $ a/n $ in una copia della sua definizione $\mathsf{fun} ~ (X_1, \ldots, X_n) \to e$, dove $ X_1, \ldots, X_n $ sono nuove variabili (distinte) e sono le uniche variabili che possono essere libere in $e$.
%
Per quanto riguarda le applicazioni, si noti che consideriamo solo il primo ordine funzioni. Per estendere la nostra semantica a considerare anche funzioni di ordine superiore, si dovrebbe ridurre il nome della funzione a \emph {chiusura} della forma $ (\theta ', \mathsf {fun} ~ (X_1, \ldots, X_n) \to e) $. 
\newline
Alle regole della semantica standard delle espressi sequenziali è stata aggiunta la regola $Call3$ utilizzata per la valutazione delle funzioni built-in che devono accedere alla mappa. Le funzioni built-in come si può vedere dalla regola $Call2$ vengono valutate tramite la funzione ausiliaria $\mathsf{eval}$, per questo motivo si è scelto di utilizzare la funzione ausiliaria $\mathsf{evalM}$ per valutare le funzioni built-in che utilizzano una mappa. Infatti per la valutazione $\mathsf{evalM}$ oltre a prendere in input i parametri prende in input pure la mappa, indicata con $\mathsf{M}$.
La funzione $\mathsf{evalM}$ e la funzione $\mathsf{eval}$ sono quindi sono due funzioni parziali visto che non è definito l'output per ogni input. $\mathsf{M'}$ corrisponde alla parte della mappa acceduta dalla funzione $\mathsf{evalM}$.
\newpage
\begin{figure}[h]
	\footnotesize
	\[
	\begin{array}{c}
		\mathcolorbox{yellow}{ (\mathit{TupleF}) ~ {\displaystyle 
				\frac{\theta,e_i \arro{\bot} fail
				}{\theta,\{\ol{v_{1,{i-1}}},e_i,\ol{e_{{i+1},n}}\}
					\arro{\bot} fail
		}}}\\[4ex] 
		
		\mathcolorbox{yellow}{(\mathit{List1F})  ~{\displaystyle 
				\frac{\theta,e_1 \arro{\bot} fail}
				{\theta,[e_1|e_2] \arro{\bot} fail}} 
			
			\hspace{2ex}
			
			(\mathit{List2F}) ~ {\displaystyle 
				\frac{\theta,e_2 \arro{\bot} fail }
				{\theta,[v_1|e_2]\arro{\bot} fail }} }\\[4ex]
		
		\mathcolorbox{yellow}{ (\mathit{Let1F}) ~ {\displaystyle \frac{\theta,e_1
					\arro{\bot} fail }{\theta,\mathsf{let}~ 
					X=e_1~\mathsf{in}~e_2
					\arro{\bot} fail}}} \\[4ex]
		
		\mathcolorbox{yellow}{ (\mathit{Case1F}) ~ {\displaystyle
				\frac{\theta,e\arro{\bot} fail
				}{\begin{array}{l}
						\theta,\mathsf{case}~e~\mathsf{of}~cl_1;\ldots;cl_n~\mathsf{end}
						\arro{\bot} fail
						
		\end{array}}}}\\[4ex]
		
		\mathcolorbox{yellow}{ (\mathit{Case2F}) ~ {\displaystyle
				\frac{\mathsf{match}(\theta,v,cl_1,\ldots,cl_n) = \emptyset }{\theta,\mathsf{case}~v~\mathsf{of}~cl_1;\ldots;cl_n~\mathsf{end}
					\arro{\bot} caseFail}}} \\[4ex]
		
		\mathcolorbox{yellow}{ (\mathit{Call1F}) ~ {\displaystyle
				\frac{\theta,e_i\arro{\bot} fail}
				{\theta,\mathsf{call}~op~(\ol{v_{1,i-1}},e_i,\ol{e_{i+1,n}})
					\arro{\bot } fail
		}}} \\[5ex]
		
		\mathcolorbox{yellow}{ (\mathit{Call2F}) ~ {\displaystyle
				\frac{\mathsf{eval}(op,v_1,\ldots,v_n) = \emptyset ~\land~ \mathsf{evalM}(\M,op,v_1,\ldots,v_n) = \emptyset  }{\theta,\mathsf{call }~ op (v_1,\dots,v_n)
					\arro{\bot} callFail}} }\\[4ex]

		\mathcolorbox{yellow}{ (\mathit{Apply1F}) ~ {\displaystyle
				\frac{\theta,e_i\arro{\bot} fail }
				{\theta,\mathsf{apply}~a/n~(\ol{v_{1,i-1}},e_i,\ol{e_{i+1,n}}) 
					\arro{\bot} fail
		}} }\\[5ex] 
		
		\mathcolorbox{yellow}{(\mathit{Apply2F}) ~ {\displaystyle
				\frac{\mu(a/n) = \emptyset }{\theta,\mathsf{apply}~a/n~(v_1,\ldots,v_n)
					\arro{\bot} applyFail}} }
		\end{array}
	\]
	\caption{Semantica standard: valutazione del fallimento delle espressioni sequenziali} \label{fig:seq-rules-fail}
\end{figure}
Nella Figura~\ref{fig:seq-rules-fail} sono presenti le regole di transizione che gestiscono i fallimenti.
La propagazione dell'errore è indicata dall'etichetta $\bot$, quindi se una valutazione di un'espressione fallisce allora il fallimento viene propagato. \\
Con il simbolo $\emptyset$ si intende: 
\begin{itemize}
	\item nel caso dei match, che l'argomento $v$ non corrisponde a nessuna clausola\footnote {Più precisamente in un programma Erlang quando è tradotto nella rappresentazione intermedia Core Erlang, viene aggiunta una clausola catch-all quindi il simbolo $\emptyset$ corrisponde al match della clausola aggiunta.};
	\item nei casi di eval, evalM e $\mu$ significa che le funzioni non sono definite sull'input dato.
\end{itemize}
\begin{figure}[h]
	\footnotesize
	\[
	\begin{array}{c}
		(\mathit{Send1}) ~ {\displaystyle 
			\frac{\theta,e_1 \arro{\ell} \theta',e'_1}{\theta,e_1\:!\: e_2 \arro{\ell}
				\theta',e'_1\:!\: e_2} ~~~~(\mathit{Send2}) ~\frac{\theta,e_2 \arro{\ell} \theta',e'_2}{\theta,v_1\:!\: e_2 \arro{\ell}
				\theta',v_1\:!\: e'_2} 
		}\\[4ex]
		
		(\mathit{Send3}) ~ {\displaystyle
			\frac{  }{\theta,v_1\:!\: v_2 \arro{\mathsf{send}(v_1,v_2)} \theta,v_2}
		}\\[4ex]
		
		(\mathit{Receive}) ~ {\displaystyle
			\frac{~}{\theta,\mathsf{receive}~cl_1;\ldots;cl_n~\mathsf{end}
				\arro{\mathsf{rec}(\kappa,\ol{cl_n})}
				\theta,\kappa
			}
		}\\[4ex]
		
		(\mathit{Spawn1}) ~ {\displaystyle
			\frac{\theta,e_i\arro{\ell}
				\theta',e'_i~~~i\in\{1,\ldots,n\}}{\theta,\mathsf{spawn}(a/n,[\ol{v_{1,i-1}},e_i,\ol{e_{i+1,n}}])
				\arro{\ell} \theta',\mathsf{spawn}(a/n,[\ol{v_{1,i-1}},e'_i,\ol{e_{i+1,n}}])       
		}}\\[4ex]
		
		(\mathit{Spawn2}) ~ {\displaystyle
			\frac{}{\theta,\mathsf{spawn}(a/n,[\ol{v_n}])
				\arro{\mathsf{spawn}(\kappa,a/n,[\ol{v_n}])} \theta,\kappa         
		}}\\[4ex]
		
		(\mathit{Self}) ~ {\displaystyle
			\frac{}{\theta,\mathsf{self}() \arro{\mathsf{self}(\kappa)} \theta,\kappa}}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{Register1}) ~ {\displaystyle 
				\frac{\theta, e_1 \arro{\ell} \theta',e'_1}{\theta, \mathsf{register}(e_1, e_2) \arro{\ell}
					\theta',\mathsf{register}(e'_1, e_2)} ~~~~
		}}\\[4ex]
		
		\mathcolorbox{yellow}{  (\mathit{Register2}) ~{\displaystyle
				\frac{\theta,e_2 \arro{\ell} \theta',e'_2}{\theta,\mathsf{register}(v_1, e_2) \arro{\ell}
					\theta',\mathsf{register}(v_1, e'_2)} 
		}}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{Register3}) ~ {\displaystyle
				\frac{~}{\theta,\mathsf{register}(v_1, v_2) \arro{\mathsf{register}(\kappa,v_1,v_2)} \theta,\kappa}}
		}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{Unregister1}) ~ {\displaystyle 
				\frac{\theta, e \arro{\ell} \theta',e'}{\theta, \mathsf{unregister}(e) \arro{\ell}
					\theta',\mathsf{unregister}(e')}}}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{Unregister2}) ~ {\displaystyle
				\frac{~}{\theta,\mathsf{unregister}(v) \arro{\mathsf{unregister}(\kappa,v)} \theta,\kappa}}
		}
	\end{array}
	\]
	\caption{Semantica standard: valutazione delle espressioni concorrenti} \label{fig:concurrent-rules}
\end{figure}

Consideriamo ora la valutazione di espressioni concorrenti che producono side-effects (Figura~\ref{fig:concurrent-rules}). Abbiamo le regole $\mathit{Send1}$, $\mathit {Send2}$ e $\mathit{Send3}$ per `` $! $ ''. In questo caso sappiamo \emph{localmente} a cosa dovrebbe essere ridotta l'espressione (cioè $ v_2 $ nella regola $\mathit {Send3}$). Per le restanti regole, questo non è noto localmente e, quindi, restituiamo un nuovo simbolo distinto, $\kappa $,  che viene trattato come una variabile, in modo che nelle regole di sistema nella figure~\ref{fig:system-rules}, \ref{fig:system-rules-map} $\kappa$ legherà al suo valore corretto:\footnote {Nota che $\kappa$ assume valori nel dominio $expr \cup Pid $, al contrario delle variabili ordinarie che possono essere associate solo a valori.} l'espressione selezionata nella regola $\mathit {Ricevive} $, un pid nelle regole $\mathit {Spawn}$ e $\mathit{Self}$ e \textbf{true} o \textbf{false} nelle regole $\mathit{Register}$ e $\mathit{Unregister}$. In questi casi, l'etichetta della transizione contiene tutte le informazioni necessarie alle regole di sistema per eseguire la valutazione a livello di sistema, incluso il simbolo $\kappa$. Questo \emph{trucco} ci permette di mantenere separate le regole per espressioni e sistemi (cioè, la semantica mostrata nelle Figura~\ref {fig:seq-rules} e \ref{fig:concurrent-rules} è per lo più indipendente dalle regole nelle Figure~\ref{fig:system-rules}, \ref{fig:system-rules-map}), in contrasto con altre semantiche di Erlang, ad esempio \cite{CMRT13tr}, dove sono combinate in una singola relazione di transizione.
Nelle regole di valutazione delle espressioni concorrenti della semantica standard sono state aggiunte le regole per la valutazione della $\mathsf{register}$ e dell'$\mathsf{unregister}$.

\begin{figure}[h]
	\footnotesize
	\[
	\begin{array}{c}	
		\mathcolorbox{yellow}{ (\mathit{Send1F}) ~ {\displaystyle 
				\frac{\theta,e_1 \arro{\bot} fail}
				{\theta,e_1\:!\: e_2 \arro{\bot} fail} ~~~~
				
				(\mathit{Send2F}) ~\frac{\theta,e_2 \arro{\bot} fail}
				{\theta,v_1\:!\: e_2 \arro{\bot} fail} 
		}}\\[4ex]
		
		\mathcolorbox{yellow}{ (\mathit{Spawn1F}) ~ {\displaystyle
				\frac{\theta,e_i\arro{\bot} fail}
				{\theta,\mathsf{spawn}(a/n,[\ol{v_{1,i-1}},e_i,\ol{e_{i+1,n}}])
					\arro{\bot} fail         
		}}}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{Register1F}) ~ {\displaystyle 
				\frac{\theta, e_1 \arro{\bot} fail}
				{\theta, \mathsf{register}(e_1, e_2) \arro{\bot} fail} ~~~~
			
				(\mathit{Register2F}) ~\frac{\theta,e_2 \arro{\bot} fail}
				{\theta,\mathsf{register}(v_1, e_2) \arro{\bot } fail} 
		}}\\[4ex]
		
		\mathcolorbox{yellow}{ (\mathit{Unregister1F}) ~ {\displaystyle 
				\frac{\theta, e \arro{\bot} fail}
				{\theta, \mathsf{unregister}(e) \arro{\bot} fail }}}
	\end{array}
	\]
	\caption{Semantica standard: valutazione del fallimento delle espressioni concorrenti} \label{fig:concurrent-rules-fail}
\end{figure}
~\newline
Anche nelle regole della valutazione delle espressioni concorrenti sono state aggiunte le regole che gestiscono il fallimento di un processo e che propagano il fallimento della valutazione di un'espressione.
\newline
Ora si possono presentare le regole di sistema che sono rappresentate nelle figure~\ref{fig:system-rules} e \ref{fig:system-rules-map}, in tutte le regole viene considerato un sistema generale nella forma $\Gamma;\tuple{p,(\theta,e),q}\:\comp\: \Pi;\M$ dove $\Gamma$ è la casella di posta globale, $\tuple{p,(\theta,e),q}\:\comp\: \Pi$ è l'insieme dei processi che contiene almeno un processo e $\M$ è la mappa dei pid registrati. Rispetto all'articolo \cite{Lanese} in tutte le regole è stata aggiunta $\M$ visto che la definizione di sistema (Definizione~\ref{sistema}) è cambiata.\\
Ora verranno descritte brevemente tutte le regole di transizione del sistema. 
\begin{figure}[th]
	\footnotesize
	\[
	\begin{array}{c}
		(\mathit{Seq}) ~ {\displaystyle
			\frac{\theta,e\arro{\tau} \theta',e'
			}{\Gamma;\tuple{p,(\theta,e),q}\comp \Pi; \mathcolorbox{yellow}{\M} \hoo
				\Gamma;\tuple{p,(\theta',e'),q}\comp \Pi; \mathcolorbox{yellow}{\M}}
		}\\[4ex]
		
		\mathcolorbox{yellow}{\mathit{(Call3)} ~ {\displaystyle
				\frac{\theta,e\arro{\tau\M\M'} \theta',e'
				}{\Gamma;\tuple{p,(\theta,e),q}\comp \Pi; \M \hoo
					\Gamma;\tuple{p,(\theta',e'),q}\comp \Pi; \M}
		}}\\[4ex]
		
		(\mathit{Send}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{send}(p'',v)}
				\theta',e'  ~~~ \mathcolorbox{yellow}{\mathsf{isAtom}(p'')=false }
			}{\Gamma;\tuple{p,(\theta,e),q} 
				\comp \Pi; \mathcolorbox{yellow}{\M} \hoo \Gamma\cup (p'',v);\tuple{p,(\theta',e'),q}\comp \Pi; \mathcolorbox{yellow}{\M}}
		}\\[4ex]
		
		\mathcolorbox{yellow}{  (\mathit{SendA}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{send}(a,v)}
					\theta',e'  ~~~ \mathsf{isAtom}(a)=true ~~ \mathsf{matchPid}(\M, a) = p''
				}{\Gamma;\tuple{p,(\theta,e),q} 
					\comp \Pi;\M \hoo \Gamma\cup (p'',v);\tuple{p,(\theta',e'),q}\comp \Pi;\M}
		}}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{SendF}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{send}(a,v)}
					\theta',e'  ~~~ \mathsf{isAtom}(a)=true ~~\mathsf{matchPid}(\M, a) = false
				}{\Gamma;\tuple{p,(\theta,e),q} 
					\comp \Pi; \mathcolorbox{yellow}{\M} \hoo \Gamma;\tuple{p,(\theta,sendFail),q}\comp \Pi; {\M}}
		}}\\[4ex]
		
		(\mathit{Receive}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{rec}(\kappa,\ol{cl_n})}
				\theta',e'~~~ \mathsf{matchrec}(\theta,\ol{cl_n},q) =
				(\theta_i,e_i,v)} {\Gamma;\tuple{p,(\theta,e),q}\comp \Pi; \mathcolorbox{yellow}{\M} \hoo
				\Gamma;\tuple{p,(\theta'\theta_i,e'\{\kappa\mapsto
					e_i\}),q\backslash\!\!\backslash v}\comp \Pi; \mathcolorbox{yellow}{\M}}
		}\\[4ex]
		
		(\mathit{Spawn}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{spawn}(\kappa,a/n,[\ol{v_n}])}
				\theta',e'~~~ p'~\mbox{is a fresh pid}}{\Gamma;\tuple{p,(\theta,e),q} 
				\comp \Pi; \mathcolorbox{yellow}{\M} \hoo \Gamma;\tuple{p,(\theta',e'\{\kappa\mapsto p'\}),q}\comp \tuple{p',(\id,\mathsf{apply}~a/n~(\ol{v_n})),\nil} 
				\comp \Pi; \mathcolorbox{yellow}{\M}}
		}\\[4ex]
		
		(\mathit{Self}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{self}(\kappa)} \theta',e'}{\Gamma;\tuple{p,(\theta,e),q} 
				\comp \Pi; \mathcolorbox{yellow}{\M} \hoo \Gamma;\tuple{p,(\theta',e'\{\kappa\mapsto p\}),q} 
				\comp \Pi; \mathcolorbox{yellow}{\M} }
		}\\[4ex]
		
		(\mathit{Sched}) ~ {\displaystyle
			\frac{~}{\Gamma\cup\{(p,v)\};\tuple{p,(\theta,e),q}\comp\Pi; \mathcolorbox{yellow}{\M} 
				\hoo \Gamma;\tuple{p,(\theta,e),v\cons q}\comp\Pi; \mathcolorbox{yellow}{\M}}
		}
	\end{array}
	\]
	\caption{Regole standard della semantica del sistema} \label{fig:system-rules}
\end{figure}

La regola $\mathit{Seq}$ aggiorna semplicemente il controllo $(\theta, e)$ del processo considerato quando un'espressione sequenziale viene ridotta utilizzando le regole di espressione.

La regola $\mathit{Call3}$ come $\mathit{Seq}$ aggiorna semplicemente il controllo $(\theta, e)$ del processo considerato quando un'espressione sequenziale viene ridotta utilizzando le regole di espressione, però accede alla mappa, quindi utilizza l'etichetta $\tau\M\M'$ invece di $\tau$.

Le regole $\mathit{Send} $ e $\mathit{SendA} $ aggiungono la coppia $(p '', v)$ alla casella di posta globale $\Gamma$ invece di aggiungerla alla coda del processo $p ''$. Ciò è necessario per garantire che tutti i possibili intrecci di messaggi siano modellati correttamente.
È stata introdotta la funzione ausiliaria $\mathsf{isAtom}$ che viene utilizzata per capire se la regola debba accedere alla mappa, l'unica differenza fra le due regole è che la $\mathit{SendA}$ utilizza un atomo come destinatario. 
Si noti che $e '$ è solitamente diverso da $v$ poiché $e$ può avere operatori annidati diversi. Ad esempio, se $e$ ha la forma `` $\mathsf{case} ~ \mathrm{p} \:! \: V ~ \mathsf {of} ~ \{\ldots \} $,'' allora $ e '$ sarà ``$ \mathsf {case} ~ v ~ \mathsf {of} ~ \{\ldots \} $'' con etichetta $ \mathsf {send} (\mathrm {p}, v) $.

La regola $\mathit{SendF}$ introduce un fallimento, infatti l'espressione da valutare successivamente nel processo sarà $sendFail$ un atomo che corrisponde ad un fallimento perché all'atomo che si utilizza per inviare un messaggio non è associato nessun pid che si capisce grazie alla funzione $\mathsf{matchPid}$.
	
Nella regola $ \mathit {Receive} $, usiamo la funzione ausiliaria $ \mathsf {matchrec} $ per valutare un'espressione di ricezione. La differenza principale con $\mathsf {match}$ è che $\mathsf{matchrec}$ prende anche una coda $q$ e restituisce il messaggio selezionato $v$. Più precisamente, la funzione $ \mathsf {matchrec} $ esegue la scansione della coda $ q $ cercando il \emph {primo} messaggio $ v $ che corrisponde a un modello dell'istruzione di ricezione. Quindi, $ \kappa $ viene associato all'espressione nella clausola selezionata, $ e_i $, e l'ambiente viene esteso con la sostituzione corrispondente.
		
Se nessun messaggio nella coda $ q $ corrisponde ad alcuna clausola, la regola non è applicabile e il processo selezionato non può essere ridotto (cioè viene sospeso). Come nelle espressioni case, assumiamo che i pattern possano contenere solo nuove variabili.
		
Le regole presentate finora consentono di memorizzare i messaggi nella casella di posta globale, ma non di rimuoverne i messaggi. Questo è esattamente il compito dello scheduler, modellato dalla regola $ \mathit{Sched} $. Questa regola sceglie in modo non deterministico una coppia $ (p, v) $ nella cassetta postale globale $ \Gamma $ e consegna il messaggio $ v $ al processo di destinazione $ p $. Qui, ignoriamo deliberatamente la restrizione: `` i messaggi inviati, direttamente, tra due processi dati arrivano nello stesso ordine in cui sono stati inviati ", poiché le attuali implementazioni lo garantiscono solo all'interno dello stesso nodo. In pratica, ignorare questa restrizione equivale a considerare che ogni processo è potenzialmente eseguito in un nodo diverso. Una definizione alternativa che garantisce questa restrizione può essere trovata in \cite{NPV16b}.

      \begin{figure}[th]
	\footnotesize
	\[
	\begin{array}{c}
		
		\mathcolorbox{yellow}{(\mathit{Register T}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{register}(\mathsf{true},a,p')}
					\theta',e' ~ \mathsf{matchMapReg}(\M, a,p') = true} {\Gamma;\tuple{p,(\theta,e),q}\comp \Pi; \M \hoo
					\Gamma;\tuple{p,(\theta',e'),q}\comp \Pi; \M\cup(a,p')  }
		}}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{Register F}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{register}(\mathsf{false},a,p')}
					\theta',e' ~ \mathsf{matchMapReg}(\M, a,p') = false} {\Gamma;\tuple{p,(\theta,e),q}\comp \Pi; \M \hoo
					\Gamma;\tuple{p,(\theta,regFail),q}\comp \Pi; \M}
		}}\\[4ex]      
		
		\mathcolorbox{yellow}{(\mathit{UnregisterT}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{unregister}(\mathsf{true},a)}
					\theta',e' ~ \mathsf{matchMapUnreg}(\M, a) = p'} {\Gamma;\tuple{p,(\theta,e),q}\comp \Pi; \M \hoo
					\Gamma;\tuple{p,(\theta',e'),q}\comp \Pi; \M\backslash\!\!\backslash(a,p')  }
		}}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{UnregisterF}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{unregister}(\mathsf{false},a)}
					\theta',e' ~ \mathsf{matchMapUnreg}(\M,a) = false} {\Gamma;\tuple{p,(\theta,e),q}\comp \Pi; \M \hoo
					\Gamma;\tuple{p,(\theta,unregFail),q}\comp \Pi; \M  }
		}}\\[4ex]
	
		\mathcolorbox{yellow}{(\mathit{Catch}) ~ {\displaystyle
				\frac{ \theta,e \arro{\bot}  fail  }{\Gamma;\tuple{p,(\theta,e),q}\comp \Pi; \M \hoo
					\Gamma;\tuple{p,(\theta,fail),q}\comp \Pi; \M}
		}}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{End}) ~ {\displaystyle
				\frac{ \mathsf{matchEnd}(\M,p)=a'  ~~  }{\Gamma;\tuple{p,(\theta,\epsilon),q}\comp \Pi; \M \hoo
					\Gamma;\tuple{p,(\theta,\epsilon),q}\comp \Pi; \M\backslash\!\!\backslash (a' ,p)}
		}}
		\end{array}
	\]
	\caption{Regole standard della semantica del sistema che utilizzano la mappa} \label{fig:system-rules-map}
\end{figure}

Nella figura \ref{fig:system-rules-map} si può notare che sono state aggiunte anche le regole per la $\mathsf{register}$ e per l'$\mathsf{unregister}$.
Queste regole sono divise in 2 casi:
\begin{itemize}
	\item il caso di successo;
	\item il caso di fallimento (che introduce come prossima espressione da valutare un atomo che descrive un fallimento).
\end{itemize}
Il caso di successo corrisponde alle regole $\mathit{RegisterT}$ e $\mathit{UnregisterT}$ che rispettivamente aggiungono la coppia $(a,p')$ alla mappa e tolgono la coppia $(a,p')$ dalla mappa.
Mentre il caso di fallimento corrisponde alle regole $\mathit{RegisterF}$ e $\mathit{UnregisterF}$. 

La regola $\mathit{Catch}$ serve per gestire il caso di fallimento di un processo. In questo caso il fallimento viene catturato al top-level.

La regola $End$ serve per gestire il caso di fine di un processo. In caso di fallimento o terminazione di un processo se il processo è registrato viene deregistrato. 

Questa scelta è stata fatta per essere il più possibili fedeli al comportamento di Erlang, visto che nel linguaggio utilizzato non sono presenti le eccezioni.

\subsection*{Concorrenza in Erlang}

Per definire una semantica reversibile per Erlang abbiamo bisogno non solo di una semantica come quella appena presentata, ma anche di una nozione di concorrenza (o, equivalentemente, della nozione opposta di conflitto). 

Dati i sistemi $ s_1, s_2 $, chiamiamo $ s_1 \hoo ^ \ast s_2 $ una \emph {derivazione}.
%
Le derivazioni in un passaggio sono chiamate semplicemente \emph {transizioni}. Usiamo $ d, d ', d_1, \ldots $ per indicare le derivazioni e $ t, t', t_1, \ldots $ per le transizioni.

Le transizioni vengono etichettate con: $s_1 \hoo_{p,r} s_2$ dove:
\begin{itemize}
	\item $p$ è il pid del processo selezionato nella transizione o del processo a cui viene consegnato un messaggio (se la regola applicata è  $\mathit{Sched})$;
	\item $r$ è l'etichetta della regola di transizione applicata. 
\end{itemize}
Data una derivazione $ d = (s_1 \hoo ^\ast s_2) $, definiamo $ \init(d) = s_1 $ e $ \final(d) = s_2 $.
Due derivazioni, $ d_1 $ e $ d_2 $, sono \emph{componibili} se $\final(d_1) = \init (d_2) $. In questo caso, $ d_1; d_2 $ corrisponde alla composizione $d_1; d_2=(s_1\hoo s_2\hoo\cdots\hoo s_n\hoo s_{n + 1}\hoo\cdots\hoo s_m)$ se $d_1 = (s_1 \hoo s_2 \hoo \cdots \hoo s_n) $ e $ d_2 = (s_n \hoo s_ {n + 1} \hoo \cdots \hoo s_m)$.
Due derivazioni, $ d_1 $ e $ d_2 $, sono dette \emph{coiniziali} se $\init(d_1) = \init (d_2) $ e \emph {cofinali} se $\final(d_1) = \final( d_2)$.

\begin{definition}[Transizioni concorrenti] \label{def:concurrent1}
	Date due transizioni coiniziali, $t_1 = (s \hoo_{p_1,r_1} s_1)$
	e $t_2 = (s \hoo_{p_2,r_2} s_2)$, si dice che sono
	\emph{in conflitto} se:
  \begin{itemize}
	\item considerano lo stesso processo, i.e., $p_1 = p_2$, e anche $r_1 = r_2 = \mathit{Sched}$ o se una transizione applica la regola $\mathit{Sched}$ e l'altra applica la regola $\mathit{Receive}$ \cite{Lanese};
	\item entrambe sono operazioni sulla mappa e una delle due regole accede in scrittura sulla mappa ($\mathsf{RegisterT}$, $\mathsf{UnregisterT}$, $\mathsf{End}$) e l'altra accede o in scrittura o in lettura ($\mathsf{SendA}$, $\mathsf{SendF}$, $\mathsf{RegisterF}$, $\mathsf{UnregisterF}$, $\mathsf{Call3}$) sulla mappa, in modo che una delle funzioni ($\mathsf{matchPid}$, $\mathsf{matchMapReg}$, $\mathsf{matchMapUnreg}$, $\mathsf{matchEnd}$, $\mathsf{evalM}$) utilizzate non abbia più lo stesso risultato. I casi in cui questo accade sono presenti nella tabella~\ref{tab:conflitti}.
	\begin{table}[h]
		\hspace{-15ex}
		\begin{tabular}{|l|l|lllllll}
			\hline
			\backslashbox{$~r_1~~$} {$~~r_2~$} & $\mathsf{Call3}$ & \multicolumn{1}{l|}{$\mathsf{UnregisterF}$} & \multicolumn{1}{l|}{$\mathsf{RegisterF}$} & \multicolumn{1}{l|}{$\mathsf{SendF}$} & \multicolumn{1}{l|}{$\mathsf{SendA}$} & \multicolumn{1}{l|}{$\mathsf{End}$} & \multicolumn{1}{l|}{$\mathsf{UnregisterT}$} & \multicolumn{1}{l|}{$\mathsf{RegisterT}$} \\ \hline
			$\mathsf{RegisterT}$   &    \begin{tabular}[c]{@{}l@{}}$a'  \in \mathsf{M'} ~\lor$ \\ $ p' \in \mathsf{M'}$\end{tabular}   & \multicolumn{1}{l|}{$a'=a''$}            & \multicolumn{1}{l|}{}          & \multicolumn{1}{l|}{$a'=a''$}      & \multicolumn{1}{l|}{}      & \multicolumn{1}{l|}{}    & \multicolumn{1}{l|}{}            & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}$a'=a'' ~\lor$ \\ $ p'=p''$\end{tabular}}          \\ \hline
			$\mathsf{UnregisterT}$ &  \begin{tabular}[c]{@{}l@{}}$a'  \in \mathsf{M'} ~\lor$ \\ $ p' \in \mathsf{M'}$\end{tabular}      & \multicolumn{1}{l|}{}            & \multicolumn{1}{l|}{$a'=a''$}          & \multicolumn{1}{l|}{}      & \multicolumn{1}{l|}{$a'=a''$}& \multicolumn{1}{l|}{$a'=a''$}    & \multicolumn{1}{l|}{$a'=a''$}            &                                \\ \cline{1-8}
			$\mathsf{End}$         &    \begin{tabular}[c]{@{}l@{}}$a'  \in \mathsf{M'} ~\lor$ \\ $ p' \in \mathsf{M'}$\end{tabular}   & \multicolumn{1}{l|}{}            & \multicolumn{1}{l|}{$a'=a''$}          & \multicolumn{1}{l|}{}      & \multicolumn{1}{l|}{$a'=a''$}      & \multicolumn{1}{l|}{}    &                                  &                                \\ \cline{1-7}
			$\mathsf{SendA}$       &       & \multicolumn{1}{l|}{}            & \multicolumn{1}{l|}{}          & \multicolumn{1}{l|}{}      & \multicolumn{1}{l|}{}      &                          &                                  &                                \\ \cline{1-6}
			$\mathsf{SendF}$       &       & \multicolumn{1}{l|}{}            & \multicolumn{1}{l|}{}          & \multicolumn{1}{l|}{}      &                            &                          &                                  &                                \\ \cline{1-5}
			$\mathsf{RegisterF}$   &       & \multicolumn{1}{l|}{}            & \multicolumn{1}{l|}{}          &                            &                            &                          &                                  &                                \\ \cline{1-4}
			$\mathsf{UnregisterF}$ &       & \multicolumn{1}{l|}{}            &                                &                            &                            &                          &                                  &                                \\ \cline{1-3}
			$\mathsf{Call3}$       &       &                                  &                                &                            &                            &                          &                                  &                                \\ \cline{1-2}
		\end{tabular}
		\caption{\label{tab:conflitti} Tabella dei conflitti}
	\end{table}

	Nella Tabella~\ref{tab:conflitti} sono presenti i casi in cui si verificano i conflitti, $a'$ e $p'$ rappresentano l'atomo e il pid coinvolti da $r_1$, mentre $a''$ e $p''$ rappresentano l'atomo e il pid coinvolto da $r_2$. $\mathsf{M'}$ rappresenta gli elementi letti nella mappa dalla regola $\mathsf{Call3}$. Le celle vuote rappresentano transizioni coiniziali che non vanno in conflitto.\\
	Da notare che non tutte le operazioni in scrittura sulla mappa sono in conflitto fra di loro questo perché in quei casi le transizioni non possono essere coiniziali e in conflitto. 
\end{itemize}
Due transizioni coiniziali sono \emph{concorrenti} se non sono in conflitto. \qed
\end{definition}
	\begin{example}
	Nel caso $\mathsf{RegisterT}, ~ \mathsf{UnregisterT}$ non può essere presente un conflitto quando le due transizioni sono coiniziali perché si dovrebbe avere che $a'$ non dovrebbe appartenere alla mappa di atomi e pid per applicare $\mathsf{RegisterT}$, $a''$ dovrebbe appartenere alla mappa di atomi e pid per poter applicare $\mathsf{UnregisterT}$ e per essere in conflitto $a'$ dovrebbe essere uguale ad $a''$ il che è impossibile. 
\end{example}

Questa definizione è utile per la dimostrazione del prossimo lemma.

\begin{lemma}[\textbf{Square lemma}] \label{lemma:square1} Date due transizioni coiniziali concorrentu $t_1 = (s \hoo_{p_1,r_1} s_1)$ e
	$t_2 = (s \hoo_{p_2,r_2} s_2)$, allora esistono due transizioni cofinali $t_2/t_1 = (s_1 \hoo_{p_2,r_2} s')$ e
	$t_1/t_2 = (s_2 \hoo_{p_1,r_1} s')$.  Graficamente,
	\[
	\begin{minipage}{50ex}
		\xymatrix@C=50pt@R=20pt{
			s \ar@{^{(}->}[r]^{p_1,r_1} \ar@<1pt>@{^{(}->}[d]_{p_2,r_2} & s_1\\
			s_2 & 
		}
	\end{minipage}
	~~
	\Longrightarrow
	~~
	\begin{minipage}{50ex}
		\xymatrix@C=50pt@R=20pt{
			s \ar@{^{(}->}[r]^{p_1,r_1} \ar@{^{(}->}[d]_{p_2,r_2} & s_1 \ar@{^{(}->}[d]^{p_2,r_2}\\
			s_2 \ar@{^{(}->}[r]_{p_1,r_1} &  s'
		}
	\end{minipage}
	\]
\end{lemma}
\begin{proof}
	Abbiamo i seguenti casi:
	\begin{itemize}
		\item entrambe le transizioni non applicano regole sulla mappa:
			\begin{itemize}
		\item due transizioni $ t_1 $ e $ t_2 $ dove $r_1\neq\mathit{Sched}$ e $r_2\neq\mathit{Sched}$. Banalmente, si applicano a processi diversi, ad esempio $p_1\neq p_2$. Quindi, possiamo facilmente dimostrare che applicando la regola $r_2$ a $p_1$ in $s_1$ e la regola $r_1$ a $p_2$ in $s_2$ abbiamo due transizioni $t_1/t_2$ e $t_2/t_1$ che sono cofinali \cite{Lanese};
		\item una transizione $t_1$ che applica la regola $r_1=\mathit{Sched}$ per consegnare il messaggio $v_1$ all'elaborazione $p_1=\mathrm{p}$, e un'altra transizione che applica una regola $r_2$ diversa da $\mathit{Sched}$. Tutti i casi tranne $r_2=\mathit{Ricevi}$ con $p_2=\mathrm{p}$ sono semplici. Quest'ultimo caso, tuttavia, non può accadere poiché le transizioni che utilizzano le regole $\mathit{Sched}$ e $\mathit{Ricevi}$ non sono simultanee \cite{Lanese};
		\item due transizioni $ t_1 $ e $ t_2 $ con le regole $ r_1 = r_2 = \mathit {Sched} $ che consegnano rispettivamente i messaggi $ v_1 $ e $ v_2 $. Poiché le transizioni sono simultanee, dovrebbero consegnare i messaggi a processi differenti, cioè $ p_1 \neq p_2 $. Pertanto, possiamo vedere che consegnando $ v_2 $ da $ s_1 $ e $ v_1 $ da $ s_2 $ otteniamo due transizioni cofinali \cite{Lanese}; 
				\end{itemize}
		\item due transizioni $t_1$ e $t_2$ dove $r_1 = $ operazione sulla mappa e $r_2 \neq $ operazione sulla mappa. Quindi, possiamo facilmente dimostrare che applicando la regola $r_2$ a $p_1$ in $s_1$ e la regola $r_1$ a $p_2$ in $s_2$ abbiamo due transizioni $t_1 / t_2$ e $t_2 / t_1$ che sono cofinali;
		\item vale anche se entrambe le operazioni $r$ sono eseguite sulla mappa, questo perché se andassero a modificare gli stessi elementi della mappa non potrebbero essere concorrenti per la definizione data: 
		\begin{itemize}
			\item se $r_1 = r_2 = \mathsf{UnregisterT}$ e deregistrano gli atomi $a_1$ e $a_2$ se le due operazioni sono concorrenti (quindi $a_1 \not= a_2$), deregistrare prima $a_1$ e poi $a_2$ o viceversa non cambia (in $s'$ la mappa sarà la stessa);
			\item  questo ragionamento lo si può fare con tutte le regole sulla mappa. 
		\end{itemize}
	\end{itemize}
\end{proof} 

Notiamo qui che sono possibili altre definizioni di transizioni concorrenti. La modifica del modello di concorrenza richiederebbe la modifica delle informazioni memorizzate nella semantica reversibile al fine di preservare la coerenza causale. Abbiamo scelto la nozione sopra poiché è ragionevolmente semplice da definire e perché è facile lavorarci.

\section{Semantica reversibile}\label{sect:semreversibile}

In questa sezione, introduciamo una semantica reversibile (non controllata) per il linguaggio considerato. Grazie al design modulare della semantica concreta, non è necessario modificare le regole di transizione per le espressioni del linguaggio per definire la semantica reversibile.

Per essere precisi, in questa sezione introduciamo due relazioni di transizione: $ \rh $ e $ \lh $. La prima relazione, $ \rh $, è un'estensione conservativa della semantica standard $ \hoo $ (Figure~\ref {fig:system-rules} e \ref{fig:system-rules-map}) per includere anche alcune informazioni aggiuntive negli stati, seguendo un tipico incorporamento di Landauer. Ci riferiamo a $ \rh $ come alla semantica reversibile \emph{forward} (o semplicemente alla semantica forward). Al contrario, la seconda relazione, $ \lh $, procede nella direzione all'indietro, ``annullando'' le azioni passo dopo passo. Ci riferiamo a $ \lh $ come semantica \emph{backward} (reversibile). Indichiamo l'unione $ \rh \cup \lh $ con $ \rlh $.

Per evitare di annullare tutte le azioni fino all'inizio del processo, lasceremo anche che il programmatore introduca \emph{checkpoints}. Sintatticamente, sono indicati con la funzione incorporata \textsf{check}, che accetta un identificatore $ \mathtt{t} $ come argomento. Tali identificatori dovrebbero essere univoci nel programma. Data un'espressione, $ expr $, possiamo introdurre un checkpoint sostituendo $ expr $ con `` $\mathsf {let} ~ X = \mathsf {check} (\mathtt {t}) ~ \mathsf {in} ~ expr $''. Una chiamata nella forma $ \mathsf {check} (\mathtt {t}) $ restituisce semplicemente $ \mathtt {t} $ (vedi sotto).
Di seguito, consideriamo che le regole per valutare le espressioni del linguaggio (Figure~\ref {fig:seq-rules} e \ref{fig:concurrent-rules}) sono estese con la seguente regola:
\[
(\mathit{Check}) ~~ 
{\displaystyle 
   	\frac{}{\theta,\mathsf{check}(\mathtt{t}) \arro{\mathsf{check}(\mathtt{t})} \theta,\mathtt{t}}}
\]

Le principali modifiche effettuate sono state l'aggiunta di una storia al processo, di un identificatore per i messaggi (un timestamp $\lambda$)~\cite{Lanese} e di una storia della mappa. 
L'aggiunta della storia del processo e della mappa è un tipico incorporamento di Laundered in cui viene aggiunta la cronologia delle operazioni eseguite dal processo (nel primo caso) e delle operazioni eseguite sulla mappa. Il sistema ora include una memoria (storia) che registra gli stati intermedi della mappa. Questo è stato fatto perché in questo modo è possibile tenere traccia delle operazioni che sono state eseguite sulla mappa e del loro ordine di esecuzione.

Al messaggio è stato aggiunto un timestamp perché  se si considera un processo $ \mathrm {p1} $ che invia due messaggi identici ad un altro processo $ \mathrm {p2} $ (il che non è insolito, ad esempio un ``ack'' dopo aver ricevuto una richiesta), per annullare la prima azione $ \mathrm {p2} \:! \: \mathrm {v} $ del processo $ \mathrm {p1} $ è necessario annullare tutte le azioni del processo $ \mathrm {p2 } $ fino alla ricezione del primo messaggio. Tuttavia, non possiamo distinguere il primo messaggio dal secondo a meno che non si tenga conto di alcune informazioni aggiuntive. Pertanto, è necessario introdurre un identificatore univoco per distinguere con precisione questo caso.

\begin{figure}[htp]
	\footnotesize
	\[
	\begin{array}{c}
		(\mathit{Seq}) ~ {\displaystyle
			\frac{\theta,e\arro{\tau} \theta',e'
			}{\Gamma;\tuple{p,\h,(\theta,e),q}\comp \Pi;\mathcolorbox{yellow}{\M;\s} \rh
				\Gamma;\tuple{p,\tau(\theta,e)\cons\h,(\theta',e'),q}\comp \Pi;\mathcolorbox{yellow}{\M;\s} }
		}\\[4ex]
	
			\mathcolorbox{yellow}{(\mathit{Call3}) ~ {\displaystyle
			\frac{\theta,e\arro{\tau\M\M'} \theta',e'}
			{      \begin{split}
					\Gamma;\tuple{p,\h,(\theta,e),q}\comp \Pi;\M;\s 
					\rh \Gamma;\tuple{p,\tau\M\M'(\theta,e,p)\cons\h,(\theta',e'),q}\comp \Pi;\\
					\M;\tau\mathsf{MM'}(\theta,e,p)\cons\s
				\end{split}
			}
	}}\\[7ex]
		
		(\mathit{Check}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{check}(\mathtt{t})} \theta',e'}{\Gamma;\tuple{p,\h,(\theta,e),q} 
				\comp \Pi;\mathcolorbox{yellow}{\M;\s} \rh \Gamma;\tuple{p,\mathsf{check}(\theta,e,\mathtt{t})\cons\h,(\theta',e'),q} 
				\comp \Pi;\mathcolorbox{yellow}{\M;\s} }
		}\\[4ex]
		
		(\mathit{Send}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{send}(p'',v)}
				\theta',e'~~~\k~\mbox{is a fresh identifier} ~\mathcolorbox{yellow}{\mathsf{isAtom}(p'')=false ~~ }}
			{
				\begin{split}
					\Gamma;\tuple{p,\h,(\theta,e),q} 
					\comp \Pi;\mathcolorbox{yellow}{\M;\s} \rh
					\Gamma\cup (p'',\{v,\k\});\tuple{p,\mathsf{send}(\theta,e,p'',\{v,\k\})\cons
						\h,(\theta',e'),q}\comp \Pi;
					\mathcolorbox{yellow}{\M;\s}
				\end{split}
			}
		}\\[8ex]
		
		\mathcolorbox{yellow}{(\mathit{SendA}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{send}(a,v)}
					\theta',e'~~~\k~\mbox{is a fresh identifier} ~\mathcolorbox{yellow}{\mathsf{isAtom}(a)=true ~~ \mathsf{matchPid}(\M, a) = p''}}
				{
					\begin{split}
						\Gamma;\tuple{p,\h,(\theta,e),q} 
						\comp \Pi;\M;\s \rh
						\Gamma\cup (p'',\{v,\k\});\tuple{p,\mathsf{sendA}(\theta,e,p'',\{v,\k\},a,p)\cons
							\h,(\theta',e'),q}\comp \Pi;\\
						\M;\mathsf{sendA}(\theta,e,p'',\{v,\k\},a,p)\cons\s
					\end{split}
				}
		}}\\[8ex]
		
		\mathcolorbox{yellow}{(\mathit{SendF}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{send}(a,v)}
					\theta',e'~~~\mathcolorbox{yellow}{\mathsf{isAtom}(a)=true ~~ \mathsf{matchPid}(\M, a) = false}}
				{\begin{split}
						\Gamma;\tuple{p,\h,(\theta,e),q} 
						\comp \Pi;\M;\s \rh
						\Gamma;\tuple{p,\mathsf{sendF}(\theta,e,a,p)\cons
							\h,(\theta,sendFail),q}\comp \Pi;\\
						\M;\mathsf{sendF}(\theta,e,a,p)\cons\s
					\end{split}
			}}
		}\\[8ex]
		
		(\mathit{Receive}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{rec}(\kappa,\ol{cl_n})}
				\theta',e'~~~ \mathsf{matchrec}(\theta,\ol{cl_n},q) = (\theta_i,e_i,\{v,\k\})}{\Gamma;\tuple{p,\h,(\theta,e),q}\comp \Pi;\mathcolorbox{yellow}{\M;\s} \rh
				\Gamma;\tuple{p,\mathsf{rec}(\theta,e,\{v,\k\},q)\cons\h,(\theta'\theta_i,e'\{\kappa\mapsto e_i\}),q\backslash\!\!\backslash\{v,\k\}}\comp \Pi;\mathcolorbox{yellow}{\M;\s}}
		}\\[4ex]
		
		(\mathit{Spawn}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{spawn}(\kappa,a/n,[\ol{v_n}])}
				\theta',e'~~~ p'~\mbox{is a fresh pid}}%%~~~\mbox{and $\mathtt{t}$ is fresh}}
			{\begin{array}{ll}
					\Gamma;\tuple{p,\h,(\theta,e),q} 
					\comp \Pi;\mathcolorbox{yellow}{\M;\s} \rh &
					\Gamma;\tuple{p,\mathsf{spawn}(\theta,e,p')\cons\h,(\theta',e'\{\kappa\mapsto
						p'\}),q} \\
					& \comp \tuple{p',\nil,(\id,\mathsf{apply}~a/n~(\ol{v_n})),\nil} 
					\comp \Pi;\mathcolorbox{yellow}{\M;\s}
			\end{array}}
		}\\[6ex]
		
		(\mathit{Self}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{self}(\kappa)} \theta',e'}
			{\Gamma;\tuple{p,\h,(\theta,e),q} \comp \Pi;\mathcolorbox{yellow}{\M;\s} 
				\rh 
				\Gamma;\tuple{p,\mathsf{self}(\theta,e)\cons\h,(\theta',e'\{\kappa\mapsto p\}),q} 
				\comp \Pi;\mathcolorbox{yellow}{\M;\s} }
		}\\[4ex]
		
		(\mathit{Sched}) ~ {\displaystyle
			\frac{~}
			{\Gamma\cup\{(p,\{v,\k\})\};\tuple{p,\h,(\theta,e),q}\comp\Pi;\mathcolorbox{yellow}{\M;\s} 
				\rh \Gamma;\tuple{p,\h,(\theta,e),\{v,\k\}\cons q}\comp\Pi;\mathcolorbox{yellow}{\M;\s}}
		}
	\end{array}
	\]
	\caption{Semantica reversibile forward} \label{fig:forwardsem}
\end{figure}

Le regole di transizioni della semantica forward si possono trovare nelle Figure~\ref{fig:forwardsem} e \ref{fig:forwardsem1}. Ai processi è stata aggiunta una \emph{storia} (o memoria) $\h$ che registra gli stati intermedi del processo e dei messaggi con l'identificatore (univoco) a loro associato. \\~\\
Nella storia per identificare le operazioni eseguite si utilizzano dei costruttori $\tau$, $\mathsf{check}$, $\mathsf{send}$,
$\mathsf{rec}$, $\mathsf{spawn}$, $\mathsf{self}$, $\tau\M\M'$, $\mathsf{sendA}$, $\mathsf{sendF}$, $\mathsf{regT}$, $\mathsf{regF}$, $\mathsf{unregT}$, $\mathsf{unregF}$, $\mathsf{fail}$ e $\mathsf{end}$  che identificano le regole applicate nella semantica forward. 
%Si nota che si potrebbero diminuire le informazioni salvate nella storia utilizzando una strategia simile a quella utilizzata in \cite{MHNHT07,NPV16,TA15} ma questo è un problema diverso da quello discusso nella tesi.
Nella regola $ \mathit {Receive} $ si può notare che la funzione ausiliare  $\mathsf{matchrec}$ prende in input un messaggio del tipo $\{v,\k\}$, che è l'estensione originale che ignora $\k$ quando elabora il match col primo messaggio.

\begin{figure}[htp]
	\footnotesize
	\[
	\begin{array}{c}
	
		\mathcolorbox{yellow}{(\mathit{RegisterT}) ~ {\displaystyle
				\frac{\theta,e\arro{\mathsf{register}(\mathsf{true},a,p')} \theta',e'~ \mathsf{matchMapReg}(\M, a,p') = true}
				{    
					\begin{split}
						\Gamma;\tuple{p,\h,(\theta,e),q}\comp \Pi;\M;\s 
						\rh \Gamma;\tuple{p,\mathsf{regT}(\theta,e,a,p',p)\cons\h,(\theta',e'),q}\comp \Pi;\\
						\M\cup(a,p'); \mathsf{regT}(\theta,e,a,p',p) \cons\s
					\end{split}
			}}
		}\\[7ex]
		
		\mathcolorbox{yellow}{(\mathit{RegisterF}) ~ {\displaystyle
				\frac{\theta,e\arro{\mathsf{register}(\mathsf{false},a,p')} \theta',e' ~ \mathsf{matchMapReg}(\M, a,p') = false}
				{\begin{split}
						\Gamma;\tuple{p,\h,(\theta,e),q}\comp \Pi;\M;\s 
						\rh \Gamma;\tuple{p,\mathsf{regF}(\theta,e,a,p',p)\cons\h,(\theta,regFail),q}\comp \Pi;\\
						\M; \mathsf{regF}(\theta,e,a,p',p) \cons\s 
			\end{split}}}
		}\\[7ex]
		
		\mathcolorbox{yellow}{(\mathit{UnregisterT}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{unregister}(\mathsf{true},a)}
					\theta',e' ~ \mathsf{matchMapUnreg}(\M, a,p) = p'} 
				{      \begin{split}
						\Gamma;\tuple{p,h,(\theta,e),q}\comp \Pi;\M;\s 
						\rh \Gamma;\tuple{p,\mathsf{unregT}(\theta,e,a,p',p)\cons\h, (\theta',e'),q}\comp \Pi; \\
						\M\backslash\!\!\backslash(a,p'); \mathsf{unregT}(\theta,e,a,p',p)\cons\s  
				\end{split}}
		}}\\[7ex]
		
		\mathcolorbox{yellow}{(\mathit{UnregisterF}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{unregister}(\mathsf{false},a)}
					\theta',e' ~ \mathsf{matchMapUnreg}(\M, a,p) = false} 
				{
					\begin{split}
						\Gamma;\tuple{p,h,(\theta,e),q}\comp \Pi; \M;\s 
						\rh \Gamma;\tuple{p,\mathsf{unregF}(\theta,e,a,p)\cons\h,(\theta,unregFail),q}\comp \Pi;\\
						\M;\mathsf{unregF}(\theta,e,a,p) \cons\s  
					\end{split}
				}
		}}\\[7ex]
		
		\mathcolorbox{yellow}{(\mathit{Catch}) ~ {\displaystyle
				\frac{ \theta,e \arro{\bot}  fail  }{\Gamma;\tuple{p,\h,(\theta,e),q}\comp \Pi; \M;\s \rh
					\Gamma;\tuple{p,\mathsf{fail}(\theta,e)\cons\h,(\theta,fail),q}\comp \Pi; \M;\s}
		}}\\[3ex]

		\mathcolorbox{yellow}{(\mathit{End}) ~ {\displaystyle
				\frac{\mathsf{matchEnd}(\M,p)=a'}{
						\Gamma;\tuple{p,\h,(\theta,\epsilon),q}\comp \Pi;\M;\s \rh
						\Gamma;\tuple{p,\mathsf{end}(\theta,\epsilon,a',p)\cons\h,(\theta,\epsilon),q}\comp \Pi,
						\M\backslash\!\!\backslash (a' ,p); \mathsf{end}(\theta,\epsilon,a',p)\cons\s
				}
		}}				
	\end{array}
	\]
	\caption{Semantica reversibile forward} \label{fig:forwardsem1}
\end{figure}
~\\
Per dimostrare che la semantica forward $\rh$ estende la semantica standard $\hoo$ bisogna introdurre $ \del(s) $.
 Si può vedere che $ \del(s) $ denoti il sistema risultante da $ s $ rimuovendo le cronologie dei processi; formalmente,
$\del(\Gamma;\Pi;\mathsf{M;S}) = \Gamma;\del'(\Pi);\mathsf{M}$, dove
\[
\begin{array}{lll}
	\del'(\tuple{p,\h,(\theta,e),q}) & = &
	\tuple{p,(\theta,e),q}
	\\
	\del'(\tuple{p,\h,(\theta,e),q}\:\comp\:\Pi) & = &
	\tuple{p,(\theta,e),q}\:\comp\:\del'(\Pi)
	\\
\end{array}
\]
si assume che $\Pi$ non sia vuoto. \\

\begin{theorem} \label{th:conservative}
	Sia $s_1$ un sistema nella semantica forward senza occorrenze di ``$\mathsf{check}$'' e $s'_1=\del(s_1)$ un sistema nella semantica standard. Allora, $s'_1 \hoo^\ast s'_2$ sse $s_1 \rh^\ast s_2$
	e $\del(s_2) = s'_2$.
\end{theorem}

\begin{proof}
	La dimostrazione avviene mostrando che le regole della semantica standard nelle Figure~\ref{fig:forwardsem} e \ref{fig:forwardsem1} sono la versione con la storia delle regole corrispondenti presenti nelle Figure~\ref{fig:system-rules} e \ref{fig:system-rules-map}. L'unico punto complicato è capire che l'introduzione dell'identificatore univoco nel messaggio non cambia il comportamento della regola $\mathit{Receive}$ poiché la funzione $\mathsf{matchrec}$ ha come risultato sempre l'occorrenza più vecchia (in termini di posizione nella coda) del messaggio selezionato \cite{Lanese}.
\end{proof}

In alcune delle regole di transizione della semantica backward, nelle side condition si richiederà che non siano presenti alcune delle regole di lettura o scrittura. 

 \begin{definition}[$\varepsilon$ e $\cancel{\varepsilon}$]\label{def:coinvolgimento}
	Per le operazioni sulla mappa diciamo che $x ~ \varepsilon ~op$ se l'operazione coinvolge l'elemento $x$ cioè se l'operazione aggiunge, rimuove o legge l'elemento $x$ dalla mappa. Si indica con $x~\cancel{\varepsilon}~op$ se l'operazione non coinvolge l'elemento $x$.
	Di seguito verrà mostrato l'elenco di come nella storia della mappa le regole vengono rappresentate e di quali sono gli elementi coinvolti.
\begin{itemize}
	\item se $op=\mathsf{regT}(\theta,e,a,p,p')$ allora $a ~\varepsilon~ \mathsf{regT}$, $p ~\varepsilon~ \mathsf{regT}$;% e $p'$ è il pid corrispondente al processo che esegue l'operazione
	\item se $op=\mathsf{unregT}(\theta,e,a,p,p')$ allora $a ~\varepsilon~ \mathsf{unregT}$, $p ~\varepsilon ~\mathsf{unregT}$;% e $p'$ è il pid corrispondente al processo che esegue l'operazione
	\item se $op=\mathsf{regF}(\theta,e,a,p,p')$ allora $a~ \varepsilon~ \mathsf{regF}$, $p~ \varepsilon~ \mathsf{regF}$;% e $p'$ è il pid corrispondente al processo che esegue l'operazione
	\item se $op=\mathsf{unregF}(\theta,e,a,p')$ allora  $a~ \varepsilon~ \mathsf{unregF}$;% e $p'$ è il pid corrispondente al processo che esegue l'operazione
	\item se $op=\mathsf{sendA}(\theta,e,p,\{v,\k\},a,p')$ allora $a ~\varepsilon~ \mathsf{sendA}$, $p~ \varepsilon~ \mathsf{sendA}$;% $p'$ è il pid corrispondente al processo che esegue l'operazione e la coppia $\{v,\k\}$ rappresenta il messaggio inviato
	\item se $op=\mathsf{sendF}(\theta,e,a,p')$ allora $a ~\varepsilon~ \mathsf{sendF}$; %e $p'$ è il pid corrispondente al processo che esegue l'operazione
	\item se $op=\mathsf{end}(\theta,e,p')$ allora $a~ \varepsilon~ \mathsf{end}$, $p' ~\varepsilon ~\mathsf{end}$;% e $p$ è il pid corrispondente al processo che esegue l'operazione, da notare che 
	\item se $op=\tau\mathsf{MM'}(\theta,e,p')$ allora $\forall~ p,a\in \mathsf{M'}; ~ p~\varepsilon ~ \tau\mathsf{MM'} \land a~\varepsilon ~ \tau\mathsf{MM'}$.\qed% e $p'$ è il pid corrispondente al processo che esegue l'operazione 
\end{itemize}
\end{definition}

\begin{definition}[Operazioni lettura e scrittura]\label{def:lettura-scrittura}
	
	Per la semantica standard si era detto che:
	\begin{itemize}
		\item per operazioni in scrittura si intendono le operazioni che modificano la mappa (cioè quelle regole che aggiungono o tolgono coppie alla mappa) e sono $\mathsf{RegisterT}$, $\mathsf{UnregisterT}$, $\mathsf{End}$.
		\item per operazioni in lettura si intendono le operazioni che  accedono alla mappa senza modificarla e sono $\mathsf{SendA}$, $\mathsf{SendF}$, $\mathsf{RegisterF}$, $\mathsf{UnregisterF}$, $\mathsf{Call3}$.
	\end{itemize}
	Questo vale anche per la semantica forward. 
	Per la semantica backward invece:
	\begin{itemize}
		\item le operazioni in scrittura sulla mappa sono $\ol{\mathsf{RegisterT}}$, $\ol{\mathsf{UnregisterT}}$ e $\ol{\mathsf{End}}$, da notare che anche queste operazioni vanno a modificare la mappa nel modo apposto alla regola forward corrispondente. 
		\item Mentre le operazioni in lettura sulla mappa nel caso della semantica backward sono $\ol{\mathsf{SendA}}$, $\ol{\mathsf{SendF}}$, $\ol{\mathsf{RegisterF}}$, $\ol{\mathsf{UnregisterF}}$ e $\ol{\mathsf{Call3}}$. 
		Le operazioni di backward in lettura vengono considerate come operazioni che leggono gli stessi elementi dell'operazione forward corrispondenti.\\\qed
	\end{itemize}
\end{definition}
Scegliere di dire che un'operazione all'indietro sia un'operazione in lettura è una scelta insolita ma è dovuta al fatto che si vuole evitare un ``annullamento'' di un'operazione di lettura sulla mappa quando la mappa è stata modificata.
\begin{example}
	Se si considera il caso in cui la storia ha una forma:
	\begin{center}
		$\mathsf{RegT}(a,p);\mathsf{Call3}(a);\mathsf{unregT}(a)$
	\end{center}
	se si potesse fare un'operazione di annullamento di call3 allora si otterrebbe
	\begin{center}
		$\mathsf{RegT}(a,p);\mathsf{Call3}(a);\mathsf{unregT}(a);\ol{\mathsf{Call3}(a)}$\\ la storia sarebbe quindi \\ $\mathsf{RegT}(a,p);\mathsf{unregT}(a)$
	\end{center}
	Però in questo modo si sarebbe annullata un'operazione di lettura sulla mappa dopo che la mappa è stata modificata e si potrebbe riapplicare l'operazione $\mathsf{Call3}(a)$ che fallirebbe (o darebbe un risultato diverso) ottenendo una storia 
	\begin{center}
		$\mathsf{RegT}(a,p);\mathsf{unregT}(a);\mathsf{Call3}(a)$
	\end{center}
	In questo modo non si potrebbe far vedere che facendo operazioni di \textit{undo-redo} si ritornerebbe in uno stato equivalente.
\end{example}

Nelle Figure \ref{fig:backwardsem} e \ref{fig:backwardsem1} sono presenti le regole di transizione della semantica backward.


\begin{figure}[ht]
	\footnotesize
	\[
	\begin{array}{lc}
		(\mathit{\ol{Seq}}) ~ {\displaystyle
			\Gamma;
			\tuple{p,\tau(\theta,e)\cons\h,(\theta',e'),q}
			\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
			\lh  \Gamma;\tuple{p,\h,(\theta,e),q}\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
		}\\[2ex]
		
				\mathcolorbox{yellow}{(\mathit{\ol{Call3}}) ~ {\displaystyle
				\begin{array}{l}
					\Gamma;
					\tuple{p,\tau\mathsf{MM'}(\theta,e,p)\cons\h,(\theta',e'),q}
					\:\comp\: \Pi;\mathsf{M;S' : \tau\mathsf{MM'}(\theta,e,p):S}
					\lh  \Gamma;\tuple{p,\h,(\theta,e),q}\:\comp\: \Pi;\mathsf{M;S'}\cons\mathsf{S}\\
					\mbox{Se in S' non sono presenti operazioni di scrittura su elementi presenti in M'}    
				\end{array}
		}}
		\\[3ex]
		
		(\mathit{\ol{Check}}) ~ {\displaystyle
			\Gamma;
			\tuple{p,\mathsf{check}(\theta,e,\mathtt{t})\cons\h,(\theta',e'),q}
			\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
			\lh  \Gamma;\tuple{p,\h,(\theta,e),q}\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
		} 
		\\[2ex]
		
		(\mathit{\ol{Send}}) ~ {\displaystyle
			\begin{array}{lc }
				\Gamma\cup\{(p'',\{v,\k\})\};\tuple{p,\mathsf{send}(\theta,e,p'',\{v,\k\})\cons\h,(\theta',e'),q}\:\comp\:
				\Pi;\mathcolorbox{yellow}{\mathsf{M;}\mathsf{S}}
				\lh \Gamma;\tuple{p,\h,(\theta,e),q} 
				\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}\\
				
			\end{array}
		}\\[2ex]
		
		\mathcolorbox{yellow}{(\mathit{\ol{SendA}}) ~ {\displaystyle
				\begin{array}{lc }
					\Gamma\cup\{(p'',\{v,\k\})\};\tuple{p,\mathsf{sendA}(\theta,e,p'',\{v,\k\},a,p)\cons\h,(\theta',e'),q}\:\comp\:
					\Pi;\mathsf{M;S'}\cons \mathsf{sendA}(\theta,e,p'',\{v,\k\},a,p)\cons\mathsf{S}\\
					\hspace{20ex}
					\lh \Gamma;\tuple{p,\h,(\theta,e),q} 
					\:\comp\: \Pi;\mathsf{M;S'}\cons\mathsf{S}\\
					Se ~ \forall ~ op ~ \mbox{in scrittura} \in \mathsf{S'} ~  a~\cancel{\varepsilon} ~op ~ \mathsf{o} ~ p''~\cancel{\varepsilon} ~op
				\end{array}
		}}\\[6ex]
		
		\mathcolorbox{yellow} {(\mathit{\ol{SendF}}) ~ {\displaystyle
				\begin{array}{lc }
					\Gamma;\tuple{p,\mathsf{sendF}(\theta,e,a,p)\cons\h,(\theta,sendFail),q}\:\comp\:
					\Pi;\mathsf{M;S'}\cons \mathsf{sendF}(\theta,e,a,p)\cons\mathsf{S}\\
					\hspace{20ex}
					\lh \Gamma;\tuple{p,\h,(\theta,e),q} 
					\:\comp\: \Pi;\mathsf{M;S'}\cons\mathsf{S}\\
					Se ~ \forall ~ op ~ \mbox{in scrittura} \in \mathsf{S'} ~  a~\cancel{\varepsilon} ~op
			\end{array}}
		}\\[6ex]
		
		(\mathit{\ol{Receive}}) ~ {\displaystyle
			\Gamma;\tuple{p,\mathsf{rec}(\theta,e,\{v,\k\},q)\cons\h,(\theta',e'), q\backslash\!\!\backslash\{v,\k\}}\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
			\lh  \Gamma;\tuple{p,\h,(\theta,e),q}\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
		}
		\\[2ex]
		
		(\mathit{\ol{Spawn}}) ~ {\displaystyle
			\begin{array}{l}
				\Gamma;\tuple{p,\mathsf{spawn}(\theta,e,p')\cons\h,(\theta',e'),q}
				\:\comp\: 
				\tuple{p',\nil,(\id,e''),\nil}
				\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}} 
				\\
				\hspace{20ex}\lh
				\Gamma;\tuple{p,\h,(\theta,e),q}
				\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}} 
			\end{array}
		}\\[5ex]
		
		(\mathit{\ol{Self}}) ~ {\displaystyle
			\Gamma;\tuple{p,\mathsf{self}(\theta,e)\cons\h,(\theta',e'),q} 
			\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}} \lh
			\Gamma;\tuple{p,\h,(\theta,e),q} 
			\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}  
		}\\[2ex]
		
		(\mathit{\ol{Sched}}) ~ {\displaystyle
			\begin{array}{l}
				\Gamma;\tuple{p,\h,(\theta,e),\{v,\k\}\cons q} \: \comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}} \lh 
				\Gamma\cup(p,\{v,\k\});\tuple{p,\h,(\theta,e),q}\:\comp\:\Pi;\mathcolorbox{yellow}{\mathsf{M;S}}\\
				\hspace{20ex}\mbox{if the topmost $\mathsf{rec}(\ldots)$ item in
					$\h$ (if any) has the}\\ 
				\hspace{20ex}\mbox{form}~\mathsf{rec}(\theta',e',\{v',\k'\},q')~\mbox{with}~q'\backslash\!\!\backslash\{v',\k'\}\neq \{v,\k\}\cons q
			\end{array}
		} \\[5ex]
		
	\end{array}
	\]
	\caption{Backward reversible semantics } \label{fig:backwardsem}
\end{figure}
Ora verranno discusse brevementealcune situazioni particolari:
\begin{itemize}
	\item Innanzitutto, si osserva che la regola $\ol{\mathit{Send}}$ può essere applicata solo quando il messaggio inviato si trova nella casella di posta globale. Se questo non è il caso (cioè, il messaggio è stato consegnato usando la regola $\mathit{Sched}$), allora dovremo prima applicare i passaggi a ritroso al processo del destinatario fino alla fine; l'applicazione della regola $\ol{\mathit{Sched}}$ rimette il messaggio nella casella di posta globale e la regola $\ol{\mathit{Send}}$ diventa applicabile. Ciò è necessario per garantire la coerenza causale. Nella sezione successiva, introdurremo una strategia particolare che ottiene questo effetto in modo controllato \cite{Lanese}.
\end{itemize}
\begin{itemize}
	\item Si può notare che la regola $\ol{\mathit{SendA}}$ (come la regola $\ol{\mathit{Send}}$) può essere applicata solo quando il messaggio inviato si trova nella casella di posta globale (cioè, il messaggio non è stato ancora consegnato usando la regola $\mathit{Sched}$). Inoltre essendo un'operazione sulla mappa in lettura si richiede che non siano presenti operazioni in scrittura sulla mappa eseguite successivamente che coinvolgono l'atomo $a$ o il pid $p$, questo è necessario per rispettare la coerenza causale.
\end{itemize}
\begin{itemize}
	\item La regola $\ol{\mathit{SendF}}$ è anch'essa in lettura sulla mappa quindi per rispettare la consistenza causale verrà richiesto che non ci siano operazioni in scrittura sulla mappa eseguite successivamente che coinvolgono l'atomo $a$.
\end{itemize}
\begin{itemize}
	\item La regola $\ol{\mathit{Call3}}$ come $\ol{\mathit{SendA}}$ e $\ol{\mathit{SendF}}$ è una regola in lettura sulla mappa, però come side-condidtion richiede  che non ci siano operazioni in scrittura sulla mappa eseguite successivamente che coinvolgono atomi o pid presenti $\M'$.
\end{itemize}
	\begin{itemize}
	\item Una situazione simile si verifica con la regola $\ol{\mathit{Spawn}}$. Dato un processo $ p $ con un elemento della cronologia $\mathsf{spawn}(\theta,e,p')$, la regola $ \ol{\mathit{Spawn}}$ non può essere applicata finché la cronologia e la coda del processo $ p '$ sono entrambi vuoti. Pertanto, si dovrebbe prima applicare una serie di passaggi all'indietro per elaborare $ p '$ in modo da poter annullare l'elemento $\mathsf{spawn}$.
	%
	Notiamo che non è necessario richiedere che nessun messaggio indirizzato al processo $ p '$ (che diventerebbe un messaggio \emph{orfano}) è nella casella di posta globale: per inviare un tale messaggio il pid $ p' $ è necessario, quindi l'invio del messaggio dipende da $\mathsf {spawn}$ e, quindi, deve essere annullato in anticipo \cite{Lanese}.
\end{itemize}
\begin{itemize}
	\item Osserva anche che la regola $\ol{\mathit{Receive}}$ può essere applicata solo quando la coda del processo è esattamente la stessa che è stata ottenuta dopo aver applicato il corrispondente passaggio $\mathit{Receive}$. Ciò è necessario per garantire che la coda ripristinata sia effettivamente quella giusta (notare che l'aggiunta del messaggio a una coda arbitraria non funzionerebbe poiché non conosciamo la posizione ``giusta'' per il messaggio) \cite{Lanese}.
\end{itemize}
\begin{itemize}
	\item L'applicazione della regola $\ol{\mathit{Sched}}$ può essere cambiata con l'applicazione di qualsiasi altra regola all'indietro eccetto $\ol{\mathit{Receive}}$ o un altro $\ol{\mathit{Sched}}$, poiché non interferisce con le regole rimanenti. Il fatto che due $ \ol{\mathit{Sched}}$ (che coinvolgono lo stesso processo) non si spostino è garantito poiché $\ol{\mathit{Sched}}$ si applica sempre al messaggio più recente di una coda. Il fatto che $\ol{\mathit{Sched}}$ e $\ol{\mathit{Receive}}$ non si spostino è garantito poiché la condizione secondaria di $\ol{\mathit{Sched}}$ controlla che non ci sia nessun elemento $\mathsf{rec}(\ldots)$ nella cronologia del processo che può essere utilizzato per applicare la regola $\ol{Receive}$ con la coda corrente. Pertanto, le loro condizioni di applicabilità non si sovrappongono \cite{Lanese}.
\end{itemize}

\begin{figure}[ht]
	\footnotesize
	\[
	\begin{array}{lc}
		
		\mathcolorbox{yellow}{ (\mathit{\ol{RegisterT}}) ~ {\displaystyle
				\begin{array}{l}	
					\Gamma;\tuple{p,\mathsf{regT}(\theta,e,a,p',p)\cons\h,(\theta',e'),q}\comp \Pi;\mathsf{M}\cup(a,p') ; \mathsf{S'}\cons\mathsf{regT}(\theta,e,a,p',p) \cons\mathsf{S} \\
					\hspace{20ex} \lh  \Gamma;\tuple{p,\h,(\theta,e),q}\:\comp\: \Pi;\mathsf{M;S'}\cons\mathsf{S}\\
					Se ~ \forall ~ op ~ \mbox{in scrittura o lettura} \in \mathsf{S'} ~  a \cancel{\varepsilon} op ~ \mathsf{o} ~ p'~\cancel{\varepsilon}~op    
					\end{array}		
		}}
		\\[6ex]
		
		\mathcolorbox{yellow}{ (\mathit{\ol{RegisterF}}) ~ {\displaystyle
				\begin{array}{l}
					\Gamma;\tuple{p,\mathsf{regF}(\theta,e,a,p',p)\cons\h,(\theta,regFail),q}\comp \Pi;
					\mathsf{M,} \mathsf{S'}\cons\mathsf{regF}(\theta,e,a,p',p) \cons\mathsf{S} \\    
					\hspace{20ex} \lh  \Gamma;\tuple{p,\h,(\theta,e),q}\:\comp\: \Pi;\mathsf{M;S'}\cons\mathsf{S}\\
					Se ~ \forall ~ op ~ \mbox{in scrittura} \in \mathsf{S'} ~  a~\cancel{\varepsilon} ~op ~ \mathsf{o} ~ p'~\cancel{\varepsilon}~op  
				\end{array}
		}}
		\\[6ex]
		
	\mathcolorbox{yellow}{ (\mathit{\ol{UnregisterT}}) ~ {\displaystyle
				\begin{array}{l}
					\Gamma;\tuple{p,\mathsf{unregT}(\theta,e,a,p',p)\cons\h,(\theta',e'),q}\comp \Pi; \mathsf{M}\backslash\!\!\backslash(a,p') ;
					\mathsf{S'}\cons\mathsf{unregT}(\theta,e,a,p',p)\cons\mathsf{S} \\
					\hspace{20ex}
					\lh  \Gamma;\tuple{p,\h,(\theta,e),q}\:\comp\: \Pi;\mathsf{M;S'}\cons\mathsf{S}\\
					Se ~ \forall ~ op ~ \mbox{in scrittura o lettura} \in \mathsf{S'} ~  a~\cancel{\varepsilon}~op ~ \mathsf{o} ~ p'~\cancel{\varepsilon}~op
				\end{array}
		}}
		\\[6ex]
		
		\mathcolorbox{yellow}{ (\mathit{\ol{UnregisterF}}) ~ {\displaystyle
				\begin{array}{l}	
					\Gamma;\tuple{p,\mathsf{unregF}(\theta,e,a,p)\cons\h,(\theta,unregFail),q}\comp \Pi; \mathsf{M;} 
					\mathsf{S'}\cons\mathsf{unregF}(\theta,e,a,p) \cons\mathsf{S}  \\
					\hspace{20ex}  \lh  \Gamma;\tuple{p,\h,(\theta,e),q}\:\comp\: \Pi;\mathsf{M;S'}\cons\mathsf{S}\\
					Se ~ \forall ~ op ~ \mbox{in scrittura} \in \mathsf{S'} ~  a~\cancel{\varepsilon}~op                  	
				\end{array}
				
		}}
		\\[5ex]
		
		\mathcolorbox{yellow}{ (\mathit{\ol{Catch}}) ~ {\displaystyle
				\begin{array}{l}
					\Gamma;\tuple{p,\mathsf{fail}(\theta,e)\cons\h,(\theta,fail),q}\comp \Pi; \mathsf{M};\mathsf{S}
					\lh
					\Gamma;\tuple{p,\h,(\theta,e),q}\comp \Pi; \mathsf{M};\mathsf{S}
				\end{array}	
		}}\\[3ex]
	
		\mathcolorbox{yellow}{ (\mathit{\ol{End}}) ~ {\displaystyle
			\begin{array}{l}
				\Gamma;\tuple{p,\mathsf{end}(\theta,\epsilon,a',p)\cons\h,(\theta,\epsilon),q}\comp \Pi,
				\mathsf{M}\backslash\!\!\backslash (a' ,p), \mathsf{S}\cons\mathsf{end}(\theta,\epsilon,a',p)\cons\mathsf{S}
				\lh  \Gamma;\tuple{p,\h,(\theta,\epsilon),q}\:\comp\: \Pi;\mathsf{M;S'}\cons\mathsf{S}\\
				Se ~ \forall ~ op ~ \mbox{in scrittura o lettura} \in \mathsf{S'} ~  a'~\cancel{\varepsilon}~op ~ \mathsf{o} ~ p~\cancel{\varepsilon}~op                  
			\end{array}		
	}}
	\end{array}
	\]
	\caption{Backward reversible semantics } \label{fig:backwardsem1}
\end{figure}

\begin{itemize}
	\item Le regole $\ol{\mathit{RegisterT}}$, $\ol{\mathit{RegisterF}}$, $\ol{\mathit{UnregisterT}}$ e $\ol{\mathit{End}}$ sono tutte regole in scrittura sulla mappa che annullano la corrispondente regola forward restituendo il controllo al processo (come tutte le altre regole). Essendo regole in scrittura sulla mappa richiederanno prima di poter essere eseguite l'annullamento di tutte le regole che coinvolgono atomi o pid  coinvolti dalla regola che si vuole annullare.
\end{itemize}
\begin{itemize}
	\item Anche $\ol{\mathit{UnregisterF}}$ è una regola in scrittura ma al contrario delle altre non coinvolge solo un atomo (e non un pid) e quindi da questa regola la side-condidtion richiederà solo che non siano presenti nella storia della mappa operazioni più recenti che coinvolgano l'atomo coinvolto dalla regola.
\end{itemize}
%\begin{itemize}
%	\item $\ol{\mathit{Catch}}$
%\end{itemize}


\section{Semantica rollback}\label{sect:semrollback}

In questa sezione introdurremo un operatore di rollback che avvia un calcolo reversibile per un processo.

\clearpage{\pagestyle{empty}\cleardoublepage}
\chapter{Conclusione}


\clearpage{\pagestyle{empty}\cleardoublepage}
\begin{thebibliography}{}
		
	\bibitem{CoreErlang}
	Richard Carlsson.
	\newblock An introduction to core {E}rlang.
	\newblock In {\em In Proceedings of the PLI'01 Erlang Workshop}, 2001.
	
	\bibitem{Lanese}
	Ivan Lanese, Naoki Nishida, Adri{\'{a}}n Palacios, and Germ{\'{a}}n Vidal.
	\newblock A theory of reversibility for {E}rlang.
	\newblock {\em Journal of Logical and Algebraic Methods in Programming},
	100:71--97, November 2018.
	
	\bibitem{Landauer}
	R.~Landauer.
	\newblock Irreversibility and heat generation in the computing process.
	\newblock {\em {IBM} Journal of Research and Development}, 5(3):183--191, July
	1961.
	
	\bibitem{Bennett}
	C.~H. Bennett.
	\newblock Logical reversibility of computation.
	\newblock {\em {IBM} Journal of Research and Development}, 17(6):525--532,
	November 1973.
	
	\bibitem{Danos}
	Vincent Danos and Jean Krivine.
	\newblock Reversible communicating systems.
	\newblock In {\em {CONCUR} 2004 - Concurrency Theory}, pages 292--307. Springer
	Berlin Heidelberg, 2004.
	
	\bibitem{CMRT13tr}
	R.~Caballero, E.~Mart{\'{\i}}n-Mart{\'{\i}}n, A.~Riesco, and S.~Tamarit.
	\newblock A declarative debugger for concurrent erlang programs (extended
	version).
	\newblock Technical Report SIC-15/13, Dpto.\ Sistemas Inform\'aticos y
	Computaci\'on, Universidad Complutense de Madrid, 2013.
	
	\bibitem{Engblom}
	Engblom, J. (2012, September). 
	\newblock A review of reverse debugging.
	\newblock In System, Software, SoC and Silicon Debug Conference (S4D), 2012 (pp. 1-6). IEEE.
	
	\bibitem{NPV16b}
	N.~Nishida, A.~Palacios, and G.~Vidal.
	\newblock A reversible semantics for {E}rlang.
	\newblock In M.~Hermenegildo and P.~L\'opez-Garc\'{\i}a, editors, {\em Proc.\
		of the 26th International Symposium on Logic-Based Program Synthesis and
		Transformation, LOPSTR 2016}, volume 10184 of {\em LNCS}, pages 259--274.
	Springer, 2017.
	\newblock Preliminary version available from
	\texttt{https://arxiv.org/abs/1608.05521}.

\end{thebibliography}
\end{document}
