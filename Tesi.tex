\documentclass[12pt,a4paper,openright,twoside]{report}
\usepackage[italian]{babel}
\usepackage[latin1]{inputenc}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{amsthm}
\usepackage{xcolor}
\oddsidemargin=30pt \evensidemargin=20pt%impostano i margini

\usepackage[all]{xy}
\usepackage{pdfpages}
\usepackage{titlesec}
\usepackage{fancyhdr}
\pagestyle{fancy}

\usepackage{color}



\newcommand{\id}{id}
% Terms
\newcommand{\nil}{[\:]}
\newcommand{\ol}[1]{\overline{#1}}  % sequence of objects

% New symbols:
\newcommand{\cons}{\!:\!}


% Arrows
\newcommand{\h}{\mathit{h}}
\renewcommand{\k}{\lambda}
\newcommand{\init}{\mathsf{init}}
\newcommand{\final}{\mathsf{final}}
\newcommand{\rlh}{\rightleftharpoons}
\newcommand{\lh}{\leftharpoondown}
\newcommand{\rh}{\rightharpoonup}
\newcommand{\lhh}{\leftharpoondown\hspace{-1.8ex}\leftharpoondown}
\newcommand{\rlhh}{\rightleftharpoons\hspace{-1.8ex}\rightleftharpoons}
\newcommand{\M}{\mathsf{M}}
\newcommand{\Hi}{\mathsf{H}}
\newcommand{\s}{\mathsf{S}}


\newcommand{\remark}[1]{\mbox{}\\\fbox{\begin{minipage}{.95\linewidth}
			Remark: \textsf{#1} \end{minipage}}\\}

\def \tuple#1{\langle #1 \rangle}


\usepackage{xcolor}
\newcommand{\mathcolorbox}[2]{\colorbox{#1}{$\displaystyle #2$}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand{\chaptermark}[1]{%
	\markboth{ #1}{}}

\renewcommand{\sectionmark}[1]{
	\markright{\thesection\ #1}}

\newcommand{\too}{\longrightarrow}
\newcommand{\arro}[1]{\xrightarrow{#1}} 
\newcommand{\hoo}{\hookrightarrow} 
\newcommand{\del}{\mathsf{del}}
\newcommand{\rolldel}{\mathsf{rolldel}} 
\newcommand{\comp}{\:|\:} 


\usepackage{thmtools}

\newtheorem{theorem}{Teorema}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollario}
\newtheorem{example}[theorem]{Esempio}


\newtheoremstyle{theoremdd}
  {\topsep}% measure of space to leave above the theorem. E.g.: 3pt
{\topsep}% measure of space to leave below the theorem. E.g.: 3pt
{}% name of font to use in the body of the theorem
{0pt}% measure of space to indent
{\bfseries}% name of head font
{. }% punctuation between head and body
{ }% space after theorem head; " " = normal interword space
{\thmname{#1}\thmnumber{ #2}\thmnote{ (#3)}}
\theoremstyle{theoremdd}
\newtheorem{definition}[theorem]{Definizione}

\renewcommand{\ttdefault}{cmtt}
\usepackage{url}
\usepackage{tikz}
\usepackage{diagbox}
\usepackage{multirow}



%\usepackage{ebproof}
% \usepackage{tikz} % Useless, but might be handy to draw fancier lines.
\usepackage{amssymb} % To provide the \varnothing symbol
\newcommand{\nothing}{\varnothing} % different from \emptyset
\usepackage{cancel}


\usepackage{tikz}

\newcommand{\reflect}[1]{\tikz[baseline=(h.base)]\node[xscale=-1](h){#1}; }
\usepackage{centernot}
\usepackage{stmaryrd}
\usepackage{ebproof}
% \usepackage{tikz} % Useless, but might be handy to draw fancier lines.
\usepackage{amssymb} % To provide the \varnothing symbol




\begin{document}

\tableofcontents
\thispagestyle{empty}                   %elimina il numero della pagina
\clearpage{\pagestyle{empty}\cleardoublepage}
\chapter{Introduzione}
Erlang è un linguaggio di programmazione funzionale e concorrente basato sul paradigma ad attori (concorrenza basata sul \textit{message-passing}). \\
BEAM è la macchina virtuale al centro di Erlang, fa parte dell'Erlang Run-Time System (ERTS), che compila il codice sorgente di Erlang in bytecode, che viene quindi eseguito su BEAM.
Core~Erlang \cite{CoreErlang} è uno dei linguaggi intermedi in cui Erlang viene compilato.
\\
In questa tesi si mostra un'estensione della semantica descritta nell'articolo ``A theory of reversibility for Erlang'' \cite{Lanese} con delle feature imperative. In questo articolo viene presentata una semantica reversibile per un sotto insieme di Core~Erlang.
\\
Nella Sezione \ref{sect:linguaggio} viene modificato il linguaggio presentato nell'articolo~\cite{Lanese} aggiungendo le operazione di registrazione di atomi e pid, di deregistrazione di pid e di lookup e un meccanismo per poter identificare quando un processo è arrivato in uno stato finale. 
\\
Nella Sezione \ref{sect:semantica} viene modificata la nozione di sistema data nell'articolo~\cite{Lanese} introducendo una mappa formata dalle coppie di atomi-pid che sono stati registrati. Rispetto all'articolo \cite{Lanese} sono state estese le regole per: la semantica del linguaggio, la valutazione delle nuove espressioni e per descrivere il fallimento di un'espressione. Inoltre, sono state aggiunte le regole di sistema per le nuove espressioni e per i casi di fallimento.
\\
Nella Sezione \ref{sect:semreversibile} viene descritta la semantica reversibile divisa in \textit{forward} e \textit{backward}. La prima è un'estensione delle regole introdotte precedentemente, a cui nell'articolo \cite{Lanese} viene aggiunta una storia dei processi;  in questo lavoro è stata aggiunta la storia della mappa. La semantica \textit{backward} invece descrive come viene fatto un passo all'indietro. In questo caso viene introdotta una nozione di operazione in lettura e scrittura per generalizzare le \textit{side-condition} delle regole inserite e per dare una nozione di operazione concorrente più generale. 
\\
Nella Sezione \ref{sect:semrollback} è stato esteso l'operatore di reversibilità che può essere utilizzato per annullare le azioni di un dato processo fino a raggiungere un determinato punto di controllo, introdotto dal programmatore. Per garantire la coerenza causale l'azione di rollback potrebbe essere propagata ad altri processi dipendenti. 

\section{Reversibilità}
Normalmente la computazione avviene in una direzione con le istruzioni che vengono eseguite in un determinato ordine; per computazione reversibile invece ci si riferisce alla possibilità di eseguire un programma sia in avanti (o anche computazione \textit{forward}) che indietro (o anche computazione \textit{backward}).\\
Dato un programma non è ovvio che sia possibile eseguire una computazione backward, in quanto tutti i linguaggi di programmazione tradizionali consentono operazioni con perdita di informazione. \\
Durante l'esecuzione di un programma, a meno che non sia reversibile o senza perdita di informazioni, i dati intermedi vengono persi mentre viene calcolato l'output finale.
\begin{example}
	L'assegnamento \texttt{$\mathtt{x}$ = 96}  elimina il vecchio valore di $\mathtt{x}$ che deve essere memorizzato se si vuole annullare questa assegnazione.
\end{example}
~\\
Landauer \cite{Landauer} notò anche che ogni computazione irreversibile può essere trasformata in una computazione reversibile includendola in una computazione più ampia nella quale nessuna informazione viene persa, salvando ogni volta gli stati intermedi così da non avere perdita di informazione.\\
L'idea alla base di questo lavoro \cite{Landauer}, chiamato incorporamento di Landauer, è che qualsiasi linguaggio di programmazione o formalismo può essere reso reversibile aggiungendo la cronologia del calcolo a ogni stato.
\\
Questa idea fu ulteriormente migliorata da Bennett \cite{Bennett} allo scopo di evitare la generazione di dati ``spazzatura'', applicando una serie di analisi al fine di limitare il più possibile le informazioni richieste nella storia.
\\
La reversibilità in un contesto sequenziale è facilmente ottenibile annullando ricorsivamente l'ultima azione eseguita dal programma. La definizione di reversibilità in un contesto in cui vengono considerati anche i sistemi concorrenti è più complicata, poiché non esiste il concetto di ``ultima azione'', essendo molte azioni eseguite contemporaneamente.
\\
Una definizione adeguata di reversibilità in uno scenario concorrente è stata proposta da Danos e Krivine nel loro articolo \cite{Danos}. Intuitivamente, questa afferma che qualsiasi azione può essere annullata a condizione che tutte le sue eventuali conseguenze siano annullate preventivamente.
\\
Il calcolo reversibile potrebbe essere applicato per migliorare il modo in cui alcune attività vengono svolte, per esempio nel debug.

\section{Debugger reversibile}

I Debugger non sono altro che programmi che consentono di analizzare se un programma è sintatticamente corretto, in modo da effettuare una ricerca del bug in modo più veloce e accurato possibile. 
\\
Generalmente il tipo più utilizzato di debugger è quello che consente a runtime la ricerca dei bug tramite funzionalità standard come \textit{breakpoint}, \textit{controlpoint} e \textit{viste da watch}, che consentono al programmatore di analizzare più accuratamente determinate parti di codice per identificare gli errori con una scansione in avanti del programma.
\\
Di contro però, la maggior parte dei debugger fornisce un'assistenza limitata, per cui i programmatori devono spesso ricorrere alla simulazione dell'esecuzione del programma mentalmente per cercare di immaginare i flussi di istruzioni che vengono eseguiti. Infatti, con un debugger a \textit{runtime}, il programmatore può cercare il bug inserendo dei breakpoint all'interno dei thread e sperare di scovare il bug facendo dei tentativi, magari entrando in watch per osservare come vengono modificate le variabili durante l'esecuzione del programma. Per far fronte a questo problema sono nati anche debugger più complessi, definiti reversibili, che risultano più utili in scenari concorrenti. Questi, a differenza dei debugger tradizionali, consentono agli sviluppatori di registrare le attività del programma in esecuzione per poi riavvolgere e riprodurre tali istruzioni, compresi eventuali errori, per ispezionare lo stato del programma \cite{Engblom}.\\
Riavvolgere le azioni di un particolare processo significa anche elimare ogni conseguenza dell'operazione, cioè  tutte le azioni ``collegate'' a quell'operazione, che si vuole annullare. Questa nozione è chiamata \textit{consistenza causale}~\cite{Danos}.

\section{Background}

In questa tesi, viene utilizzato ``A theory of reversibility for Erlang'' \cite{Lanese} come articolo di riferimento.
In esso viene utilizzato come linguaggio un sottoinsieme di \emph{Core~Erlang}~\cite{CoreErlang}. \\
Inizialmente, al contrario di quelle utilizzate in altri lavori \cite{CMRT13tr}, gli autori hanno introdotto una semantica modulare per il linguaggio, ciò permette di semplificare l'aggiornamento di quest'ultima ad una semantica reversibile.\\
Sucessivamente, utilizzando l'incorporamento di Landauer, gli autori hanno definito una semantica reversibile per il linguaggio scelto che può andare avanti e indietro in modo non deterministico, chiamata semantica reversibile \emph{non controllata}, per la quale hanno dimostrato che essa gode delle proprietà usuali (loop lemma, square lemma e consistenza causale). \\
Infine, hanno introdotto una versione controllata della semantica a ritroso grazie all'utilizzo dell'operatore di rollback che annulla le azioni di un processo fino a un determinato punto di controllo; per garantire la coerenza causale, l'azione di rollback potrebbe essere propagata ad altri processi dipendenti. \\
La semantica descritta nell'articolo è stata implementata dagli autori in un interprete, che è anche un debugger reversibile, chiamato CauDEr, che mostra che l'approccio utilizzato è effettivamente attuabile nella pratica. CauDEr verrà descritto più approfonditamente nella sezione successiva~\ref{Cauder}.

\section{CauDEr}\label{Cauder}

Un debugger casual-consistent è uno strumento che consente di eseguire il debug di un programma concorrente, garantendo la coerenza causale anche a fronte di operazioni di undo di certe azioni svolte dai processi. 
Non è semplice individuare un comportamento erroneo in un sistema concorrente, quindi è utile disporre di strumenti che possono aiutare lo sviluppatore. In~\cite{paperCauder} viene introdotto CauDEr, ovvero sia un debugger casual-consistent per un sottoinsieme funzionale e concorrente del linguaggio Core~Erlang \cite{CoreErlang}.\\
Il programma funziona come segue: l'utente carica un file sorgente Erlang che viene tradotto in Core~Erlang. Successivamente egli specifica quale funzione è il punto di ingresso e, eventualmente, anche gli argomenti di input della funzione. Dopo aver premuto il pulsante di avvio il sistema verrà azionato e l'utente potrà eseguire il programma in modo automatico in avanti. Si potranno quindi specificare quanti passi avanti debbano essere eseguiti, o in alternativa si potrà selezionare un processo ed eseguire passi avanti su di esso. L'utente può anche selezionare un processo e se possibile potrà eseguire un calcolo a ritroso. 
Inoltre, l'utente ha l'opportunità di eseguire il rollback del processo nel momento in cui viene eseguita un'azione osservabile con la garanzia che è stata assicurata la coerenza causale.\\
Un debugger che permette all'utente di concentrarsi solo sul processo desiderato, ignorando quindi gli altri, riduce la quantità di informazioni che egli debba percepirare in un solo istante, riducendo così il carico cognitivo e consentendo al soggetto di doversi concentrare esclusivamente su ciò di cui ha più bisogno.\\ 
Contrariamente un debugger che tiene traccia dell'intero sistema e che dia la possibilità di far evolvere in avanti e/o all'indietro l'intero sistema, invece che i singoli processi, risulterebbe più problematico, infatti un tale strumento non consentirebbe di concentrarsi su un particolare processo ma costringerebbe l'utente a eseguire il rollback e riprodurre l'intero sistema, anche i processi che non sono legati a quello a cui siamo interessati.
 Un tale approccio sommergerebbe quindi l'utente di informazioni non utili, aumentando così la difficoltà e il tempo di trovare il bug che causa il comportamento scorretto nel programma.
 \\~\\
 Lo sviluppo di CauDEr è presente in due versioni \cite{cauder,cauderV2} che entrambe implementano la semantica reversibile descritta nell'articolo~\cite{Lanese}. Le principali differenze fra le due versioni sono che nella seconda versione~\cite{cauderV2} non è presente la mailbox locale dei processi ma solo quella globale. Di conseguenza non è presente nemmeno lo scheduler che sposta i messaggi dalla mailbox globale a quella locale del destinatario. Nella seconda versione è stata aggiunta anche la definizione dei tipi delle strutture dati utilizzate e della sintassi, in questo modo viene aggiunto alle definizione delle funzioni il tipo dell'input e dell' output. Inoltre il linguaggio non è più tradotto in Core~Erlang ma nella sintassi definita.\\
Infine un'altra differenza è che nella prima versione il codice visibile è il programma tradotto in Core~Erlang mentre nella seconda versione è il codice originale in Erlang.

\clearpage{\pagestyle{empty}\cleardoublepage}
\chapter{Estensione con feature imperative}

Si vuole estendere \cite{Lanese} con alcuni meccanismi imperativi presenti in Core~Erlang e ingorati in \cite{Lanese}: la possibilità di associare atomi a pid, tipicamente utilizzata per rendere pubblici i pid di server per servizi noti.
 \\
Nel seguito di questo capitolo, verrà presentata la sintassi del linguaggio esteso supportato, seguita dalla sua semantica (reversibile). In contrasto con la semantica descritta nell'articolo ``A theory of reversibility for Erlang'' \cite{Lanese} quella che verrà presentata qui includerà funzioni imperative.
Le modifiche effettuate all'articolo \cite{Lanese} sono evidenziate in giallo.

\section{Sintassi del linguaggio}\label{sect:linguaggio}
In questa sezione verrà mostrata la sintassi di un linguaggio funzionale, concorrente, distribuito e basato sul paradigma ad attori. Questo linguaggio è un sotto insieme di Core~Erlang \cite{CoreErlang}, che è uno dei linguaggi intermedi in cui un programma Erlang viene compilato.
\begin{figure}[ht]
	\begin{center}
		$
		\begin{array}{rcl@{~~~~~~}l}
			
			\mathit{module} & ::= & \mathsf{module} ~ Atom = %%[fname_1,\ldots,fname_n] =
			\mathit{fun}_1~\ldots~\mathit{fun}_n\\
			{\mathit{fun}} & ::= & \mathit{fname} = \mathsf{fun}~(\mathit{Var}_1,\ldots,\mathit{Var}_n) \to expr \\
			{\mathit{fname}} & ::= & Atom/\mathit{Integer} \\
			lit & ::= & Atom \mid \mathit{Integer} \mid \mathit{Float} \mid
			\mathit{Pid} \mid \nil \\
			expr & ::= & \mathit{Var}  \mid \mathit{fname} \mid [expr_1|expr_2]
			\mid   \{expr_1,\ldots,expr_n\} \\
			& \mid & \mathsf{call}~Op~(expr_1,\ldots,expr_n) 
			\mid \mathsf{apply}~\mathit{fname}~(expr_1,\ldots,expr_n) \\
			& \mid &
			\mathsf{case}~expr~\mathsf{of}~clause_1;\ldots;clause_m~\mathsf{end}\\
			& \mid & \mathsf{let}~\mathit{Var}=expr_1~\mathsf{in}~expr_2 
			\mid \mathsf{receive}~clause_1;\ldots;clause_n~\mathsf{end}\\
			& \mid & \mathsf{spawn}(\mathit{fname},[expr_1,\ldots,expr_n])  
			\mid expr \:!\: expr \mid \mathsf{self}()\\
			& \mid &   \mathcolorbox{yellow}{ \mathsf{register}(expr, expr)} \mid    \mathcolorbox{yellow}{ \mathsf{unregister}(expr)}  \mid \mathcolorbox{yellow}{end} \\
			clause & ::= & pat ~\mathsf{when}~expr_1 \to expr_2
			\\
			pat & ::= & \mathit{Var} \mid lit \mid [pat_1|pat_2] \mid
			\{pat_1,\ldots,pat_n\} \\
			Op & ::= & \dots \mid \mathcolorbox{yellow} { \mathsf{whereis}} \mid \mathcolorbox{yellow} {\mathsf{registered}}\\
			\mathcolorbox{yellow}{end} & ::= & lit \mid [end_1|end_2] \mid
			\{end_1,\ldots,end_n\} 
		\end{array}
		$
	\end{center}
	\caption{Regole di sintassi del linguaggio} \label{ErlangSyntax}
\end{figure}
\newline
\newline
Nella Figura~\ref{ErlangSyntax} viene presentata la sintassi del linguaggio. Si può notare che vengono considerate solo espressioni; di conseguenza il primo argomento delle applicazioni di funzioni e della spawn è un nome di funzione invece che un'espressione o chiusura arbitraria, e il primo argomento nelle chiamate è un'operazione built-in $Op$. Rispetto alla sintassi dell'articolo~\cite{Lanese} sono state aggiunte le funzioni built-in: 
\begin{itemize}
	\item $\mathsf{whereis}$ che dato in input un atomo restituisce il pid associato, oppure \textbf{undefined};
	\item $\mathsf{registered}$ che restituisce una lista di tutti gli atomi nella mappa; se non sono presenti atomi registrati restituisce una lista vuota;
\end{itemize}
sono anche state aggiunte le funzioni:
\begin{itemize}
	\item $\mathsf{register}$ che dati in input un atomo e un pid inserisce in una mappa la coppia (atomo,pid) e restituisce l'atomo \textbf{true}. Se l'atomo o il pid sono già presenti nella mappa il processo fallisce;
	\item $\mathsf{unregister}$ che dato in input un atomo toglie dalla mappa la coppia (atomo,pid) e restituisce l'atomo \textbf{true}. Se l'atomo non è presente nella mappa il processo fallisce.
\end{itemize}
Inoltre è stato creato il non terminale \textit{end} che indica gli stati finali di un processo, in modo da determinare se un processo è fallito. In questo modo si è riusciti ad avere un comportamento il più fedele possibile a quello di Erlang nel caso delle funzioni aggiunte. \\~\\
Nelle regole che verranno descritte successivamente il simbolo $\epsilon$ rappresenterà un non terminale \textit{end}. 

\section{Semantica del linguaggio}\label{sect:semantica}
In questa sezione descriveremo formalmente la semantica del linguaggio presentato nella sezione \ref{sect:linguaggio}.

\begin{definition} [Processo]
	Un processo è indicato da una tupla $\tuple {p, (\theta, e), q}$ dove $p$ è il pid del processo (ed è unico), $(\theta, e)$ è il controllo, che consiste di un ambiente (una sostituzione) e di un'espressione da valutare, e $q$ è la mailbox del processo, una coda FIFO con la sequenza di messaggi che sono stati inviati al processo.
	\\
	Si considera le seguenti operazioni sulle mailbox locali. Dato un messaggio $v$ e una mailbox locale $q$, $v:q$ denota una nuova mailbox con il messaggio $v$ sopra (cioè $v$ è il messaggio più recente). Con $q \backslash\! \! \backslash v$ verrà indicata una nuova coda che risulta da $q$ rimuovendo l'occorrenza più vecchia del messaggio $v$ (che non è necessariamente il messaggio più vecchio nella coda). \qed
\end{definition}
%
Un \emph{sistema} in esecuzione può quindi essere visto come un insieme di processi, che vengono definiti formalmente come segue:

\begin{definition} [Sistema] \label{sistema}
	Un sistema è indicato da $\Gamma;\Pi;\M$, dove $\Gamma$, la \emph{mailbox globale}, è un insieme di coppie nella forma $(destinazione,$ $messaggio)$ e $\Pi$ è un insieme di processi, indicato da un'espressione della forma
	\[
	\tuple{p_1, (\theta_1, e_1), q_1} ~ \comp \cdots
	\comp ~ \tuple {p_n, (\theta_n, e_n), q_n}
	\]
	dove `` $\comp$ '' denota un operatore associativo e commutativo.
	%
	Data una mailbox globale $\Gamma $, $\Gamma \cup \{(p, v) \} $ denota una nuova mailbox che include anche la coppia $(p, v)$; si usa ``$\cup$'' come unione multiset.
	Spesso un sistema viene denotato con un'espressione nella forma $\Gamma;\tuple{p,(\theta, e),q}\comp \Pi;\M$ per far notare che $ \tuple {p, (\theta, e), q} $ è un processo arbitrario del pool (grazie al fatto che `` $\comp $ '' è associativo e commutativo).
	Infine, $\M$ rappresenta l'insieme delle coppie $(atomo,pid)$ registrate; si indica con ``$\cup$'' l'aggiunta di una coppia alla mappa e con ``$\backslash\! \! \backslash$'' la rimozione di una coppia dalla mappa.\qed 
\end{definition}
~\\
Intuitivamente, $\Gamma$ memorizza i messaggi dopo che sono stati inviati e prima che vengano inseriti nella mailbox di destinazione, quindi rappresenta i messaggi che si trovano nella rete.
\newline
La semantica è definita tramite due relazione di transizione: $\too$ per le espressioni e $\hoo$ per il sistema. Verrà prima mostrata la relazione di transizione etichettata 
\[
\too\; : (Env,Exp)\times Label\times(Env,Exp)
\]
dove $Env$ e $Exp$ rappresentano rispettivamente l'ambiente (cioè le sostituzioni) e le espressioni, mentre $Label$ denota un elemento dell'insieme
\[
\begin{array}{l}
	\hspace{-11ex}
	\{\tau, \mathsf{send}(v_1,v_2),
	\mathsf{rec}(\kappa,\ol{cl_n}), \mathsf{spawn}(\kappa,a/n,[\ol{v_n}]),
	\mathsf{self}(\kappa),
	\mathcolorbox{yellow}{\mathsf{register}(\kappa,a,p)},
	\mathcolorbox{yellow}{\mathsf{unregister}(\kappa,a)},
	\mathcolorbox{yellow}{\tau \M\M'},
	\mathcolorbox{yellow}{\bot}
	\}
\end{array}
\]
Verrà utilizzato $\ell$ per indicare un'etichetta fra quelle appena indicate.\\ Per chiarezza le regole di transizione della semantica verranno divise in quattro gruppi: quelle per le espressioni sequenziali sono raffigurate nella Figura~\ref{fig:seq-rules}, quelle per i fallimenti delle espressioni sequenziali nella Figura~\ref{fig:seq-rules-fail}, quelle per le espressioni concorrenti nella Figura~\ref{fig:concurrent-rules} e infine quelle per i fallimenti delle espressioni concorrenti sono mostrate nella Figura~\ref{fig:concurrent-rules-fail}.

\begin{figure}[h]
	\footnotesize
	\[
	\begin{array}{c}
		(\mathit{Var}) ~ {\displaystyle \frac{}{\theta,X
				\arro{\tau} \theta,\theta(X)}} 
		
		\hspace{2ex}
		
		(\mathit{Tuple}) ~ {\displaystyle 
			\frac{\theta,e_i \arro{\ell}
				\theta',e'_i}{\theta,\{\ol{v_{1,{i-1}}},e_i,\ol{e_{{i+1},n}}\}
				\arro{\ell} \theta',
				\{\ol{v_{1,{i-1}}},e'_i,\ol{e_{{i+1},n}}\}}}\\[4ex] 
		
		(\mathit{List1})  ~{\displaystyle 
			\frac{\theta,e_1 \arro{\ell}
				\theta',e'_1}{\theta,[e_1|e_2]
				\arro{\ell} \theta',
				[e'_1|e_2]}} 
		
		\hspace{2ex}
		
		(\mathit{List2}) ~ {\displaystyle 
			\frac{\theta,e_2 \arro{\ell}
				\theta',e'_2}{\theta,[v_1|e_2]
				\arro{\ell} \theta',
				[v_1|e'_2]}} \\[4ex]
		
		(\mathit{Let1}) ~ {\displaystyle \frac{\theta,e_1
				\arro{\ell} \theta',e'_1 }{\theta,\mathsf{let}~ 
				X=e_1~\mathsf{in}~e_2
				\arro{\ell} \theta',\mathsf{let}~ 
				X=e'_1~\mathsf{in}~e_2}}
		
		\hspace{1ex}
		
		(\mathit{Let2}) ~ {\displaystyle \frac{}{\theta,\mathsf{let}~ 
				X=v~\mathsf{in}~e
				\arro{\tau} \theta[X\mapsto v],e}} \\[4ex]
		
		(\mathit{Case1}) ~ {\displaystyle
			\frac{\theta,e\arro{\ell}
				\theta',e'}{\begin{array}{l}
					\theta,\mathsf{case}~e~\mathsf{of}~cl_1;\ldots;cl_n~\mathsf{end}
					\arro{\ell}
					\theta',\mathsf{case}~e'~\mathsf{of}~cl_1;\ldots;cl_n~\mathsf{end}\\
		\end{array}}}\\[4ex]
		
		(\mathit{Case2}) ~ {\displaystyle
			\frac{\mathsf{match}(\theta,v,cl_1,\ldots,cl_n) = \tuple{\theta_i,e_i}}{\theta,\mathsf{case}~v~\mathsf{of}~cl_1;\ldots;cl_n~\mathsf{end}
				\arro{\tau} \theta\theta_i,e_i}} \\[4ex]
		
		(\mathit{Call1}) ~ {\displaystyle
			\frac{\theta,e_i\arro{\ell}
				\theta',e'_i~~~i\in\{1,\ldots,n\}}{\theta,\mathsf{call}~op~(\ol{v_{1,i-1}},e_i,\ol{e_{i+1,n}})
				\arro{\ell}
				\theta',\mathsf{call}~op~(\ol{v_{1,i-1}},e'_i,\ol{e_{i+1,n}})}} \\[5ex]
		
		(\mathit{Call2}) ~ {\displaystyle
			\frac{\mathsf{eval}(op,v_1,\ldots,v_n)=v}{\theta,\mathsf{call}~op~(v_1,\ldots,v_n)
				\arro{\tau} \theta,v}} \\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{Call3}) ~ {\displaystyle
				\frac{\mathsf{evalM}(\M,op,v_1,\ldots,v_n)= (v,\M') }{\theta,\mathsf{call}~op~(v_1,\ldots,v_n)
					\arro{\tau\M\M'} \theta,v}} }\\[4ex]
		
		(\mathit{Apply1}) ~ {\displaystyle
			\frac{\theta,e_i\arro{\ell}
				\theta',e'_i~~~i\in\{1,\ldots,n\}}{\theta,\mathsf{apply}~a/n~(\ol{v_{1,i-1}},e_i,\ol{e_{i+1,n}}) 
				\arro{\ell}
				\theta',\mathsf{apply}~a/n~(\ol{v_{1,i-1}},e'_i,\ol{e_{i+1,n}})}}\\[5ex] 
		
		(\mathit{Apply2}) ~ {\displaystyle
			\frac{\mu(a/n) = \mathsf{fun}~(X_1,\ldots,X_n)\to e}{\theta,\mathsf{apply}~a/n~(v_1,\ldots,v_n)
				\arro{\tau} \theta\cup\{X_1\mapsto v_1,\ldots,X_n\mapsto v_n\},e}} %\{\ol{X_n\mapsto v_n}\},e}} 
	\end{array}
	\]
	\caption{Semantica standard: valutazione espressioni sequenziali} \label{fig:seq-rules}
\end{figure}

Ogni transizione è contrassegnata da un etichetta che può essere: $ \tau$ che indica una riduzione sequenziale senza side-effects, $\tau\M\M'$ una riduzione che accede alla mappa senza side-effects, $\bot$ la propagazione di un fallimento, o un'etichetta che identifica la riduzione di un'azione con alcuni side-effects. Le etichette sono usate nelle regole di sistema (Figure~\ref {fig:system-rules}, \ref{fig:system-rules-map}) per determinare gli effetti collaterali associati e/o le informazioni da recuperare.
\newline
Nella Figura~\ref{fig:seq-rules} sono presenti le regole di transizione per la valutazione delle espressioni sequenziali.
\newline
Come in Erlang, si considera che l'ordine di valutazione degli argomenti in una tupla, lista, ecc. è fisso da sinistra a destra.
\newline
Per la valutazione dei case, si assume una funzione ausiliaria $\mathsf{match}$ che seleziona la prima clausola, $cl_i = (pat_i ~\mathsf{when} ~ e'_i \to e_i)$, in modo tale che $v$ corrisponda a $pat_i$, ovvero $ v = \theta_i (pat_i)$, e che la guardia sia soddisfatta, cioè, $\theta \theta_i, e'_i \too^\ast \theta ', true$. Come in Core~Erlang, si assume che i patterns possano solo contenere nuove variabili (ma le guardie potrebbero avere variabili legate, quindi verrà passato l'ambiente corrente $ \theta $ alla funzione $ \mathsf {match} $).
\newline
Le funzioni possono essere definite nel programma, in questo caso sono invocate da $\mathsf {apply}$, o essere un built-in, invocate da $\mathsf{call}$. In quest'ultimo caso vengono valutate utilizzando la funzione ausiliaria $\mathsf {eval}$.
\newline
Nella regola $\mathit {Apply2}$, si considera che la mappa $\mu$ memorizzi tutte le definizioni di funzione nel programma, cioè, mappi ogni nome di funzione $ a/n $ in una copia della sua definizione $\mathsf{fun} ~ (X_1, \ldots, X_n) \to e$, dove $ X_1, \ldots, X_n $ sono nuove variabili distinte e sono le uniche che possono essere libere in $e$.
\
Per estendere la semantica utilizzata a considerare anche funzioni di ordine superiore, si dovrebbe ridurre il nome della funzione a una \emph {chiusura} della forma $ (\theta ', \mathsf {fun} ~ (X_1, \ldots, X_n) \to e) $. 
\newline
Alle regole della semantica standard delle espressi sequenziali è stata aggiunta la regola $Call3$ utilizzata per la valutazione delle funzioni built-in che devono accedere alla mappa. Le funzioni built-in, come si può vedere dalla regola $Call2$, vengono valutate tramite la funzione ausiliaria $\mathsf{eval}$; per questo motivo si è scelto di utilizzare la funzione ausiliaria $\mathsf{evalM}$ per valutare le funzioni built-in che utilizzano una mappa. Infatti per la valutazione, $\mathsf{evalM}$ non prende in input solo i parametri ma anche la mappa, indicata con $\M$.
La funzione $\mathsf{evalM}$ e la funzione $\mathsf{eval}$ sono quindi due funzioni parziali visto che non è definito l'output per ogni input. $\mathsf{M'}$ corrisponde alla parte della mappa acceduta dalla funzione $\mathsf{evalM}$.
\newpage
\begin{figure}[h]
	\footnotesize
	\[
	\begin{array}{c}
		\mathcolorbox{yellow}{ (\mathit{TupleF}) ~ {\displaystyle 
				\frac{\theta,e_i \arro{\bot} fail
				}{\theta,\{\ol{v_{1,{i-1}}},e_i,\ol{e_{{i+1},n}}\}
					\arro{\bot} fail
		}}}\\[4ex] 
		
		\mathcolorbox{yellow}{(\mathit{List1F})  ~{\displaystyle 
				\frac{\theta,e_1 \arro{\bot} fail}
				{\theta,[e_1|e_2] \arro{\bot} fail}} 
			
			\hspace{2ex}
			
			(\mathit{List2F}) ~ {\displaystyle 
				\frac{\theta,e_2 \arro{\bot} fail }
				{\theta,[v_1|e_2]\arro{\bot} fail }} }\\[4ex]
		
		\mathcolorbox{yellow}{ (\mathit{Let1F}) ~ {\displaystyle \frac{\theta,e_1
					\arro{\bot} fail }{\theta,\mathsf{let}~ 
					X=e_1~\mathsf{in}~e_2
					\arro{\bot} fail}}} \\[4ex]
		
		\mathcolorbox{yellow}{ (\mathit{Case1F}) ~ {\displaystyle
				\frac{\theta,e\arro{\bot} fail
				}{\begin{array}{l}
						\theta,\mathsf{case}~e~\mathsf{of}~cl_1;\ldots;cl_n~\mathsf{end}
						\arro{\bot} fail
						
		\end{array}}}}\\[4ex]
		
		\mathcolorbox{yellow}{ (\mathit{Case2F}) ~ {\displaystyle
				\frac{\mathsf{match}(\theta,v,cl_1,\ldots,cl_n) = \emptyset }{\theta,\mathsf{case}~v~\mathsf{of}~cl_1;\ldots;cl_n~\mathsf{end}
					\arro{\bot} caseFail}}} \\[4ex]
		
		\mathcolorbox{yellow}{ (\mathit{Call1F}) ~ {\displaystyle
				\frac{\theta,e_i\arro{\bot} fail}
				{\theta,\mathsf{call}~op~(\ol{v_{1,i-1}},e_i,\ol{e_{i+1,n}})
					\arro{\bot } fail
		}}} \\[5ex]
		
		\mathcolorbox{yellow}{ (\mathit{Call2F}) ~ {\displaystyle
				\frac{\mathsf{eval}(op,v_1,\ldots,v_n) = \emptyset ~\land~ \mathsf{evalM}(\M,op,v_1,\ldots,v_n) = \emptyset  }{\theta,\mathsf{call }~ op (v_1,\dots,v_n)
					\arro{\bot} callFail}} }\\[4ex]

		\mathcolorbox{yellow}{ (\mathit{Apply1F}) ~ {\displaystyle
				\frac{\theta,e_i\arro{\bot} fail }
				{\theta,\mathsf{apply}~a/n~(\ol{v_{1,i-1}},e_i,\ol{e_{i+1,n}}) 
					\arro{\bot} fail
		}} }\\[5ex] 
		
		\mathcolorbox{yellow}{(\mathit{Apply2F}) ~ {\displaystyle
				\frac{\mu(a/n) = \emptyset }{\theta,\mathsf{apply}~a/n~(v_1,\ldots,v_n)
					\arro{\bot} applyFail}} }
		\end{array}
	\]
	\caption{Semantica standard: valutazione del fallimento delle espressioni sequenziali} \label{fig:seq-rules-fail}
\end{figure}
Nella Figura~\ref{fig:seq-rules-fail} sono presenti le regole di transizione che gestiscono i fallimenti.
La propagazione dell'errore è indicata dall'etichetta $\bot$; quindi, se una valutazione di un'espressione fallisce, allora il fallimento viene propagato. \\
Con il simbolo $\emptyset$ si intende: 
\begin{itemize}
	\item nel caso dei match, che l'argomento $v$ non corrisponde a nessuna clausola\footnote {Più precisamente in un programma Erlang quando è tradotto nella rappresentazione intermedia Core~Erlang, viene aggiunta una clausola catch-all; quindi il simbolo $\emptyset$ corrisponde al match della clausola aggiunta.};
	\item nei casi di eval, evalM e $\mu$, che le funzioni non sono definite sull'input dato.
\end{itemize}
\begin{figure}[h]
	\footnotesize
	\[
	\begin{array}{c}
		(\mathit{Send1}) ~ {\displaystyle 
			\frac{\theta,e_1 \arro{\ell} \theta',e'_1}{\theta,e_1\:!\: e_2 \arro{\ell}
				\theta',e'_1\:!\: e_2} ~~~~(\mathit{Send2}) ~\frac{\theta,e_2 \arro{\ell} \theta',e'_2}{\theta,v_1\:!\: e_2 \arro{\ell}
				\theta',v_1\:!\: e'_2} 
		}\\[4ex]
		
		(\mathit{Send3}) ~ {\displaystyle
			\frac{  }{\theta,v_1\:!\: v_2 \arro{\mathsf{send}(v_1,v_2)} \theta,v_2}
		}\\[4ex]
		
		(\mathit{Receive}) ~ {\displaystyle
			\frac{~}{\theta,\mathsf{receive}~cl_1;\ldots;cl_n~\mathsf{end}
				\arro{\mathsf{rec}(\kappa,\ol{cl_n})}
				\theta,\kappa
			}
		}\\[4ex]
		
		(\mathit{Spawn1}) ~ {\displaystyle
			\frac{\theta,e_i\arro{\ell}
				\theta',e'_i~~~i\in\{1,\ldots,n\}}{\theta,\mathsf{spawn}(a/n,[\ol{v_{1,i-1}},e_i,\ol{e_{i+1,n}}])
				\arro{\ell} \theta',\mathsf{spawn}(a/n,[\ol{v_{1,i-1}},e'_i,\ol{e_{i+1,n}}])       
		}}\\[4ex]
		
		(\mathit{Spawn2}) ~ {\displaystyle
			\frac{}{\theta,\mathsf{spawn}(a/n,[\ol{v_n}])
				\arro{\mathsf{spawn}(\kappa,a/n,[\ol{v_n}])} \theta,\kappa         
		}}\\[4ex]
		
		(\mathit{Self}) ~ {\displaystyle
			\frac{}{\theta,\mathsf{self}() \arro{\mathsf{self}(\kappa)} \theta,\kappa}}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{Register1}) ~ {\displaystyle 
				\frac{\theta, e_1 \arro{\ell} \theta',e'_1}{\theta, \mathsf{register}(e_1, e_2) \arro{\ell}
					\theta',\mathsf{register}(e'_1, e_2)} ~~~~
		}}\\[4ex]
		
		\mathcolorbox{yellow}{  (\mathit{Register2}) ~{\displaystyle
				\frac{\theta,e_2 \arro{\ell} \theta',e'_2}{\theta,\mathsf{register}(v_1, e_2) \arro{\ell}
					\theta',\mathsf{register}(v_1, e'_2)} 
		}}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{Register3}) ~ {\displaystyle
				\frac{~}{\theta,\mathsf{register}(v_1, v_2) \arro{\mathsf{register}(\kappa,v_1,v_2)} \theta,\kappa}}
		}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{Unregister1}) ~ {\displaystyle 
				\frac{\theta, e \arro{\ell} \theta',e'}{\theta, \mathsf{unregister}(e) \arro{\ell}
					\theta',\mathsf{unregister}(e')}}}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{Unregister2}) ~ {\displaystyle
				\frac{~}{\theta,\mathsf{unregister}(v) \arro{\mathsf{unregister}(\kappa,v)} \theta,\kappa}}
		}
	\end{array}
	\]
	\caption{Semantica standard: valutazione delle espressioni concorrenti} \label{fig:concurrent-rules}
\end{figure}
Si considera ora la valutazione di espressioni concorrenti che producono side-effects (Figura~\ref{fig:concurrent-rules}). Si hanno le regole $\mathit{Send1}$, $\mathit {Send2}$ e $\mathit{Send3}$ per ``$!$''. In questo caso si sa \emph{localmente} a cosa dovrebbe essere ridotta l'espressione (cioè $ v_2 $ nella regola $\mathit {Send3}$). Per le restanti regole questo non è noto localmente e, quindi, si restituisce un nuovo simbolo distinto, $\kappa $,  che viene trattato come una variabile, in modo che nelle regole di sistema nelle Figure~\ref{fig:system-rules}, \ref{fig:system-rules-map} $\kappa$ legherà al suo valore corretto:\footnote {Nota che $\kappa$ assume valori nel dominio $expr \cup Pid $, al contrario delle variabili ordinarie che possono essere associate solo a valori.} l'espressione selezionata nella regola $\mathit {Receive} $, un pid nelle regole $\mathit {Spawn}$ e $\mathit{Self}$ e \textbf{true} o \textbf{false} nelle regole $\mathit{Register}$ e $\mathit{Unregister}$. In questi casi, l'etichetta della transizione contiene tutte le informazioni necessarie alle regole di sistema per eseguire la valutazione a livello di sistema, incluso il simbolo $\kappa$. Questo \emph{trucco} permette di mantenere separate le regole per espressioni e sistemi (cioè, la semantica mostrata nelle Figura~\ref {fig:seq-rules} e \ref{fig:concurrent-rules} è per lo più indipendente dalle regole nelle Figure~\ref{fig:system-rules}, \ref{fig:system-rules-map}) in contrasto con altre semantiche di Erlang, ad esempio \cite{CMRT13tr}, dove sono combinate in una singola relazione di transizione.
Nelle regole di valutazione delle espressioni concorrenti della semantica standard sono state aggiunte le regole per la valutazione della $\mathsf{register}$ e dell'$\mathsf{unregister}$.

\begin{figure}[h]
	\footnotesize
	\[
	\begin{array}{c}	
		\mathcolorbox{yellow}{ (\mathit{Send1F}) ~ {\displaystyle 
				\frac{\theta,e_1 \arro{\bot} fail}
				{\theta,e_1\:!\: e_2 \arro{\bot} fail} ~~~~
				
				(\mathit{Send2F}) ~\frac{\theta,e_2 \arro{\bot} fail}
				{\theta,v_1\:!\: e_2 \arro{\bot} fail} 
		}}\\[4ex]
		
		\mathcolorbox{yellow}{ (\mathit{Spawn1F}) ~ {\displaystyle
				\frac{\theta,e_i\arro{\bot} fail}
				{\theta,\mathsf{spawn}(a/n,[\ol{v_{1,i-1}},e_i,\ol{e_{i+1,n}}])
					\arro{\bot} fail         
		}}}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{Register1F}) ~ {\displaystyle 
				\frac{\theta, e_1 \arro{\bot} fail}
				{\theta, \mathsf{register}(e_1, e_2) \arro{\bot} fail} ~~~~
			
				(\mathit{Register2F}) ~\frac{\theta,e_2 \arro{\bot} fail}
				{\theta,\mathsf{register}(v_1, e_2) \arro{\bot } fail} 
		}}\\[4ex]
		
		\mathcolorbox{yellow}{ (\mathit{Unregister1F}) ~ {\displaystyle 
				\frac{\theta, e \arro{\bot} fail}
				{\theta, \mathsf{unregister}(e) \arro{\bot} fail }}}
	\end{array}
	\]
	\caption{Semantica standard: valutazione del fallimento delle espressioni concorrenti} \label{fig:concurrent-rules-fail}
\end{figure}
~\newline
Anche nelle regole di valutazione delle espressioni concorrenti sono state aggiunte le regole che gestiscono il fallimento di un processo e che propagano il fallimento della valutazione di un'espressione.
\newline
Ora si possono presentare le regole di sistema che sono rappresentate nelle Figure~\ref{fig:system-rules} e \ref{fig:system-rules-map}; in tutte queste viene considerato un sistema generale nella forma $\Gamma;\tuple{p,(\theta,e),q}\:\comp\: \Pi;\M$ dove $\Gamma$ è la mailbox globale, $\tuple{p,(\theta,e),q}\:\comp\: \Pi$ è l'insieme dei processi che contiene almeno un processo e $\M$ è la mappa dei pid registrati. Rispetto all'articolo \cite{Lanese} in tutte le regole è stata aggiunta $\M$ visto che la definizione di sistema (Definizione~\ref{sistema}) è cambiata.\\
Ora verranno descritte brevemente tutte le regole di transizione del sistema. 
\begin{figure}[th]
	\footnotesize
	\[
	\begin{array}{c}
		(\mathit{Seq}) ~ {\displaystyle
			\frac{\theta,e\arro{\tau} \theta',e'
			}{\Gamma;\tuple{p,(\theta,e),q}\comp \Pi; \mathcolorbox{yellow}{\M} \hoo
				\Gamma;\tuple{p,(\theta',e'),q}\comp \Pi; \mathcolorbox{yellow}{\M}}
		}\\[4ex]
		
		\mathcolorbox{yellow}{\mathit{(Call3)} ~ {\displaystyle
				\frac{\theta,e\arro{\tau\M\M'} \theta',e'
				}{\Gamma;\tuple{p,(\theta,e),q}\comp \Pi; \M \hoo
					\Gamma;\tuple{p,(\theta',e'),q}\comp \Pi; \M}
		}}\\[4ex]
		
		(\mathit{Send}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{send}(p'',v)}
				\theta',e'  ~~~ \mathcolorbox{yellow}{\mathsf{isAtom}(p'')=false }
			}{\Gamma;\tuple{p,(\theta,e),q} 
				\comp \Pi; \mathcolorbox{yellow}{\M} \hoo \Gamma\cup (p'',v);\tuple{p,(\theta',e'),q}\comp \Pi; \mathcolorbox{yellow}{\M}}
		}\\[4ex]
		
		\mathcolorbox{yellow}{  (\mathit{SendA}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{send}(a,v)}
					\theta',e'  ~~~ \mathsf{isAtom}(a)=true ~~ \mathsf{matchPid}(\M, a) = p''
				}{\Gamma;\tuple{p,(\theta,e),q} 
					\comp \Pi;\M \hoo \Gamma\cup (p'',v);\tuple{p,(\theta',e'),q}\comp \Pi;\M}
		}}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{SendF}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{send}(a,v)}
					\theta',e'  ~~~ \mathsf{isAtom}(a)=true ~~\mathsf{matchPid}(\M, a) = false
				}{\Gamma;\tuple{p,(\theta,e),q} 
					\comp \Pi; \mathcolorbox{yellow}{\M} \hoo \Gamma;\tuple{p,(\theta,sendFail),q}\comp \Pi; {\M}}
		}}\\[4ex]
		
		(\mathit{Receive}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{rec}(\kappa,\ol{cl_n})}
				\theta',e'~~~ \mathsf{matchrec}(\theta,\ol{cl_n},q) =
				(\theta_i,e_i,v)} {\Gamma;\tuple{p,(\theta,e),q}\comp \Pi; \mathcolorbox{yellow}{\M} \hoo
				\Gamma;\tuple{p,(\theta'\theta_i,e'\{\kappa\mapsto
					e_i\}),q\backslash\!\!\backslash v}\comp \Pi; \mathcolorbox{yellow}{\M}}
		}\\[4ex]
		
		(\mathit{Spawn}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{spawn}(\kappa,a/n,[\ol{v_n}])}
				\theta',e'~~~ p'~\mbox{is a fresh pid}}{\Gamma;\tuple{p,(\theta,e),q} 
				\comp \Pi; \mathcolorbox{yellow}{\M} \hoo \Gamma;\tuple{p,(\theta',e'\{\kappa\mapsto p'\}),q}\comp \tuple{p',(\id,\mathsf{apply}~a/n~(\ol{v_n})),\nil} 
				\comp \Pi; \mathcolorbox{yellow}{\M}}
		}\\[4ex]
		
		(\mathit{Self}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{self}(\kappa)} \theta',e'}{\Gamma;\tuple{p,(\theta,e),q} 
				\comp \Pi; \mathcolorbox{yellow}{\M} \hoo \Gamma;\tuple{p,(\theta',e'\{\kappa\mapsto p\}),q} 
				\comp \Pi; \mathcolorbox{yellow}{\M} }
		}\\[4ex]
		
		(\mathit{Sched}) ~ {\displaystyle
			\frac{~}{\Gamma\cup\{(p,v)\};\tuple{p,(\theta,e),q}\comp\Pi; \mathcolorbox{yellow}{\M} 
				\hoo \Gamma;\tuple{p,(\theta,e),v\cons q}\comp\Pi; \mathcolorbox{yellow}{\M}}
		}
	\end{array}
	\]
	\caption{Regole standard della semantica del sistema} \label{fig:system-rules}
\end{figure}
~\\
La regola $\mathit{Seq}$ aggiorna semplicemente il controllo $(\theta, e)$ del processo considerato quando un'espressione sequenziale viene ridotta utilizzando le regole di espressione.
\\
La regola $\mathit{Call3}$ come $\mathit{Seq}$ aggiorna semplicemente il controllo $(\theta, e)$ del processo considerato quando un'espressione sequenziale viene ridotta utilizzando le regole di espressione; accedendo però alla mappa, utilizza l'etichetta $\tau\M\M'$ invece di $\tau$.
\\
Le regole $\mathit{Send} $ e $\mathit{SendA} $ aggiungono la coppia $(p '', v)$ alla mailbox globale $\Gamma$ invece di aggiungerla alla coda del processo $p ''$. Ciò è necessario per garantire che tutti i possibili intrecci di messaggi siano modellati correttamente.
È stata introdotta la funzione ausiliaria $\mathsf{isAtom}$ che viene utilizzata per capire se la regola debba accedere alla mappa; l'unica differenza fra le due regole è che la $\mathit{SendA}$ utilizza un atomo come destinatario. 
Si noti che $e '$ è solitamente diverso da $v$ poiché $e$ può avere operatori annidati diversi. Ad esempio, se $e$ ha la forma `` $\mathsf{case} ~ \mathrm{p} \:! \: V ~ \mathsf {of} ~ \{\ldots \} $,'' allora $ e '$ sarà ``$ \mathsf {case} ~ v ~ \mathsf {of} ~ \{\ldots \} $'' con etichetta $ \mathsf {send} (\mathrm {p}, v) $ per un qualche $v$.
\\
La regola $\mathit{SendF}$ introduce un fallimento, visto che l'espressione da valutare successivamente nel processo sarà l'atromo $sendFail$ che corrisponde ad un fallimento. Questo avviene perchè l'atomo che si utilizza per inviare un messaggio non è associato nessun pid nella mappa, come comprensibile dalla funzione $\mathsf{matchPid}$.
	\\
Nella regola $ \mathit {Receive} $ si usa la funzione ausiliaria $ \mathsf {matchrec} $ per valutare un'espressione di ricezione. La differenza principale con $\mathsf {match}$ è che $\mathsf{matchrec}$ prende anche una coda $q$ e restituisce il messaggio selezionato $v$. Più precisamente, la funzione $ \mathsf {matchrec} $ esegue la scansione della coda $ q $ cercando il \emph {primo} messaggio $ v $ che corrisponde a un modello dell'istruzione di ricezione. Quindi $ \kappa $ viene associato all'espressione nella clausola selezionata, $ e_i $, e l'ambiente viene esteso con la sostituzione corrispondente.
		\\
Se nessun messaggio nella coda $ q $ corrisponde ad alcuna clausola, la regola non è applicabile e il processo selezionato non può essere ridotto (cioè viene sospeso). Come nelle espressioni case, si assume che i pattern possano contenere solo nuove variabili.
\\
Le regole presentate finora consentono di memorizzare i messaggi nella mailbox globale, ma non di rimuoverli. Questo è esattamente il compito dello scheduler, modellato dalla regola $ \mathit{Sched}$. Questa regola sceglie in modo non deterministico una coppia $ (p, v) $ nella mailbox globale $ \Gamma $ e consegna il messaggio $ v $ al processo di destinazione $ p $. Qui si ignora deliberatamente la restrizione: `` i messaggi inviati, direttamente, tra due processi dati arrivano nello stesso ordine in cui sono stati inviati", poiché le attuali implementazioni lo garantiscono solo all'interno dello stesso nodo. In pratica, ignorare questa restrizione equivale a considerare che ogni processo è potenzialmente eseguito in un nodo diverso. Una definizione alternativa che garantisce questa restrizione può essere trovata in \cite{NPV16b}.
      \begin{figure}[th]
	\footnotesize
	\[
	\begin{array}{c}
		
		\mathcolorbox{yellow}{(\mathit{Register T}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{register}(\mathsf{true},a,p')}
					\theta',e' ~ \mathsf{matchMapReg}(\M, a,p') = true} {\Gamma;\tuple{p,(\theta,e),q}\comp \Pi; \M \hoo
					\Gamma;\tuple{p,(\theta',e'),q}\comp \Pi; \M\cup(a,p')  }
		}}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{Register F}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{register}(\mathsf{false},a,p')}
					\theta',e' ~ \mathsf{matchMapReg}(\M, a,p') = false} {\Gamma;\tuple{p,(\theta,e),q}\comp \Pi; \M \hoo
					\Gamma;\tuple{p,(\theta,regFail),q}\comp \Pi; \M}
		}}\\[4ex]      
		
		\mathcolorbox{yellow}{(\mathit{UnregisterT}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{unregister}(\mathsf{true},a)}
					\theta',e' ~ \mathsf{matchMapUnreg}(\M, a) = p'} {\Gamma;\tuple{p,(\theta,e),q}\comp \Pi; \M \hoo
					\Gamma;\tuple{p,(\theta',e'),q}\comp \Pi; \M\backslash\!\!\backslash(a,p')  }
		}}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{UnregisterF}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{unregister}(\mathsf{false},a)}
					\theta',e' ~ \mathsf{matchMapUnreg}(\M,a) = false} {\Gamma;\tuple{p,(\theta,e),q}\comp \Pi; \M \hoo
					\Gamma;\tuple{p,(\theta,unregFail),q}\comp \Pi; \M  }
		}}\\[4ex]
	
		\mathcolorbox{yellow}{(\mathit{Catch}) ~ {\displaystyle
				\frac{ \theta,e \arro{\bot}  fail  }{\Gamma;\tuple{p,(\theta,e),q}\comp \Pi; \M \hoo
					\Gamma;\tuple{p,(\theta,fail),q}\comp \Pi; \M}
		}}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{End}) ~ {\displaystyle
				\frac{ \mathsf{matchEnd}(\M,p)=a'  ~~  }{\Gamma;\tuple{p,(\theta,\epsilon),q}\comp \Pi; \M \hoo
					\Gamma;\tuple{p,(\theta,\epsilon),q}\comp \Pi; \M\backslash\!\!\backslash (a' ,p)}
		}}
		\end{array}
	\]
	\caption{Regole standard della semantica del sistema che utilizzano la mappa} \label{fig:system-rules-map}
\end{figure}
Nella figura \ref{fig:system-rules-map} si può notare che sono state aggiunte anche le regole per la $\mathsf{register}$ e per l'$\mathsf{unregister}$.
Queste regole sono divise in 2 casi:
\begin{itemize}
	\item il caso di successo;
	\item il caso di fallimento (che introduce come prossima espressione da valutare un atomo che descrive un fallimento).
\end{itemize}
Il caso di successo corrisponde alle regole $\mathit{RegisterT}$ e $\mathit{UnregisterT}$ che rispettivamente aggiunge la coppia $(a,p')$ alla mappa e tolgie la coppia $(a,p')$, mentre il caso di fallimento corrisponde alle regole $\mathit{RegisterF}$ e $\mathit{UnregisterF}$. 
\\
La regola $\mathit{Catch}$ serve per gestire il caso di fallimento di un processo che viene catturato al top-level.
\\
La regola $End$ serve per gestire il caso di terminazione di un processo. In caso di fallimento o terminazione con successo se è registrato allora viene deregistrato. Questa scelta è stata fatta per essere il più possibili fedeli al comportamento di Erlang.

\subsection*{Concorrenza in Erlang}

Per definire una semantica reversibile per Erlang si ha bisogno non solo di una semantica come quella appena presentata, ma anche di una nozione di concorrenza (o, equivalentemente, della nozione opposta di conflitto). 
\\
Dati i sistemi $ s_1, s_2 $, si chiama $ s_1 \hoo ^ \ast s_2 $ una \emph {derivazione}.
\\
Le derivazioni in un passaggio sono chiamate semplicemente \emph {transizioni}. Si usa $ d, d ', d_1, \ldots $ per indicare le derivazioni e $ t, t', t_1, \ldots $ per le transizioni.
\\
Le transizioni vengono etichettate con: $s_1 \hoo_{p,r} s_2$ dove:
\begin{itemize}
	\item $p$ è il pid del processo selezionato nella transizione o del processo a cui viene consegnato un messaggio (se la regola applicata è  $\mathit{Sched})$;
	\item $r$ è l'etichetta della regola di transizione applicata. 
\end{itemize}
Data una derivazione $ d = (s_1 \hoo ^\ast s_2) $, si definisce $ \init(d) = s_1 $ e $ \final(d) = s_2 $.
Due derivazioni, $ d_1 $ e $ d_2 $, sono \emph{componibili} se $\final(d_1) = \init (d_2) $. In questo caso, $ d_1; d_2 $ corrisponde alla composizione $d_1; d_2=(s_1\hoo s_2\hoo\cdots\hoo s_n\hoo s_{n + 1}\hoo\cdots\hoo s_m)$ se $d_1 = (s_1 \hoo s_2 \hoo \cdots \hoo s_n) $ e $ d_2 = (s_n \hoo s_ {n + 1} \hoo \cdots \hoo s_m)$.
Due derivazioni, $ d_1 $ e $ d_2 $, sono dette \emph{coiniziali} se $\init(d_1) = \init (d_2) $ e \emph {cofinali} se $\final(d_1) = \final( d_2)$.

\begin{definition}[Transizioni concorrenti] \label{def:concurrent1}
	Date due transizioni coiniziali, $t_1 = (s \hoo_{p_1,r_1} s_1)$
	e $t_2 = (s \hoo_{p_2,r_2} s_2)$, si dice che sono
	\emph{in conflitto} se:
  \begin{itemize}
	\item considerano lo stesso processo, i.e., $p_1 = p_2$, e anche $r_1 = r_2 = \mathit{Sched}$ o se una transizione applica la regola $\mathit{Sched}$, e l'altra applica la regola $\mathit{Receive}$ \cite{Lanese};
	\item entrambe sono operazioni sulla mappa e una delle due regole accede in scrittura sulla mappa ($\mathsf{RegisterT}$, $\mathsf{UnregisterT}$, $\mathsf{End}$) e l'altra vi accede o in scrittura o in lettura ($\mathsf{SendA}$, $\mathsf{SendF}$, $\mathsf{RegisterF}$, $\mathsf{UnregisterF}$, $\mathsf{Call3}$), in modo che una delle funzioni ($\mathsf{matchPid}$, $\mathsf{matchMapReg}$, $\mathsf{matchMapUnreg}$, $\mathsf{matchEnd}$, $\mathsf{evalM}$) utilizzate non abbia più lo stesso risultato. I casi in cui questo accade sono presenti nella tabella~\ref{tab:conflitti}.
	\begin{table}[h]
		\hspace{-15ex}
		\begin{tabular}{|l|l|lllllll}
			\hline
			\backslashbox{$~r_1~~$} {$~~r_2~$} & $\mathsf{Call3}$ & \multicolumn{1}{l|}{$\mathsf{UnregisterF}$} & \multicolumn{1}{l|}{$\mathsf{RegisterF}$} & \multicolumn{1}{l|}{$\mathsf{SendF}$} & \multicolumn{1}{l|}{$\mathsf{SendA}$} & \multicolumn{1}{l|}{$\mathsf{End}$} & \multicolumn{1}{l|}{$\mathsf{UnregisterT}$} & \multicolumn{1}{l|}{$\mathsf{RegisterT}$} \\ \hline
			$\mathsf{RegisterT}$   &    \begin{tabular}[c]{@{}l@{}}$a'  \in \mathsf{M'} ~\lor$ \\ $ p' \in \mathsf{M'}$\end{tabular}   & \multicolumn{1}{l|}{$a'=a''$}            & \multicolumn{1}{l|}{}          & \multicolumn{1}{l|}{$a'=a''$}      & \multicolumn{1}{l|}{}      & \multicolumn{1}{l|}{}    & \multicolumn{1}{l|}{}            & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}$a'=a'' ~\lor$ \\ $ p'=p''$\end{tabular}}          \\ \hline
			$\mathsf{UnregisterT}$ &  \begin{tabular}[c]{@{}l@{}}$a'  \in \mathsf{M'} ~\lor$ \\ $ p' \in \mathsf{M'}$\end{tabular}      & \multicolumn{1}{l|}{}            & \multicolumn{1}{l|}{$a'=a''$}          & \multicolumn{1}{l|}{}      & \multicolumn{1}{l|}{$a'=a''$}& \multicolumn{1}{l|}{$a'=a''$}    & \multicolumn{1}{l|}{$a'=a''$}            &                                \\ \cline{1-8}
			$\mathsf{End}$         &    \begin{tabular}[c]{@{}l@{}}$a'  \in \mathsf{M'} ~\lor$ \\ $ p' \in \mathsf{M'}$\end{tabular}   & \multicolumn{1}{l|}{}            & \multicolumn{1}{l|}{$a'=a''$}          & \multicolumn{1}{l|}{}      & \multicolumn{1}{l|}{$a'=a''$}      & \multicolumn{1}{l|}{}    &                                  &                                \\ \cline{1-7}
			$\mathsf{SendA}$       &       & \multicolumn{1}{l|}{}            & \multicolumn{1}{l|}{}          & \multicolumn{1}{l|}{}      & \multicolumn{1}{l|}{}      &                          &                                  &                                \\ \cline{1-6}
			$\mathsf{SendF}$       &       & \multicolumn{1}{l|}{}            & \multicolumn{1}{l|}{}          & \multicolumn{1}{l|}{}      &                            &                          &                                  &                                \\ \cline{1-5}
			$\mathsf{RegisterF}$   &       & \multicolumn{1}{l|}{}            & \multicolumn{1}{l|}{}          &                            &                            &                          &                                  &                                \\ \cline{1-4}
			$\mathsf{UnregisterF}$ &       & \multicolumn{1}{l|}{}            &                                &                            &                            &                          &                                  &                                \\ \cline{1-3}
			$\mathsf{Call3}$       &       &                                  &                                &                            &                            &                          &                                  &                                \\ \cline{1-2}
		\end{tabular}
		\caption{\label{tab:conflitti} Tabella dei conflitti per le regole forward-forward}
	\end{table}

	Nella Tabella~\ref{tab:conflitti} sono presenti i casi in cui si verificano i conflitti; $a'$ e $p'$ rappresentano l'atomo e il pid coinvolti da $r_1$, mentre $a''$ e $p''$ rappresentano l'atomo e il pid coinvolto da $r_2$. $\mathsf{M'}$ rappresenta gli elementi letti nella mappa dalla regola $\mathsf{Call3}$. Le celle vuote rappresentano transizioni coiniziali che non vanno in conflitto.\\
	Si nota che esistono coppie di operazini in scrittura che non sono in conflitto visto che nei casi in cui sarebbe presente il conflitto queste operazioni non possono essere coiniziali. 
	%Da notare che non tutte le operazioni in scrittura sulla mappa sono in conflitto fra di loro, questo perché in quei casi le transizioni non possono essere coiniziali e in conflitto. 
\end{itemize}
Due transizioni coiniziali sono \emph{concorrenti} se non sono in conflitto. \qed
\end{definition}
	\begin{example}
	Nel caso $\mathsf{RegisterT}, ~ \mathsf{UnregisterT}$ non può essere presente un conflitto quando le due transizioni sono coiniziali perché si dovrebbe avere che $a'$ non dovrebbe appartenere alla mappa di atomi e pid per applicare $\mathsf{RegisterT}$, $a''$ dovrebbe appartenere alla mappa di atomi e pid per poter applicare $\mathsf{UnregisterT}$ e per essereci il conflitto $a'$ dovrebbe essere uguale ad $a''$, il che è impossibile. 
\end{example}

Questa definizione è utile per la dimostrazione del prossimo lemma.

\begin{lemma}[\textbf{Square lemma}] \label{lemma:square1} Date due transizioni coiniziali concorrenti $t_1 = (s \hoo_{p_1,r_1} s_1)$ e
	$t_2 = (s \hoo_{p_2,r_2} s_2)$, allora esistono due transizioni cofinali $t_2/t_1 = (s_1 \hoo_{p_2,r_2} s')$ e
	$t_1/t_2 = (s_2 \hoo_{p_1,r_1} s')$.  Graficamente,
	\[
	\begin{minipage}{50ex}
		\xymatrix@C=50pt@R=20pt{
			s \ar@{^{(}->}[r]^{p_1,r_1} \ar@<1pt>@{^{(}->}[d]_{p_2,r_2} & s_1\\
			s_2 & 
		}
	\end{minipage}
	~~
	\Longrightarrow
	~~
	\begin{minipage}{50ex}
		\xymatrix@C=50pt@R=20pt{
			s \ar@{^{(}->}[r]^{p_1,r_1} \ar@{^{(}->}[d]_{p_2,r_2} & s_1 \ar@{^{(}->}[d]^{p_2,r_2}\\
			s_2 \ar@{^{(}->}[r]_{p_1,r_1} &  s'
		}
	\end{minipage}
	\]
\end{lemma}
\begin{proof}
	Si hanno i seguenti casi:
	\begin{itemize}
		\item entrambe le transizioni non applicano regole sulla mappa:
			\begin{itemize}
		\item due transizioni $ t_1 $ e $ t_2 $ dove $r_1\neq\mathit{Sched}$ e $r_2\neq\mathit{Sched}$. Banalmente, si applicano a processi diversi, ad esempio $p_1\neq p_2$. Quindi, si può facilmente dimostrare che applicando la regola $r_2$ a $p_1$ in $s_1$ e la regola $r_1$ a $p_2$ in $s_2$, si hanno due transizioni $t_1/t_2$ e $t_2/t_1$ che sono cofinali \cite{Lanese};
		\item una transizione $t_1$ che applica la regola $r_1=\mathit{Sched}$ per consegnare il messaggio $v_1$ all'elaborazione $p_1=\mathrm{p}$, e un'altra transizione che applica una regola $r_2$ diversa da $\mathit{Sched}$. Tutti i casi tranne $r_2=\mathit{Receive}$ con $p_2=\mathrm{p}$ sono semplici. Quest'ultimo caso, tuttavia, non può accadere poiché le transizioni che utilizzano le regole $\mathit{Sched}$ e $\mathit{Receive}$ non sono simultanee \cite{Lanese};
		\item due transizioni $ t_1 $ e $ t_2 $ con le regole $ r_1 = r_2 = \mathit {Sched} $ che consegnano rispettivamente i messaggi $ v_1 $ e $ v_2 $. Poiché le transizioni sono simultanee, dovrebbero consegnare i messaggi a processi differenti, cioè $ p_1 \neq p_2 $. Pertanto, si può vedere che consegnando $ v_2 $ da $ s_1 $ e $ v_1 $ da $ s_2 $ si ottengono due transizioni cofinali \cite{Lanese}; 
				\end{itemize}
		\item due transizioni $t_1$ e $t_2$ dove $r_1 = $ operazione sulla mappa e $r_2 \neq $ operazione sulla mappa. Quindi, si può facilmente dimostrare che applicando la regola $r_2$ a $p_1$ in $s_1$ e la regola $r_1$ a $p_2$ in $s_2$ si hanno due transizioni $t_1 / t_2$ e $t_2 / t_1$ che sono cofinali;
		\item entrambe le operazioni $r$ sono eseguite sulla mappa, questo perché se andassero a modificare gli stessi elementi della mappa non potrebbero essere concorrenti per la definizione data: 
		\begin{itemize}
			\item se $r_1 = r_2 = \mathsf{UnregisterT}$ deregistrano gli atomi $a_1$ e $a_2$ e se le due operazioni sono concorrenti (quindi $a_1 \not= a_2$), deregistrare prima $a_1$ e poi $a_2$ o viceversa non cambia (in $s'$ la mappa sarà la stessa);
			\item  questo ragionamento può essere applicato a tutte le regole sulla mappa. \qedhere
		\end{itemize}
	\end{itemize}
\end{proof} 

Si noti che sono possibili altre definizioni di transizioni concorrenti. La modifica del modello di concorrenza richiederebbe la modifica delle informazioni memorizzate nella semantica reversibile al fine di preservare la coerenza causale. È stata scelta la nozione sopra poiché è ragionevolmente semplice da definire e perché è facile lavorarci.

\section{Semantica reversibile}\label{sect:semreversibile}

In questa sezione, viene introdotta una semantica reversibile (non controllata) per il linguaggio considerato. Grazie al design modulare della semantica concreta, non è necessario modificare le regole di transizione per le espressioni del linguaggio per definire la semantica reversibile.
\\
Per essere precisi, in questa sezione verranno introdotte due relazioni di transizione: $ \rh $ e $ \lh $. La prima relazione, $ \rh $, è un'estensione conservativa della semantica standard $ \hoo $ (Figure~\ref {fig:system-rules} e \ref{fig:system-rules-map}) per includere anche alcune informazioni aggiuntive negli stati, seguendo un tipico incorporamento di Landauer. Verrà indicata con $ \rh $ la semantica reversibile \emph{forward} (o semplicemente alla semantica forward). Al contrario, la seconda relazione, $ \lh $, procede nella direzione all'indietro, ``annullando'' le azioni passo dopo passo. Ci si riferisce a $ \lh $ come semantica \emph{backward} (reversibile). Verrà indicata l'unione $ \rh \cup \lh $ con $ \rlh $.
\\
Per evitare di annullare tutte le azioni fino all'inizio del processo, lasceremo anche che il programmatore introduca \emph{checkpoints}. Sintatticamente, sono indicati con la funzione incorporata \textsf{check}, che accetta un identificatore $ \mathtt{t} $ come argomento. Tali identificatori dovrebbero essere univoci nel programma. Data un'espressione, $ expr $, si può introdurre un checkpoint sostituendo $ expr $ con `` $\mathsf {let} ~ X = \mathsf {check} (\mathtt {t}) ~ \mathsf {in} ~ expr $''. Una chiamata nella forma $ \mathsf {check} (\mathtt {t}) $ restituisce semplicemente $ \mathtt {t} $ (vedi sotto).
Di seguito, si considera che le regole per valutare le espressioni del linguaggio (Figure~\ref {fig:seq-rules} e \ref{fig:concurrent-rules}) sono estese con la seguente regola:
\[
(\mathit{Check}) ~~ 
{\displaystyle 
   	\frac{}{\theta,\mathsf{check}(\mathtt{t}) \arro{\mathsf{check}(\mathtt{t})} \theta,\mathtt{t}}}
\]

Le principali modifiche effettuate sono state l'aggiunta di una storia al processo, di un identificatore per i messaggi (un timestamp $\lambda$)~\cite{Lanese} e di una storia della mappa. 
L'aggiunta della storia del processo e della mappa è un tipico incorporamento di Laundered in cui viene aggiunta la cronologia delle operazioni eseguite dal processo (nel primo caso) e delle operazioni eseguite sulla mappa. Il sistema ora include una memoria (storia) che registra gli stati intermedi della mappa. Questo è stato fatto perché in questo modo è possibile tenere traccia delle operazioni che sono state eseguite sulla mappa e del loro ordine di esecuzione.
\\
Al messaggio è stato aggiunto un timestamp perché,  se si considera un processo $ \mathrm {p1} $ che invia due messaggi identici ad un altro processo $ \mathrm {p2} $ (il che non è insolito, ad esempio un ``ack'' dopo aver ricevuto una richiesta), per annullare la prima azione $ \mathrm {p2} \:! \: \mathrm {v} $ del processo $ \mathrm {p1} $ è necessario annullare tutte le azioni del processo $ \mathrm {p2 } $ fino alla ricezione del primo messaggio. Tuttavia, non si può distinguere il primo messaggio dal secondo a meno che non si tenga conto di alcune informazioni aggiuntive. Pertanto, è necessario introdurre un identificatore univoco per distinguere con precisione questo caso.

\begin{figure}[htp]
	\footnotesize
	\[
	\begin{array}{c}
		(\mathit{Seq}) ~ {\displaystyle
			\frac{\theta,e\arro{\tau} \theta',e'
			}{\Gamma;\tuple{p,\h,(\theta,e),q}\comp \Pi;\mathcolorbox{yellow}{\M;\s} \rh
				\Gamma;\tuple{p,\tau(\theta,e)\cons\h,(\theta',e'),q}\comp \Pi;\mathcolorbox{yellow}{\M;\s} }
		}\\[4ex]
	
			\mathcolorbox{yellow}{(\mathit{Call3}) ~ {\displaystyle
			\frac{\theta,e\arro{\tau\M\M'} \theta',e'}
			{      \begin{split}
					\Gamma;\tuple{p,\h,(\theta,e),q}\comp \Pi;\M;\s 
					\rh \Gamma;\tuple{p,\tau\M\M'(\theta,e,p)\cons\h,(\theta',e'),q}\comp \Pi;\\
					\M;\tau\mathsf{MM'}(\theta,e,p)\cons\s
				\end{split}
			}
	}}\\[7ex]
		
		(\mathit{Check}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{check}(\mathtt{t})} \theta',e'}{\Gamma;\tuple{p,\h,(\theta,e),q} 
				\comp \Pi;\mathcolorbox{yellow}{\M;\s} \rh \Gamma;\tuple{p,\mathsf{check}(\theta,e,\mathtt{t})\cons\h,(\theta',e'),q} 
				\comp \Pi;\mathcolorbox{yellow}{\M;\s} }
		}\\[4ex]
		
		(\mathit{Send}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{send}(p'',v)}
				\theta',e'~~~\k~\mbox{is a fresh identifier} ~\mathcolorbox{yellow}{\mathsf{isAtom}(p'')=false ~~ }}
			{
				\begin{split}
					\Gamma;\tuple{p,\h,(\theta,e),q} 
					\comp \Pi;\mathcolorbox{yellow}{\M;\s} \rh
					\Gamma\cup (p'',\{v,\k\});\tuple{p,\mathsf{send}(\theta,e,p'',\{v,\k\})\cons
						\h,(\theta',e'),q}\comp \Pi;
					\mathcolorbox{yellow}{\M;\s}
				\end{split}
			}
		}\\[8ex]
		
		\mathcolorbox{yellow}{(\mathit{SendA}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{send}(a,v)}
					\theta',e'~~~\k~\mbox{is a fresh identifier} ~\mathcolorbox{yellow}{\mathsf{isAtom}(a)=true ~~ \mathsf{matchPid}(\M, a) = p''}}
				{
					\begin{split}
						\Gamma;\tuple{p,\h,(\theta,e),q} 
						\comp \Pi;\M;\s \rh
						\Gamma\cup (p'',\{v,\k\});\tuple{p,\mathsf{sendA}(\theta,e,p'',\{v,\k\},a,p)\cons
							\h,(\theta',e'),q}\comp \Pi;\\
						\M;\mathsf{sendA}(\theta,e,p'',\{v,\k\},a,p)\cons\s
					\end{split}
				}
		}}\\[8ex]
		
		\mathcolorbox{yellow}{(\mathit{SendF}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{send}(a,v)}
					\theta',e'~~~\mathcolorbox{yellow}{\mathsf{isAtom}(a)=true ~~ \mathsf{matchPid}(\M, a) = false}}
				{\begin{split}
						\Gamma;\tuple{p,\h,(\theta,e),q} 
						\comp \Pi;\M;\s \rh
						\Gamma;\tuple{p,\mathsf{sendF}(\theta,e,a,p)\cons
							\h,(\theta,sendFail),q}\comp \Pi;\\
						\M;\mathsf{sendF}(\theta,e,a,p)\cons\s
					\end{split}
			}}
		}\\[8ex]
		
		(\mathit{Receive}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{rec}(\kappa,\ol{cl_n})}
				\theta',e'~~~ \mathsf{matchrec}(\theta,\ol{cl_n},q) = (\theta_i,e_i,\{v,\k\})}{\Gamma;\tuple{p,\h,(\theta,e),q}\comp \Pi;\mathcolorbox{yellow}{\M;\s} \rh
				\Gamma;\tuple{p,\mathsf{rec}(\theta,e,\{v,\k\},q)\cons\h,(\theta'\theta_i,e'\{\kappa\mapsto e_i\}),q\backslash\!\!\backslash\{v,\k\}}\comp \Pi;\mathcolorbox{yellow}{\M;\s}}
		}\\[4ex]
		
		(\mathit{Spawn}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{spawn}(\kappa,a/n,[\ol{v_n}])}
				\theta',e'~~~ p'~\mbox{is a fresh pid}}%%~~~\mbox{and $\mathtt{t}$ is fresh}}
			{\begin{array}{ll}
					\Gamma;\tuple{p,\h,(\theta,e),q} 
					\comp \Pi;\mathcolorbox{yellow}{\M;\s} \rh &
					\Gamma;\tuple{p,\mathsf{spawn}(\theta,e,p')\cons\h,(\theta',e'\{\kappa\mapsto
						p'\}),q} \\
					& \comp \tuple{p',\nil,(\id,\mathsf{apply}~a/n~(\ol{v_n})),\nil} 
					\comp \Pi;\mathcolorbox{yellow}{\M;\s}
			\end{array}}
		}\\[6ex]
		
		(\mathit{Self}) ~ {\displaystyle
			\frac{\theta,e \arro{\mathsf{self}(\kappa)} \theta',e'}
			{\Gamma;\tuple{p,\h,(\theta,e),q} \comp \Pi;\mathcolorbox{yellow}{\M;\s} 
				\rh 
				\Gamma;\tuple{p,\mathsf{self}(\theta,e)\cons\h,(\theta',e'\{\kappa\mapsto p\}),q} 
				\comp \Pi;\mathcolorbox{yellow}{\M;\s} }
		}\\[4ex]
		
		(\mathit{Sched}) ~ {\displaystyle
			\frac{~}
			{\Gamma\cup\{(p,\{v,\k\})\};\tuple{p,\h,(\theta,e),q}\comp\Pi;\mathcolorbox{yellow}{\M;\s} 
				\rh \Gamma;\tuple{p,\h,(\theta,e),\{v,\k\}\cons q}\comp\Pi;\mathcolorbox{yellow}{\M;\s}}
		}
	\end{array}
	\]
	\caption{Semantica reversibile forward} \label{fig:forwardsem}
\end{figure}

Le regole di transizioni della semantica forward si possono trovare nelle Figure~\ref{fig:forwardsem} e \ref{fig:forwardsem1}. Ai processi è stata aggiunta una \emph{storia} (o memoria) $\h$ che registra gli stati intermedi del processo e dei messaggi con l'identificatore (univoco) a loro associato. \\~\\
Nella storia per identificare le operazioni eseguite si utilizzano dei costruttori $\tau$, $\mathsf{check}$, $\mathsf{send}$, $\mathsf{rec}$, $\mathsf{spawn}$, $\mathsf{self}$, $\mathcolorbox{yellow}{\tau\M\M'}$, $\mathcolorbox{yellow}{\mathsf{sendA}}$, $\mathcolorbox{yellow}{\mathsf{sendF}}$, $\mathcolorbox{yellow}{\mathsf{regT}}$, $\mathcolorbox{yellow}{\mathsf{regF}}$, $\mathcolorbox{yellow}{\mathsf{unregT}}$, $\mathcolorbox{yellow}{\mathsf{unregF}}$, $\mathcolorbox{yellow}{\mathsf{fail}}$ e $\mathcolorbox{yellow}{\mathsf{end}}$, che identificano le regole applicate nella semantica forward. 
%Si nota che si potrebbero diminuire le informazioni salvate nella storia utilizzando una strategia simile a quella utilizzata in \cite{MHNHT07,NPV16,TA15} ma questo è un problema diverso da quello discusso nella tesi.
Nella regola $ \mathit {Receive} $ si può notare che la funzione ausiliare  $\mathsf{matchrec}$ prende in input un messaggio del tipo $\{v,\k\}$, che è l'estensione originale che ignora $\k$ quando elabora il match col primo messaggio.

\begin{figure}[htp]
	\footnotesize
	\[
	\begin{array}{c}
	
		\mathcolorbox{yellow}{(\mathit{RegisterT}) ~ {\displaystyle
				\frac{\theta,e\arro{\mathsf{register}(\mathsf{true},a,p')} \theta',e'~ \mathsf{matchMapReg}(\M, a,p') = true}
				{    
					\begin{split}
						\Gamma;\tuple{p,\h,(\theta,e),q}\comp \Pi;\M;\s 
						\rh \Gamma;\tuple{p,\mathsf{regT}(\theta,e,a,p',p)\cons\h,(\theta',e'),q}\comp \Pi;\\
						\M\cup(a,p'); \mathsf{regT}(\theta,e,a,p',p) \cons\s
					\end{split}
			}}
		}\\[7ex]
		
		\mathcolorbox{yellow}{(\mathit{RegisterF}) ~ {\displaystyle
				\frac{\theta,e\arro{\mathsf{register}(\mathsf{false},a,p')} \theta',e' ~ \mathsf{matchMapReg}(\M, a,p') = false}
				{\begin{split}
						\Gamma;\tuple{p,\h,(\theta,e),q}\comp \Pi;\M;\s 
						\rh \Gamma;\tuple{p,\mathsf{regF}(\theta,e,a,p',p)\cons\h,(\theta,regFail),q}\comp \Pi;\\
						\M; \mathsf{regF}(\theta,e,a,p',p) \cons\s 
			\end{split}}}
		}\\[7ex]
		
		\mathcolorbox{yellow}{(\mathit{UnregisterT}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{unregister}(\mathsf{true},a)}
					\theta',e' ~ \mathsf{matchMapUnreg}(\M, a,p) = p'} 
				{      \begin{split}
						\Gamma;\tuple{p,h,(\theta,e),q}\comp \Pi;\M;\s 
						\rh \Gamma;\tuple{p,\mathsf{unregT}(\theta,e,a,p',p)\cons\h, (\theta',e'),q}\comp \Pi; \\
						\M\backslash\!\!\backslash(a,p'); \mathsf{unregT}(\theta,e,a,p',p)\cons\s  
				\end{split}}
		}}\\[7ex]

		\mathcolorbox{yellow}{(\mathit{UnregisterF}) ~ {\displaystyle
				\frac{\theta,e \arro{\mathsf{unregister}(\mathsf{false},a)}
					\theta',e' ~ \mathsf{matchMapUnreg}(\M, a,p) = false} 
				{
					\begin{split}
						\Gamma;\tuple{p,h,(\theta,e),q}\comp \Pi; \M;\s 
						\rh \Gamma;\tuple{p,\mathsf{unregF}(\theta,e,a,p)\cons\h,(\theta,unregFail),q}\comp \Pi;\\
						\M;\mathsf{unregF}(\theta,e,a,p) \cons\s  
					\end{split}
				}
		}}\\[7ex]
		
		\mathcolorbox{yellow}{(\mathit{Catch}) ~ {\displaystyle
				\frac{ \theta,e \arro{\bot}  fail  }{\Gamma;\tuple{p,\h,(\theta,e),q}\comp \Pi; \M;\s \rh
					\Gamma;\tuple{p,\mathsf{fail}(\theta,e)\cons\h,(\theta,fail),q}\comp \Pi; \M;\s}
		}}\\[3ex]

		\mathcolorbox{yellow}{(\mathit{End}) ~ {\displaystyle
				\frac{\mathsf{matchEnd}(\M,p)=a'}{
						\Gamma;\tuple{p,\h,(\theta,\epsilon),q}\comp \Pi;\M;\s \rh
						\Gamma;\tuple{p,\mathsf{end}(\theta,\epsilon,a',p)\cons\h,(\theta,\epsilon),q}\comp \Pi,
						\M\backslash\!\!\backslash (a' ,p); \mathsf{end}(\theta,\epsilon,a',p)\cons\s
				}
		}}\\[3ex]
	
\mathcolorbox{yellow}{(\mathit{End}) ~ {\displaystyle
\frac{\mathsf{matchEnd}(\M,p)=\emptyset}{
	\Gamma;\tuple{p,\h,(\theta,\epsilon),q}\comp \Pi;\M;\s \rh
	\Gamma;\tuple{p,\mathsf{end}(\theta,\epsilon,\mathsf{undefined},p)\cons\h,(\theta,\epsilon),q}\comp \Pi,
	\M; \mathsf{end}(\theta,\epsilon,\mathsf{undefined},p)\cons\s
}
}}								
	\end{array}
	\]
	\caption{Semantica reversibile forward} \label{fig:forwardsem1}
\end{figure}
~\\
Per dimostrare che la semantica forward $\rh$ estende la semantica standard $\hoo$ bisogna introdurre $ \del(s) $.
 Si può vedere che $ \del(s) $ denota il sistema risultante da $ s $ rimuovendo le cronologie dei processi; formalmente,
$\del(\Gamma;\Pi;\mathsf{M;S}) = \Gamma;\del'(\Pi);\M$, dove:
\[
\begin{array}{lll}
	\del'(\tuple{p,\h,(\theta,e),q}) & = &
	\tuple{p,(\theta,e),q}
	\\
	\del'(\tuple{p,\h,(\theta,e),q}\:\comp\:\Pi) & = &
	\tuple{p,(\theta,e),q}\:\comp\:\del'(\Pi)
	\\
\end{array}
\]
Si assume che $\Pi$ non sia vuoto. \\

\begin{theorem} \label{th:conservative}
	Sia $s_1$ un sistema nella semantica forward senza occorrenze di ``$\mathsf{check}$'' e $s'_1=\del(s_1)$ un sistema nella semantica standard. Allora, $s'_1 \hoo^\ast s'_2$ sse $s_1 \rh^\ast s_2$
	e $\del(s_2) = s'_2$.
\end{theorem}

\begin{proof}
	La dimostrazione avviene mostrando che le regole della semantica standard nelle Figure~\ref{fig:forwardsem} e \ref{fig:forwardsem1} sono la versione con la storia delle regole corrispondenti presenti nelle Figure~\ref{fig:system-rules} e \ref{fig:system-rules-map}. L'unico punto complicato è capire che l'introduzione dell'identificatore univoco nel messaggio non cambia il comportamento della regola $\mathit{Receive}$ poiché la funzione $\mathsf{matchrec}$ ha come risultato sempre l'occorrenza più vecchia (in termini di posizione nella coda) del messaggio selezionato \cite{Lanese}.
\end{proof}
In alcune delle regole di transizione della semantica backward, nelle side condition si richiederà che non siano presenti alcune delle regole di lettura o scrittura. 

 \begin{definition}[$\varepsilon$ e $\cancel{\varepsilon}$]\label{def:coinvolgimento}
	Per le operazioni sulla mappa si dice che $x ~ \varepsilon ~op$ se l'operazione coinvolge l'elemento $x$, cioè se l'operazione aggiunge, rimuove o legge $x$ dalla mappa. Si indica con $x~\cancel{\varepsilon}~op$ se l'operazione non coinvolge l'elemento $x$.
	Di seguito verrà mostrato l'elenco di come nella storia della mappa le regole vengono rappresentate e di quali sono gli elementi coinvolti.
\begin{itemize}
	\item se $op=\mathsf{regT}(\theta,e,a,p,p')$ allora $a ~\varepsilon~ \mathsf{regT}$, $p ~\varepsilon~ \mathsf{regT}$;% e $p'$ è il pid corrispondente al processo che esegue l'operazione
	\item se $op=\mathsf{unregT}(\theta,e,a,p,p')$ allora $a ~\varepsilon~ \mathsf{unregT}$, $p ~\varepsilon ~\mathsf{unregT}$;% e $p'$ è il pid corrispondente al processo che esegue l'operazione
	\item se $op=\mathsf{regF}(\theta,e,a,p,p')$ allora $a~ \varepsilon~ \mathsf{regF}$, $p~ \varepsilon~ \mathsf{regF}$;% e $p'$ è il pid corrispondente al processo che esegue l'operazione
	\item se $op=\mathsf{unregF}(\theta,e,a,p')$ allora  $a~ \varepsilon~ \mathsf{unregF}$;% e $p'$ è il pid corrispondente al processo che esegue l'operazione
	\item se $op=\mathsf{sendA}(\theta,e,p,\{v,\k\},a,p')$ allora $a ~\varepsilon~ \mathsf{sendA}$, $p~ \varepsilon~ \mathsf{sendA}$;% $p'$ è il pid corrispondente al processo che esegue l'operazione e la coppia $\{v,\k\}$ rappresenta il messaggio inviato
	\item se $op=\mathsf{sendF}(\theta,e,a,p')$ allora $a ~\varepsilon~ \mathsf{sendF}$; %e $p'$ è il pid corrispondente al processo che esegue l'operazione
	\item se $op=\mathsf{end}(\theta,e,p')$ allora $a~ \varepsilon~ \mathsf{end}$, $p' ~\varepsilon ~\mathsf{end}$;% e $p$ è il pid corrispondente al processo che esegue l'operazione, da notare che 
	\item se $op=\tau\mathsf{MM'}(\theta,e,p')$ allora $\forall~ p,a\in \mathsf{M'}; ~ p~\varepsilon ~ \tau\mathsf{MM'} \land a~\varepsilon ~ \tau\mathsf{MM'}$.\qed% e $p'$ è il pid corrispondente al processo che esegue l'operazione 
\end{itemize}
\end{definition}

\begin{definition}[Operazioni lettura e scrittura]\label{def:lettura-scrittura}
	
	Per la semantica standard si era detto che:
	\begin{itemize}
		\item per operazioni in scrittura si intendono le operazioni che modificano la mappa (cioè quelle regole che aggiungono o tolgono coppie alla mappa) e sono $\mathsf{RegisterT}$, $\mathsf{UnregisterT}$, $\mathsf{End}$.
		\item per operazioni in lettura si intendono le operazioni che  accedono alla mappa senza modificarla, e sono $\mathsf{SendA}$, $\mathsf{SendF}$, $\mathsf{RegisterF}$, $\mathsf{UnregisterF}$, $\mathsf{Call3}$.
	\end{itemize}
	Questo vale anche per la semantica forward. 
	Per la semantica backward invece:
	\begin{itemize}
		\item le operazioni in scrittura sulla mappa sono $\ol{\mathsf{RegisterT}}$, $\ol{\mathsf{UnregisterT}}$ e $\ol{\mathsf{End}}$. Da notare che anche queste operazioni vanno a modificare la mappa nel modo opposto alla regola forward corrispondente; 
		\item le operazioni in lettura sulla mappa nel caso della semantica backward sono $\ol{\mathsf{SendA}}$, $\ol{\mathsf{SendF}}$, $\ol{\mathsf{RegisterF}}$, $\ol{\mathsf{UnregisterF}}$ e $\ol{\mathsf{Call3}}$. 
		Queste vengono considerate come operazioni che leggono gli stessi elementi dell'operazione forward corrispondenti.\qed
	\end{itemize}
\end{definition}
Scegliere di dire che un'operazione all'indietro sia un'operazione in lettura è una scelta insolita, ma è dovuta al fatto che si vuole evitare un ``annullamento'' di un'operazione di lettura sulla mappa quando questa è stata modificata.
\begin{example}
	Se si considera il caso in cui la storia ha una forma:
	\begin{center}
		$\mathsf{RegT}(a,p);\mathsf{Call3}(a);\mathsf{unregT}(a)$
	\end{center}
	se fosse possibile fare un'operazione di annullamento di call3 ($\ol{\mathsf{Call3}(a)}$), allora si otterrebbe una storia
	\begin{center}
		$\mathsf{RegT}(a,p);\mathsf{unregT}(a)$
	\end{center}
	Però in questo modo si sarebbe annullata un'operazione di lettura sulla mappa dopo che questa è stata modificata, e si potrebbe riapplicare l'operazione $\mathsf{Call3}(a)$ che fallirebbe, o darebbe un risultato diverso, ottenendo una storia 
	\begin{center}
		$\mathsf{RegT}(a,p);\mathsf{unregT}(a);\mathsf{Call3}(a)$
	\end{center}
	In questo modo non si potrebbe far vedere che facendo operazioni di \textit{undo-redo} si ritornerebbe in uno stato equivalente, una proprietà importante che è auspicabile.
\end{example}

Nelle Figure \ref{fig:backwardsem} e \ref{fig:backwardsem1} sono presenti le regole di transizione della semantica backward.


\begin{figure}[ht]
	\footnotesize
	\[
	\begin{array}{lc}
		(\mathit{\ol{Seq}}) ~ {\displaystyle
			\Gamma;
			\tuple{p,\tau(\theta,e)\cons\h,(\theta',e'),q}
			\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
			\lh  \Gamma;\tuple{p,\h,(\theta,e),q}\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
		}\\[2ex]
		
				\mathcolorbox{yellow}{(\mathit{\ol{Call3}}) ~ {\displaystyle
				\begin{array}{l}
					\Gamma;
					\tuple{p,\tau\mathsf{MM'}(\theta,e,p)\cons\h,(\theta',e'),q}
					\:\comp\: \Pi;\mathsf{M;S' : \tau\mathsf{MM'}(\theta,e,p):S}
					\lh  \Gamma;\tuple{p,\h,(\theta,e),q}\:\comp\: \Pi;\mathsf{M;S'}\cons\mathsf{S}\\
					\mbox{Se in S' non sono presenti operazioni di scrittura su elementi presenti in M'}    
				\end{array}
		}}
		\\[3ex]
		
		(\mathit{\ol{Check}}) ~ {\displaystyle
			\Gamma;
			\tuple{p,\mathsf{check}(\theta,e,\mathtt{t})\cons\h,(\theta',e'),q}
			\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
			\lh  \Gamma;\tuple{p,\h,(\theta,e),q}\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
		} 
		\\[2ex]
		
		(\mathit{\ol{Send}}) ~ {\displaystyle
			\begin{array}{lc }
				\Gamma\cup\{(p'',\{v,\k\})\};\tuple{p,\mathsf{send}(\theta,e,p'',\{v,\k\})\cons\h,(\theta',e'),q}\:\comp\:
				\Pi;\mathcolorbox{yellow}{\mathsf{M;}\mathsf{S}}
				\lh \Gamma;\tuple{p,\h,(\theta,e),q} 
				\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}\\
				
			\end{array}
		}\\[2ex]
		
		\mathcolorbox{yellow}{(\mathit{\ol{SendA}}) ~ {\displaystyle
				\begin{array}{lc }
					\Gamma\cup\{(p'',\{v,\k\})\};\tuple{p,\mathsf{sendA}(\theta,e,p'',\{v,\k\},a,p)\cons\h,(\theta',e'),q}\:\comp\:
					\Pi;\mathsf{M;S'}\cons \mathsf{sendA}(\theta,e,p'',\{v,\k\},a,p)\cons\mathsf{S}\\
					\hspace{20ex}
					\lh \Gamma;\tuple{p,\h,(\theta,e),q} 
					\:\comp\: \Pi;\mathsf{M;S'}\cons\mathsf{S}\\
					Se ~ \forall ~ op ~ \mbox{in scrittura} \in \mathsf{S'} ~  a~\cancel{\varepsilon} ~op ~ \mathsf{o} ~ p''~\cancel{\varepsilon} ~op
				\end{array}
		}}\\[6ex]
		
		\mathcolorbox{yellow} {(\mathit{\ol{SendF}}) ~ {\displaystyle
				\begin{array}{lc }
					\Gamma;\tuple{p,\mathsf{sendF}(\theta,e,a,p)\cons\h,(\theta,sendFail),q}\:\comp\:
					\Pi;\mathsf{M;S'}\cons \mathsf{sendF}(\theta,e,a,p)\cons\mathsf{S}\\
					\hspace{20ex}
					\lh \Gamma;\tuple{p,\h,(\theta,e),q} 
					\:\comp\: \Pi;\mathsf{M;S'}\cons\mathsf{S}\\
					Se ~ \forall ~ op ~ \mbox{in scrittura} \in \mathsf{S'} ~  a~\cancel{\varepsilon} ~op
			\end{array}}
		}\\[6ex]
		
		(\mathit{\ol{Receive}}) ~ {\displaystyle
			\Gamma;\tuple{p,\mathsf{rec}(\theta,e,\{v,\k\},q)\cons\h,(\theta',e'), q\backslash\!\!\backslash\{v,\k\}}\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
			\lh  \Gamma;\tuple{p,\h,(\theta,e),q}\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
		}
		\\[2ex]
		
		(\mathit{\ol{Spawn}}) ~ {\displaystyle
			\begin{array}{l}
				\Gamma;\tuple{p,\mathsf{spawn}(\theta,e,p')\cons\h,(\theta',e'),q}
				\:\comp\: 
				\tuple{p',\nil,(\id,e''),\nil}
				\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}} 
				\\
				\hspace{20ex}\lh
				\Gamma;\tuple{p,\h,(\theta,e),q}
				\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}} 
			\end{array}
		}\\[5ex]
		
		(\mathit{\ol{Self}}) ~ {\displaystyle
			\Gamma;\tuple{p,\mathsf{self}(\theta,e)\cons\h,(\theta',e'),q} 
			\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}} \lh
			\Gamma;\tuple{p,\h,(\theta,e),q} 
			\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}  
		}\\[2ex]
		
		(\mathit{\ol{Sched}}) ~ {\displaystyle
			\begin{array}{l}
				\Gamma;\tuple{p,\h,(\theta,e),\{v,\k\}\cons q} \: \comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}} \lh 
				\Gamma\cup(p,\{v,\k\});\tuple{p,\h,(\theta,e),q}\:\comp\:\Pi;\mathcolorbox{yellow}{\mathsf{M;S}}\\
				\hspace{20ex}\mbox{if the topmost $\mathsf{rec}(\ldots)$ item in
					$\h$ (if any) has the}\\ 
				\hspace{20ex}\mbox{form}~\mathsf{rec}(\theta',e',\{v',\k'\},q')~\mbox{with}~q'\backslash\!\!\backslash\{v',\k'\}\neq \{v,\k\}\cons q
			\end{array}
		} \\[5ex]
		
	\end{array}
	\]
	\caption{Backward reversible semantics } \label{fig:backwardsem}
\end{figure}
Ora verranno discusse brevemente alcune situazioni particolari:
\begin{itemize}
	\item Innanzitutto, si osserva che la regola $\ol{\mathit{Send}}$ può essere applicata solo quando il messaggio inviato si trova nella mailbox globale. Se questo non è il caso (cioè il messaggio è stato consegnato usando la regola $\mathit{Sched}$), allora si dovranno prima applicare i passaggi a ritroso al processo del destinatario fino a che l'applicazione della regola $\ol{\mathit{Sched}}$ rimette il messaggio nella mailbox globale e la regola $\ol{\mathit{Send}}$ diventa applicabile. Ciò è necessario per garantire la coerenza causale. Nella sezione successiva, introdurremo una strategia particolare che ottiene questo effetto in modo controllato \cite{Lanese}.
\end{itemize}
\begin{itemize}
	\item Si può notare che la regola $\ol{\mathit{SendA}}$ (come la regola $\ol{\mathit{Send}}$) può essere applicata solo quando il messaggio inviato si trova nella mailbox globale, cioè il messaggio non è stato ancora consegnato usando la regola $\mathit{Sched}$. Inoltre, essendo un'operazione sulla mappa in lettura, si richiede che non siano presenti operazioni in scrittura sulla mappa eseguite successivamente che coinvolgono l'atomo $a$ o il pid $p$; questo è necessario per rispettare la coerenza causale.
\end{itemize}
\begin{itemize}
	\item La regola $\ol{\mathit{SendF}}$ è anch'essa in lettura sulla mappa, quindi per rispettare la consistenza causale verrà richiesto che non siano presenti operazioni in scrittura sulla mappa eseguite successivamente che coinvolgono l'atomo $a$.
\end{itemize}
\begin{itemize}
	\item La regola $\ol{\mathit{Call3}}$, come $\ol{\mathit{SendA}}$ e $\ol{\mathit{SendF}}$, è una regola in lettura sulla mappa, che però come side-condition richiede  che non ci siano operazioni in scrittura sulla mappa eseguite successivamente che coinvolgono atomi o pid presenti in $\M'$.
\end{itemize}
	\begin{itemize}
	\item Una situazione simile si verifica con la regola $\ol{\mathit{Spawn}}$. Dato un processo $ p $ con un elemento della cronologia $\mathsf{spawn}(\theta,e,p')$, la regola $ \ol{\mathit{Spawn}}$ non può essere applicata finché la cronologia e la coda del processo $ p '$ sono entrambi vuoti. Pertanto, si dovrebbe prima applicare una serie di passaggi all'indietro per elaborare $ p '$ in modo da poter annullare l'elemento $\mathsf{spawn}$.
	%
	Si noti che non è necessario richiedere che nessun messaggio indirizzato al processo $ p '$ (che diventerebbe un messaggio \emph{orfano}) sia nella mailbox globale: per inviare un tale messaggio il pid $ p' $ è necessario, quindi l'invio del messaggio dipende da $\mathsf {spawn}$ e di conseguenza deve essere annullato in anticipo \cite{Lanese}.
\end{itemize}
\begin{itemize}
	\item si osserva anche che la regola $\ol{\mathit{Receive}}$ può essere applicata solo quando la coda del processo è esattamente la stessa che è stata ottenuta dopo aver applicato il corrispondente passaggio $\mathit{Receive}$. Ciò è necessario per garantire che la coda ripristinata sia effettivamente quella giusta (notare che l'aggiunta del messaggio a una coda arbitraria non funzionerebbe poiché non si conosce la sua posizione ``giusta'') \cite{Lanese}.
\end{itemize}
\begin{itemize}
	\item L'applicazione della regola $\ol{\mathit{Sched}}$ può essere cambiata con l'applicazione di qualsiasi altra regola all'indietro eccetto $\ol{\mathit{Receive}}$ o un altro $\ol{\mathit{Sched}}$, poiché non interferisce con le regole rimanenti. È garantito il fatto che due $ \ol{\mathit{Sched}}$ che coinvolgono lo stesso processo non si spostino, poiché $\ol{\mathit{Sched}}$ si applica sempre al messaggio più recente di una coda. Il fatto che $\ol{\mathit{Sched}}$ e $\ol{\mathit{Receive}}$ non si spostino è garantito poiché la condizione secondaria di $\ol{\mathit{Sched}}$ controlla che non ci sia nessun elemento $\mathsf{rec}(\ldots)$ nella cronologia del processo che può essere utilizzato per applicare la regola $\ol{Receive}$ con la coda corrente. Pertanto, le loro condizioni di applicabilità non si sovrappongono \cite{Lanese}.
\end{itemize}

\begin{figure}[ht]
	\footnotesize
	\[
	\begin{array}{lc}
		
		\mathcolorbox{yellow}{ (\mathit{\ol{RegisterT}}) ~ {\displaystyle
				\begin{array}{l}	
					\Gamma;\tuple{p,\mathsf{regT}(\theta,e,a,p',p)\cons\h,(\theta',e'),q}\comp \Pi;\M\cup(a,p') ; \s'\cons\mathsf{regT}(\theta,e,a,p',p) \cons\s \\
					\hspace{20ex} \lh  \Gamma;\tuple{p,\h,(\theta,e),q}\:\comp\: \Pi;\M;\s'\cons\s\\
					Se ~ \forall ~ op ~ \mbox{in scrittura o lettura} \in \s' ~  a \cancel{\varepsilon} op ~ \mathsf{o} ~ p'~\cancel{\varepsilon}~op    
					\end{array}		
		}}
		\\[6ex]
		
		\mathcolorbox{yellow}{ (\mathit{\ol{RegisterF}}) ~ {\displaystyle
				\begin{array}{l}
					\Gamma;\tuple{p,\mathsf{regF}(\theta,e,a,p',p)\cons\h,(\theta,regFail),q}\comp \Pi;
					\M; \s'\cons\mathsf{regF}(\theta,e,a,p',p) \cons\s \\    
					\hspace{20ex} \lh  \Gamma;\tuple{p,\h,(\theta,e),q}\:\comp\: \Pi;\M;\s'\cons\s\\
					Se ~ \forall ~ op ~ \mbox{in scrittura} \in \s' ~  a~\cancel{\varepsilon} ~op ~ \mathsf{o} ~ p'~\cancel{\varepsilon}~op  
				\end{array}
		}}
		\\[6ex]
		
	\mathcolorbox{yellow}{ (\mathit{\ol{UnregisterT}}) ~ {\displaystyle
				\begin{array}{l}
					\Gamma;\tuple{p,\mathsf{unregT}(\theta,e,a,p',p)\cons\h,(\theta',e'),q}\comp \Pi; \M\backslash\!\!\backslash(a,p') ;
					\s'\cons\mathsf{unregT}(\theta,e,a,p',p)\cons\s \\
					\hspace{20ex}
					\lh  \Gamma;\tuple{p,\h,(\theta,e),q}\:\comp\: \Pi;\M;\s'\cons\s\\
					Se ~ \forall ~ op ~ \mbox{in scrittura o lettura} \in \s' ~  a~\cancel{\varepsilon}~op ~ \mathsf{o} ~ p'~\cancel{\varepsilon}~op
				\end{array}
		}}
		\\[6ex]
		
		\mathcolorbox{yellow}{ (\mathit{\ol{UnregisterF}}) ~ {\displaystyle
				\begin{array}{l}	
					\Gamma;\tuple{p,\mathsf{unregF}(\theta,e,a,p)\cons\h,(\theta,unregFail),q}\comp \Pi; \M; 
					\s'\cons\mathsf{unregF}(\theta,e,a,p) \cons\s  \\
					\hspace{20ex}  \lh  \Gamma;\tuple{p,\h,(\theta,e),q}\:\comp\: \Pi;\M;\s'\cons\s\\
					Se ~ \forall ~ op ~ \mbox{in scrittura} \in \s' ~  a~\cancel{\varepsilon}~op                  	
				\end{array}
				
		}}
		\\[5ex]
		
		\mathcolorbox{yellow}{ (\mathit{\ol{Catch}}) ~ {\displaystyle
				\begin{array}{l}
					\Gamma;\tuple{p,\mathsf{fail}(\theta,e)\cons\h,(\theta,fail),q}\comp \Pi; \M;\s
					\lh
					\Gamma;\tuple{p,\h,(\theta,e),q}\comp \Pi; \M;\s
				\end{array}	
		}}\\[3ex]
	
		\mathcolorbox{yellow}{ (\mathit{\ol{End}}) ~ {\displaystyle
			\begin{array}{l}
				\Gamma;\tuple{p,\mathsf{end}(\theta,\epsilon,a',p)\cons\h,(\theta,\epsilon),q}\comp \Pi,
				\M\backslash\!\!\backslash (a' ,p), \s'\cons\mathsf{end}(\theta,\epsilon,a',p)\cons\s
				\lh  \Gamma;\tuple{p,\h,(\theta,\epsilon),q}\:\comp\: \Pi;\M;\s'\cons\s\\
				Se ~ \forall ~ op ~ \mbox{in scrittura o lettura} \in \s' ~  a'~\cancel{\varepsilon}~op ~ \mathsf{o} ~ p~\cancel{\varepsilon}~op                  
			\end{array}		
	}}
	\end{array}
	\]
	\caption{Backward reversible semantics } \label{fig:backwardsem1}
\end{figure}

\begin{itemize}
	\item Le regole $\ol{\mathit{RegisterT}}$, $\ol{\mathit{RegisterF}}$, $\ol{\mathit{UnregisterT}}$ e $\ol{\mathit{End}}$ sono tutte in scrittura sulla mappa che annullano la corrispondente regola forward restituendo il controllo al processo (come tutte le altre regole). Essendo in scrittura sulla mappa richiederanno, prima di poter essere eseguite, l'annullamento di tutte le regole che coinvolgono atomi o pid  coinvolti dalla regola che si vuole annullare.
\end{itemize}
\begin{itemize}
	\item Anche $\ol{\mathit{UnregisterF}}$ è una regola in scrittura ma, al contrario delle altre, coinvolge solo un atomo (e non un pid) e quindi la sua side-condition richiederà solo che non siano presenti nella storia della mappa operazioni più recenti che coinvolgano l'atomo rimosso da $\ol{\mathit{UnregisterF}}$.
\end{itemize}

\subsection*{Proprietà della semantica reversibile incontrollata}
Di seguito verranno dimostate diverse proprietà della semantica reversibile mostrata precedentemente.
Dati i sistemi $s_1,s_2$ verrà indicata con $s_1\rh^\ast s_2$ una derivazione \emph {forward} e con $s_2\lh^\ast s_1$ una derivazione \emph {backward}.
La derivazione che potenzialmente include sia i passi avanti che quelli indietro è indicata da $s_1\rlh^\ast s_2$.
%
Si etichettano le transizioni come segue: $s_1\rlh_ {p, r, k} s_2$, dove:
\begin{itemize}
	\item $ p, r $ sono rispettivamente il pid del processo selezionato e l'etichetta della regola applicata,
	\item $ k $ è un elemento della cronologia se la regola applicata è diversa da $ \mathit {Sched} $ e $ \ol {\mathit {Sched}} $ e
	\item $ k = \mathsf {sched} (\{v, \k \}) $ quando la regola applicata è $ \mathit {Sched} $ o $ \ol {\mathit {Sched}} $, dove $ \{v, \ k \} $ è il messaggio consegnato o reinserito in $ \Gamma $. Si nota che le informazioni sono disponibili quando si applica la regola.
\end{itemize}
Si estendono le definizioni delle funzioni $ \init $ e $ \final $ date nella Sezione~\ref{sect:semantica} a derivazioni reversibili in modo naturale. Anche le nozioni di derivazione componibile, coiniziale e cofinale sono estese in modo semplice.
Data un'etichetta di regola $ r $, allora $\ol{r} $ denota la sua versione inversa, ovvero se $ r=\mathit{Send} $ allora $\ol{r}=\ol{\mathit {Send}}$ e viceversa (se $r=\ol{\mathit{Send}}$ allora $\ol{r}=\mathit{Send}$).
		%
Inoltre, data una transizione $ t $, si dice che $ \ol{t} =(s'\lh_{p, \ol{r},k} s) $ se $ t = (s \rh_ {p, r, k} s ') $ e che $ \ol {t} = (s' \rh_ {p, r, k} s) $ se $ t = (s \lh_ {p, \ol {r}, k} s ') $. Si dice che $ \ol {t} $ è \emph {inverso} di $ t $.
Questa notazione è naturalmente estesa alle derivazioni.
		
Di seguito si limita l'attenzione ai sistemi raggiungibili dall'esecuzione di un programma.

\begin{definition}[Sistema raggiungibile]\label{def:reachable}
	Un sistema è \emph{iniziale} se è composto da un singolo processo che ha una cronologia e una coda vuote; inoltre, anche la mailbox globale è vuota. Un sistema $s$ è raggiungibile se esiste un sistema iniziale $s_0$ e una derivazione $s_0 \rlh^\ast s$ utilizzando le regole corrispondenti a un dato programma.\qed
\end{definition}
Le definizioni e i lemmi successivi sono utilizzati per dimostrare che ogni transizione in avanti (risp. indietro) può essere annullata da una transizione all'indietro (risp. avanti), come dimostrato nel Lemma~\ref{lemma:loop} .

\begin{definition}[Equivalenza fra storie ($\equiv$)]\label{def:equivS}
Date due storie $\Hi= \Hi_1 : \Hi_2 : op :\Hi_3$ e $\Hi'= \Hi_1 : op : \Hi_2 : \Hi_3$ si dice che:
	\begin{itemize}
		\item se $op$ è un'operazione in lettura tale che $a ~ \varepsilon ~ op $ e $ p ~ \varepsilon ~ op$ e se per ogni  operazione in scrittura $op_1 \in \Hi_2$ vale che $a \cancel{\varepsilon} op_1 $ e $ p  \cancel{\varepsilon} op_1$, allora $\Hi \cong \Hi'$.
		\item se $op$ è un'operazione in scrittura tale che $a ~ \varepsilon ~ op $ e $ p ~ \varepsilon ~ op$ e se per ogni operazione in lettura o scrittura $op_1 \in \Hi_2$ vale che $a \cancel{\varepsilon} op_1 $ e $ p  \cancel{\varepsilon} op_1$, allora $\Hi \cong \Hi'$.
		
	\end{itemize} 
	La relazione di equivalenza fra due storie viene indicata col simbolo $\equiv$ ed è la chiusura transitiva e simmetrica della relazione $\cong$ \qed
\end{definition}
\begin{definition}[Trasposizione]
	Data una storia $h=\Hi_1 : \Hi_2 : op :\Hi_3$ e una storia $h'=\Hi_1 : op : \Hi_2 : \Hi_3$ tali per cui $h\cong h'$, si dice che è avvenuta la \textbf{trasposizione} di $op$ (con $\Hi_2$).   \qed 
\end{definition}
\begin{corollary}
	La relazione $\equiv$ fra due storie è anche riflessiva.
\end{corollary}
\begin{proof}
	Per vedere che una storia $h$ sia equivalente a se stessa si può sempre considerare $h = \Hi_1 : op : \Hi_2 :\Hi_3 $ con $\Hi_2 = [~]$ ($\Hi_2$ vuoto) e quindi si può mostrare che $\Hi_1 : op : [~] :\Hi_3 \cong \Hi_1 : [~]  : op :\Hi_3$ e quindi che $h \equiv h$
\end{proof}

\begin{lemma}\label{myCorollario0}
	Se $\Hi_1: op : \Hi_2 \cong \Hi_1': op : \Hi_2'$ con trasposizione di $op$, allora $\Hi_1: \Hi_2= \Hi_1': \Hi_2'$.
\end{lemma}
\begin{proof}
	Visto che è avvenuta la trasposizione di $op$ togliendo $op$ si ottiene una storia $\Hi_1: \Hi_2= \Hi_1': \Hi_2'$ dove non è presente nessuna trasposizione.
\end{proof}
\begin{lemma}\label{myCorollario1}
	Se $\Hi_1: op : \Hi_2 \cong \Hi_1': op : \Hi_2'$ con trasposizione di $op'\not=op$ con $\Hi_3$(dove $\Hi_3$ parte della storia), allora $\Hi_1: \Hi_2\cong \Hi_1': \Hi_2'$ mediante la trasposizione di $op'$ con $\Hi_3$ o con $\Hi_3$ senza $op$.
\end{lemma}
\begin{proof}
	~
	\begin{itemize}
		\item se $op\in \Hi_3$ la trasposizione di $op'$ con $\Hi_3$ senza $op$ è sempre possibile perché applicata su un sottoinsieme di $\Hi_3$ e quindi la Definizione~\ref{def:equivS} è sempre rispettata;  
		\item se $op\notin \Hi_3$ la trasposizione di $op'$ con $\Hi_3$ è la medesima. \qedhere
	\end{itemize}
\end{proof}

\begin{corollary}\label{myCorollario2}
	Se  $\Hi_1: op : \Hi_2 \cong \Hi_1': op : \Hi_2'$, allora $\Hi_1: \Hi_2\cong \Hi_1': \Hi_2'$.
\end{corollary}
\begin{proof}
	~
	\begin{itemize}
		\item se c'è trasposizione di $op$ per    Lemma~\ref{myCorollario0};  
		\item se non c'è trasposizione di $op$ per Lemma~\ref{myCorollario1}. \qedhere
	\end{itemize}
\end{proof}

\begin{lemma}\label{myCorollario3}
	Se  $\Hi_1: op : \Hi_2 \equiv \Hi_1': op : \Hi_2'$, allora $\Hi_1: \Hi_2\equiv \Hi_1': \Hi_2'$.
\end{lemma}
\begin{proof}
	Per induzione strutturale sull'albero di derivazione della chiusura contestuale la dimostrazione è:\\
	\begin{itemize}
		\item Caso Base:\\
		
		\begin{prooftree} 
			\hypo[]{\Hi_1:op:\Hi_2 \cong \Hi_1':op :\Hi_2'}
			% Conclusion
			\Infer1[]{\Hi_1:op:\Hi_2 \equiv \Hi_1':op :\Hi_2'}           
		\end{prooftree}
		~\\~\\
		
		Da $\Hi_1':op:\Hi_2' \cong \Hi_1:op :\Hi_2$, per il Corollario~\ref{myCorollario2} vale che $\Hi_1:\Hi_2 \cong \Hi_1':\Hi_2'$. Quindi si costruisce l'albero:\\ 
		
		\begin{prooftree} 
			\hypo[]{\Hi_1:\Hi_2 \cong \Hi_1':\Hi_2'}
			% Conclusion
			\Infer1[]{\Hi_1:\Hi_2 \equiv \Hi_1':\Hi_2'}           
		\end{prooftree}
		
		
		\item Caso Induttivo:\\
		\begin{itemize}
			\item caso riflessivo:\\
			
			\begin{prooftree} 
				\hypo[]{\Hi_1':op:\Hi_2' \equiv \Hi_1:op :\Hi_2}
				% Conclusion
				\Infer1[]{\Hi_1:op:\Hi_2 \equiv \Hi_1':op :\Hi_2'}           
			\end{prooftree}
			~\\~\\
			
			Per l'ipotesi induttiva su $\Hi_1':op:\Hi_2' \equiv \Hi_1:op :\Hi_2$ si ha $\Hi_1':\Hi_2' \equiv \Hi_1:\Hi_2$. Quindi si costruisce l'albero:\\
			
			\begin{prooftree} 
				\hypo[]{\Hi_1':\Hi_2' \equiv \Hi_1:\Hi_2}
				% Conclusion
				\Infer1[]{\Hi_1:\Hi_2 \equiv \Hi_1':\Hi_2'}           
			\end{prooftree}
			
			\item caso transitivo:\\
			
			\begin{prooftree} 
				\hypo[]{\Hi_1:op:\Hi_2 \equiv \Hi_1'':op:\Hi_2''}
				\hypo[]{\Hi_1'':op:\Hi_2'' \equiv \Hi_1':op:\Hi_2'}
				% Conclusion
				\Infer2[]{\Hi_1:op:\Hi_2 \equiv \Hi_1':op:\Hi_2'}           
			\end{prooftree}
			~\\~\\
			
			Per l'ipotesi induttiva su $\Hi_1:op:\Hi_2 \equiv \Hi_1'':op :\Hi_2''$ e\\ $\Hi_1'':op:\Hi_2'' \equiv \Hi_1':op :\Hi_2'$ si ha $\Hi_1:\Hi_2 \equiv \Hi_1'':\Hi_2''$ e $\Hi_1'':\Hi_2'' \equiv \Hi_1':\Hi_2'$. Quindi si costruisce l'albero:\\
			
			\begin{prooftree} 
				\hypo[]{\Hi_1:\Hi_2 \equiv \Hi_1'':\Hi_2''}
				\hypo[]{\Hi_1'':\Hi_2'' \equiv \Hi_1':\Hi_2'}
				% Conclusion
				\Infer2[]{\Hi_1:\Hi_2 \equiv \Hi_1':\Hi_2'}           
			\end{prooftree} \qedhere
		\end{itemize}
			\end{itemize}
\end{proof}

Due processi nella forma $\tuple{p,\h,(\theta,e),q}$ sono equivalenti se tutti gli elementi sono uguali (la lista $\h$ di operazioni deve essere uguale perché altrimenti i processi avrebbero fatto operazioni diverse e quindi non sarebbero uguali).

\begin{definition} [Equivalenza fra sistemi ($\equiv$)]\label{def:equiv} Due sistemi $s_1 = (\Gamma_1,\Pi_1,\M_1,\Hi) $ e $s_2 = (\Gamma_2,\Pi_2,\M_2,\Hi')$ sono equivalenti se: 
	\begin{itemize}
		\item $\Gamma_1 = \Gamma_2$
		\item $ \Pi_1 = \Pi_2$
		\item $ \M_1 = \M_2$
		\item $ \Hi \equiv \Hi' $ 
	\end{itemize}
	Due sistemi $s_1, s_2$ equivalenti vengono  indicati con $s_1 \equiv s_2$.\qed
\end{definition}

\begin{lemma} \label{lemma:my3}
	Dato un sistema $s$ con storia $h = \Hi_2~op~\Hi_1 $ in cui è possibile applicare $\ol{op}$, e un sistema $s'\equiv s$ con storia	$h' = \Hi_2'~op~\Hi_1' $,  allora  è possibile applicare $\ol{op}$ a $s'$. 
\end{lemma}
\begin{proof}
	In $s$ è possibile applicare $\ol{op}$ quindi:
	\begin{itemize}
		\item se $\ol{op}$ è in lettura e $a~\varepsilon~\ol{op}$ e $p~\varepsilon~\ol{op}$, allora in $\Hi_2$ non sono presenti operazioni in scrittura tali che $a~\varepsilon~op_1$ o $p~\varepsilon~op_1$;
		\item se $\ol{op}$ è in scrittura e $a~\varepsilon~\ol{op}$ e $p~\varepsilon~\ol{op}$, allora in $\Hi_2$ non sono presenti operazioni in scrittura o lettura tali che $a~\varepsilon~op_1$ o $p~\varepsilon~op_1$.
	\end{itemize}
	Visto che $s\equiv s'$ allora anche $h\equiv h'$ per la Definizione~\ref{def:equiv}.
	Per applicare $\ol{op}$ in $s'$ bisogna che le side-condition della regola vengano rispettate in $h'$ e quindi che:
	\begin{itemize}
		\item se $\ol{op}$ è in lettura e $a~\varepsilon~\ol{op}$ e $p~\varepsilon~\ol{op}$,  allora in $\Hi_2'$ non devono essere presenti operazioni in scrittura tali che $a~\varepsilon~op_1$ o $p~\varepsilon~op_1$;
		\item se $\mathsf{\ol{op}}$ è in scrittura e $a~\varepsilon~\ol{op}$ e $p~\varepsilon~\ol{op}$,  allora in $\Hi_2'$ non devono essere presenti operazioni in scrittura o lettura tali che $a~\varepsilon~op_1$ o $p~\varepsilon~op_1$;
	\end{itemize}
	questo è rispettato in entrambi i casi per la Definizione~\ref{def:equivS} (di equivalenza fra storie) visto che è possibile applicare $\ol{op}$ in $s$, allora non ci possono essere trasposizioni in $h'$ che violino le side-condition della regola $\ol{op}$, e quindi è possibile applicare $\ol{op}$ a $s'$. 
\end{proof}

\begin{lemma} \label{lemma:my4}
	
	Dato un sistema $s_1$ con storia $h = \Hi_2~op~\Hi_1$ in cui è possibile applicare $\ol{op}$ ottenendo $s_1'$, e un sistema $s_2\equiv s_1$ con  storia $h' = \Hi_2'~op~\Hi_1'$, allora applicando $\ol{op}$ a $s_2$ si ottiene un sistema $s_2'\equiv s_1'$.
\end{lemma}
\begin{proof}
	Per il Lemma~\ref{lemma:my3} è possibile applicare $\ol{op}$ anche ad $s_2$. \\
	Applicando $\ol{op}$ a $s_1$ si ottiene $s_1'$ con storia $\Hi_2:\Hi_1$, mentre applicando $\ol{op}$ a $s_2$  si ottiene $s_2'$ con storia $\Hi_2':\Hi_1'$.\\
	Per il Lemma~\ref{myCorollario3} si vede che $\Hi_2:\Hi_1\equiv\Hi_2':\Hi_1'$ e quindi che $s_1'\equiv s_2'$.
\end{proof}

\begin{lemma}\label{lemma:my1}
	Se $s_1 \equiv s_1' $ e $ s_1 \rlh_ {p, r, k} s_2$ allora $\exists~s_2'$  t.c. $s_2\equiv s_2'$  e $s_1' \rlh_ {p, r, k} s_2'$. Graficamente:
		\[
	\begin{minipage}{50ex}
		\xymatrix@C=50pt@R=20pt{
			s_1 \ar@<1pt>@^{->}[r]^{p,r,k}  & s_2 \ar@<1pt>@^{->}[l]\\
			s_1' & 
		}
	\end{minipage}
	~~
	\Longrightarrow
	~~
	\begin{minipage}{50ex}
	\xymatrix@C=50pt@R=20pt{
		s_1 \ar@<1pt>@^{->}[r]^{p,r,k}  & s_2 \ar@<1pt>@^{->}[l]\\
		s_1'  \ar@<1pt>@^{->}[r]^{p,r,k}& s_2' \ar@<1pt>@^{->}[l]
	}
\end{minipage}
	\]
\end{lemma}
\begin{proof}
	La dimostrazione si divide in due parti:
	\begin{itemize}
		\item se $r$ è forward la dimostrazione si divide in due casi:
		\begin{itemize}
			\item nel caso l'operazione non sia sulla mappa è facile mostrare che  applicando a $s_1'$  la stessa transizione applicata a $s_1$, questo muova in uno stato $s_2'$ equivalente a $s_2$.  Se la modifica effettuata al sistema è la stessa, allora anche $\Gamma $ e $\Pi$ saranno uguali a quelli di $s_2$ e, non essendo stata modificata la mappa, allora anch'essa e la sua storia saranno equivalenti;
			\item nel caso l'operazione sia sulla mappa invece per dimostrare l'equivalenza di $s_2$ e $s_2'$ bisognerà mostrare l'equivalenza fra le storie dei due sistemi.\\
			In questo caso si sa che la storia di $s_1$ indicata con $\Hi_1$ è equivalente alla storia di $s_1'$ indicata con $\Hi_1'$. Inoltre, si sa anche che applicando a $s_1'$ la regola $r$ si muoverà in $s_2'$ con storia $\Hi_2'= \Hi_1' : op$. Applicando la regola a $s_1$ si muoverà in uno stato $s_2$ con storia $\Hi_2 = \Hi_1 : op$. È facile notare che $\Hi_2 \equiv \Hi_2'$ visto che $\Hi_1 \equiv \Hi_1'$ ed è stato aggiunto alla fine della storia lo stesso elemento;
		\end{itemize}
		\item se $r$ è backward la dimostrazione si divide in due casi:
		\begin{itemize}
			\item nel caso l'operazione non sia sulla mappa se si applica la stessa regola backward a due sistemi equivalenti, allora muoveranno in due sistemi equivalenti visto che le modifiche al sistema sono le stesse (la mappa e la sua storia non vengono modificate e per questo rimarranno equivalenti);
			\item nel caso l'operazione sia sulla mappa per il Lemma~\ref{lemma:my3} è possibile applicare a $s_1'$ la regola backward $r$. L'equivalenza di $s_2$ e $s_2'$ si può vedere grazie al Lemma~\ref{lemma:my4}. \qedhere
		\end{itemize}
	\end{itemize}
\end{proof}

\begin{lemma}[Loop lemma] \label{lemma:loop} Per ogni coppia di sistemi raggiungibili,
	$s_1$ e $s_2$, si ha $s_1 \rh_{p,r,k} s_2$ sse esiste $s_1'$, $s_2
	\lh_{p,\ol{r},k} s_1'$ tale per cui  $s_1\equiv s_1'$. Graficamente:
	\[
	\begin{minipage}{50ex}
		\xymatrix@C=50pt@R=20pt{
			s_1 \ar@<1pt>@^{->}[r]^{p,r,k}  & s_2 \\
		}
	\end{minipage}
	~~
	\Longleftrightarrow
	~~
	\begin{minipage}{50ex}
		\xymatrix@C=50pt@R=20pt{
			s_1 \equiv s_1'   & s_2 \ar@<1pt>@^{->}[l]^{p,r,k}\\
		}
	\end{minipage}
	\]
\end{lemma}
\begin{proof}
	La prova è l'analisi dei casi sulla regola applicata. 
	Di seguito verranno discussi i casi più interessanti.
	\begin{itemize}
		\item Regola forward sulla mappa: in questo caso è possibile applicare successivamente la regola backward corrispondente perché vengono rispettate tutte le condizioni richieste, essendo l'ultima regola applicata alla mappa è quella forward. In questo caso si può facilmente vedere che si torna allo stato originale.
		\item  Regola backward sulla mappa: in questo caso se si può applicare la regola backward vuol dire che sono rispettate tutte le condizioni richieste dalla regola. Al sistema quindi sarà possibile applicare la regola forward successivamente tornando ad uno stato equivalente al precedente. Questo perché, se sono state rispettate le condizioni imposte dalla regola, allora nella storia:
		\begin{itemize}
			\item se la regola di backward è in lettura, allora non sono presenti operazioni in scrittura che coinvolgono gli stessi atomi o pid coinvolti dalla regola forward, 
		 
		 	\item se la regola è in scrittura, allora nella storia non sono presenti operazioni in scrittura o lettura che coinvolgono gli stessi atomi o pid coinvolti dalla regola forward. \qedhere
		\end{itemize}
	\end{itemize}
\end{proof}


\begin{definition}[Transizioni concorrenti] \label{def:concurrent}
	Due transizioni coiniziali, $t_1 = (s \rlh_{p_1,r_1,k_1} s_1)$
	e $t_2 = (s \rlh_{p_2,r_2,k_2} s_2)$, vengono definite
	\emph{in conflitto} se almeno una delle seguenti condizioni sussiste:
	\begin{itemize}
		\item \textbf{entrambe le transizioni sono forward}, considerano lo stesso processo, cioè $p_1 = p_2$, e $r_1 = r_2 = \mathit{Sched}$ o una transizione applica la regola $\mathit{Sched} $ e l'altra la regola $\mathit{Receive}$.

		\item le regole viste nella Tabella~\ref{tab:conflitti} presente nella Definizione~\ref{def:concurrent1} 

		\item una è una transizione \textbf{forward} che si applica a un processo $\mathrm{p}$, si definisce $ p_1 = \mathrm{p}$, e l'altra è una transizione \textbf{backward} che annulla la creazione di $\mathrm{p}$, ovvero $p_2 = \mathrm{p}'\neq\mathrm{p} $, $r_2 = \ol{\mathit{Spawn}}$ e $ k_2 = \mathsf{spawn}(\theta, e, \mathrm{p})$ per qualche controllo $(\theta, e)$;

		\item una è una transizione \textbf{forward} che consegna un messaggio $ \{v, \k \} $ a un processo $\mathrm{p} $, si definisce $ p_1 = \mathrm{p} $, $ r_1 = \mathit{Sched} $ e $ k_1 = \mathsf {sched} (\{v, \ k \})$, e l'altra è una transizione \textbf{backward} che annulla l'invio di $ \{v, \ k \} $ a $ \mathrm {p} $, ovvero $ p_2 = \mathrm{p} '$ (nota che $ \mathrm {p} = \mathrm {p}' $ se il messaggio viene inviato a se stessi), $ r_2 = \ol{\mathit{Send}} $ e $ k_2 = \mathsf{send (\theta, e, \mathrm {p}, \{v, \ k \})} $ per qualche controllo $ (\theta, e) $;
	
		\item una è una transizione \textbf {forward} e l'altra è \textbf{backward} tale che $ p_1 = p_2 $ e i) entrambe le regole applicate sono diverse sia da $ \mathit{Sched} $ che da $ \ol{\mathit{Sched}} $, ovvero $ \{r_1, r_2 \} \cap\{\mathit{Sched}, \ol {\mathit {Sched}} \} = \emptyset $; ii) una regola è $ \mathit {Sched} $ e l'altra è $ \ol {\mathit {Sched}} $; iii) una regola è $ \mathit {Sched} $ e l'altra è $ \ol{\mathit {Receive}} $; o iv) una regola è $ \ol{\mathit{Sched}} $ e l'altra è $ \mathit {Receive} $.			

		
		\item nel caso in cui entrambe le transizioni siano sulla mappa, se queste accedono ad uno stesso pid o atomo e se una delle due è in scrittura sulla mappa (se entrambe le transizioni sono in lettura il conflitto non è presente);
		\item nel caso in cui entrambe le transizioni siano sulla mappa e una transizione sia \textbf{forward} e l'altra \textbf{backward} i casi di conflitto si vedono nella Tabella~\ref{tab:conflitti1} %tali per cui:%vedere tabella se non è precisamente sotto.
		
		\begin{table}[h!]
			\hspace{-17ex}
			\begin{tabular}{@{}|l|l|l|l|l|l|l|l|l|@{}}
				\hline
				\backslashbox{$~r_1~~$} {$~~r_2~$} &  $\ol{\mathsf{RegisterT}}$&  $\ol{\mathsf{UnregisterT}}$& $\ol{\mathsf{End}}$ & $\ol{\mathsf{SendA}}$ & $\ol{\mathsf{SendF}}$ & $\ol{\mathsf{RegisterF}}$ & $\ol{\mathsf{UnregisterF}}$ & $\ol{\mathsf{Call3}}$ \\ \hline
				$\mathsf{RegisterT}$   &       & \begin{tabular}[c]{@{}l@{}}$a'=a'' ~\lor$ \\ $ p' =p''$ \end{tabular}              &      \begin{tabular}[c]{@{}l@{}}$a'=a'' ~\lor$ \\ $ p' =p''$ \end{tabular}     &       &   $a' = a''$    &     &      $a' = a''$       & \begin{tabular}[c]{@{}l@{}}$a'  \in \M' ~\lor$ \\ $ p' \in \M'$\end{tabular}        \\ \hline
				
				$\mathsf{UnregisterT}$ &    \begin{tabular}[c]{@{}l@{}}$a'=a'' ~\lor$ \\ $ p' =p''$ \end{tabular}    &             &           &   \begin{tabular}[c]{@{}l@{}}$a'=a'' ~\lor$ \\ $ p' =p''$ \end{tabular}    &  &  \begin{tabular}[c]{@{}l@{}}$a'=a'' ~\lor$ \\ $ p' =p''$ \end{tabular}   &             &               \begin{tabular}[c]{@{}l@{}}$a'  \in \M' ~\lor$ \\ $ p' \in \M'$\end{tabular}                 \\ \hline
				
				$\mathsf{End}$         &    \begin{tabular}[c]{@{}l@{}}$a'=a'' ~\lor$ \\ $ p' =p''$ \end{tabular}    &             &           &   \begin{tabular}[c]{@{}l@{}}$a'=a'' ~\lor$ \\ $ p' =p''$ \end{tabular}    &  &  \begin{tabular}[c]{@{}l@{}}$a'=a'' ~\lor$ \\ $ p' =p''$ \end{tabular}   &             &               \begin{tabular}[c]{@{}l@{}}$a'  \in \M' ~\lor$ \\ $ p' \in \M'$\end{tabular}                 \\ \hline
				
				$\mathsf{SendA}$       &   \begin{tabular}[c]{@{}l@{}}$a'=a'' ~\lor$ \\ $ p' =p''$ \end{tabular}    &            &           &       &       &                          &                                  &                                \\ \hline
				
				$\mathsf{SendF}$       &       &          $a'=a''$    &      $a'=a''$      &       &                            &                          &                                  &                                \\ \hline
				
				$\mathsf{RegisterF}$   &  \begin{tabular}[c]{@{}l@{}}$a'=a'' ~\lor$ \\ $ p' =p''$ \end{tabular}     &             &           &                            &                            &                          &                                  &                                \\ \hline
				
				$\mathsf{UnregisterF}$ &       &    $a'=a''$         &   $a'=a''$                              &                            &                            &                          &                                  &                                \\ \hline
				
				$\mathsf{Call3}$       &     \begin{tabular}[c]{@{}l@{}}$a'  \in \M' ~\lor$ \\ $ p' \in \M'$\end{tabular}  &                 \begin{tabular}[c]{@{}l@{}}$a'  \in \M' ~\lor$ \\ $ p' \in \M'$\end{tabular}                 &          \begin{tabular}[c]{@{}l@{}}$a'  \in \M' ~\lor$ \\ $ p' \in \M'$\end{tabular}                      &                            &                            &                          &                                  &                                \\ \hline
			\end{tabular}
			\caption{\label{tab:conflitti1} Tabella dei conflitti per le regole forward-backward, nel caso delle regole backward-backward non è presente una tabella perchè non è presente il conflitto fra due operazioni backword.}
		\end{table}
		
		Nella Tabella~\ref{tab:conflitti1} sono presenti i casi in cui si verificano i conflitti; $a'$ e $p'$ rappresentano l'atomo e il pid coinvolti da $r_1$, mentre $a''$ e $p''$ rappresentano l'atomo e il pid coinvolto da $r_2$. $\M'$ rappresenta gli elementi letti nella mappa dalla regola $\mathsf{Call3}$ o $\ol{\mathsf{Call3}}$. Le celle vuote rappresentano transizioni coiniziali che non vanno in conflitto.\\
		Si nota che esistono coppie di operazini in scrittura che non sono in conflitto visto che nei casi in cui sarebbe presente il conflitto queste operazioni non possono essere coiniziali. 
		%Da notare che anche in questo caso, non tutte le operazioni in scrittura sulla mappa sono in conflitto fra di loro; questo perché in quei casi le transizioni non possono essere coiniziali e in conflitto. 
	\end{itemize}
	%
	Due transizioni coiniziali sono \emph{concorrenti} se non sono in conflitto. Si può notare che due transizioni backward coiniziali non sono mai in conflitto. \qed
\end{definition}
%
Il seguente lemma è la controparte del Lemma~\ref{lemma:square} per la semantica standard.

\begin{lemma}[Square lemma] \label{lemma:square} Date due operazioni coiniziali concorrenti $t_1 = (s \rlh_{p_1,r_1,k_1} s_1)$ e
	$t_2 = (s \rlh_{p_2,r_2,k_2} s_2)$, allora esistono due transizioni $t_2/t_1 = (s_1 \rlh_{p_2,r_2,k_2} s')$,
	$t_1/t_2 = (s_2 \rlh_{p_1,r_1,k_1} s'')$ tali per cui $s' \equiv s''$.  Graficamente,
	\[
	\begin{minipage}{50ex}
		\xymatrix@C=50pt@R=20pt{
			s \ar@<1pt>@^{->}[r]^{p_1,r_1,k_1} \ar@<1pt>@^{->}[d]_{p_2,r_2,k_2} & s_1 \ar@<1pt>@^{->}[l]\\
			s_2 \ar@<1pt>@^{->}[u]& 
		}
	\end{minipage}
	~~
	\Longrightarrow
	~~
	\begin{minipage}{50ex}
		\xymatrix@C=50pt@R=20pt{
			s \ar@<1pt>@^{->}[r]^{p_1,r_1,k_1} \ar@<1pt>@^{->}[d]_{p_2,r_2,k_2} & s_1 \ar@<1pt>@^{->}[d]^{p_2,r_2,k_2} \ar@<1pt>@^{->}[l]\\
			s_2 \ar@<1pt>@^{->}[r]_{p_1,r_1,k_1} \ar@<1pt>@^{->}[u] & s'' \equiv s' ~~~~~~ \ar@<1pt>@^{->}[u] \ar@<1pt>@^{->}[l]
		}
	\end{minipage}
	\]
\end{lemma}

\begin{proof}
	Si distinguono i seguenti casi a seconda delle regole applicate: \\ [1ex]
	(1) Due transizioni forward. Quindi, si hanno i seguenti casi:
	\begin{itemize}
		\item $r_1= \mathsf{End}$ e $r_2=\mathsf{RegisterF}$ nel caso in cui %(accedono a pid e atomi diversi) 
		$a~\varepsilon~r_1$, $p_1~\varepsilon~r_1$, $a'~\varepsilon~r_2$ e $p'~\varepsilon~r_2$ dove $a$ e $a'$ sono atomi e $p'$ è un pid:
		\begin{itemize}
			\item se $a\not= a'$ e $p_1 \not= p'$, allora si nota che applicando prima la transizione $t_1$ e poi la $t_2$ o viceversa si arriva in due stati rispettivamente $s'$ e $s''$ che sono equivalenti. Questo perché la mappa è la stessa mentre la storia della mappa differisce per gli ultimi elementi che sono scambiati. Visto che $a\not= a'$ e $p_1 \not= p'$ viene rispettata la Definizione~\ref{def:equivS} (equivalenza fra storie) e quindi $s'\equiv s''$. 
			\item  se $a= a'$ o $p_1 = p'$ le due operazioni sono in conflitto (vedere Tabella~\ref{tab:conflitti}).
		\end{itemize}
		\item questo ragionamento si può effettuare su tutte le regole sulla mappa 
	\end{itemize}
	(2) Una transizione forward e una backward. Quindi, si distnguono i seguenti casi:
	\begin{itemize}
		\item $r_1 = \mathsf{RegisterT}$ e $r_2= \mathsf{\ol{UnregisterT}}$ nel caso in cui %(accedono a pid e atomi diversi) 
		$a~\varepsilon~r_1$, $p~\varepsilon~r_1$, $a'~\varepsilon~r_2$ e $p'~\varepsilon~r_2$, dove $a$ e $a'$ sono atomi e $p$ e $p'$ sono pid:
		\begin{itemize}
			\item se $a\not= a'$ e $p \not= p'$, allora applicando prima la transizione $t_1$ e poi $t_2$ o viceversa si ottengono due transizioni $t_1/t_2$ e $t_2/t_1$ che finiscono in due stati equivalenti (la storia della mappa sarà la stessa sia in $s'$ che in $s''$).
			\item se $a= a'$ o $p = p'$ le due operazioni sono in conflitto (vedere Tabella~\ref{tab:conflitti1}).
		\end{itemize}
		\item questo ragionamento si può effettuare su tutte le regole sulla mappa 
	\end{itemize}
	(3) Due transizioni backward. Quindi, si distinguono i seguenti casi:
	\begin{itemize}
		\item Nel caso di due operazioni sulla mappa (o anche in cui solo una è sulla mappa), è sempre verificato: 
		\begin{itemize}
			\item nel caso in cui entrambe le operazioni backward sono sulla mappa, allora le condizioni di entrambe le regole sono rispettate, quindi sarà indifferente applicare prima una o l'altra (la storia della mappa sarà la stessa sia in $s'$ che in $s''$).
			\item nel caso in cui una regola è sulla mappa e l'altra no, allora le condizioni di entrambe le regole sono rispettate; applicare prima la regola sulla mappa o prima la regola non sulla mappa non cambia il risultato (la storia della mappa sarà la stessa sia in $s'$ che in $s''$). \qedhere
		\end{itemize}
	\end{itemize}
\end{proof}

\begin{lemma}[Confluenza] \label{lemma:square*} Date due operazioni coiniziali concorrenti $t_1 = (s \rlh^* s_1)$ e
	$t_2 = (s \rlh^* s_2)$, allora $t_2/t_1^* = (s_1 \rlh^* s')$,
	$t_1/t_2^* = (s_2 \rlh* s'')$ tali per cui $s' \equiv s''$.  Graficamente,
	\[
	\begin{minipage}{50ex}
		\xymatrix@C=50pt@R=20pt{
			s \ar@<1pt>@^{->}[r]^{*} \ar@<1pt>@^{->}[d]_{*} & s_1 \ar@<1pt>@^{->}[l]\\
			s_2 \ar@<1pt>@^{->}[u]& 
		}
	\end{minipage}
	~~
	\Longrightarrow
	~~
	\begin{minipage}{50ex}
		\xymatrix@C=50pt@R=20pt{
			s \ar@<1pt>@^{->}[r]^{*} \ar@<1pt>@^{->}[d]_{*} & s_1 \ar@<1pt>@^{->}[d]^{*} \ar@<1pt>@^{->}[l]\\
			s_2 \ar@<1pt>@^{->}[r]_{*} \ar@<1pt>@^{->}[u] & s'' \equiv s' ~~~~~~ \ar@<1pt>@^{->}[u] \ar@<1pt>@^{->}[l]
		}
	\end{minipage}
	\]
\end{lemma}
\begin{proof}
	Per il Lemma~\ref{lemma:my1} è possibile applicare una stessa regola a stati equivalenti e ottenere due stati equivalenti. Quindi è possibile iterare più volte il Lemma \ref{lemma:square} a stati equivalenti. Formalmente la prova avviene per induzione sul numero di passi e poi applicando il Lemma~\ref{lemma:my1} e \ref{lemma:square}, $m$ volte (dove $m$ è il numero di passi su cui non si è fatta induzione). \\
La dimostrazione è per induzione sul numero di passi:
\begin{itemize}
	\item Caso base:
	\[
	\begin{minipage}{50ex}
		\xymatrix@C=50pt@R=20pt{
			s \ar@<1pt>@^{->}[r]^{m} \ar@<1pt>@^{->}[d]_{0} & s_1 \ar@<1pt>@^{->}[d]^{0} \ar@<1pt>@^{->}[l]\\
			s \ar@<1pt>@^{->}[r]_{m} \ar@<1pt>@^{->}[u] & s_1 \ar@<1pt>@^{->}[u] \ar@<1pt>@^{->}[l]
		}
	\end{minipage}
	\]
	\item Caso induttivo ($n+1$)
	\[
	\begin{minipage}{50ex}
		\xymatrix@C=50pt@R=20pt{
			s \ar@<1pt>@^{->}[r]^{m} \ar@<1pt>@^{->}[d]_{n} & s_1 \ar@<1pt>@^{->}[d]^{n} \ar@<1pt>@^{->}[l]\\
			i \ar@<1pt>@^{->}[r]_{m} \ar@<1pt>@^{->}[u] \ar@<1pt>@^{->}[d] & i'' \equiv i' ~~~~~~ \ar@<1pt>@^{->}[u]  \ar@<1pt>@^{->}[d]^{1}\ar@<1pt>@^{->}[l]\\
			s_2 \ar@<1pt>@^{->}[r] \ar@<1pt>@^{->}[u]^{1}   & s'' \equiv s' ~~~~~\ar@<1pt>@^{->}[u] \ar@<1pt>@^{->}[l]^{m} 
		}
	\end{minipage}
	\]
	\[
	\begin{minipage}{50ex}
		\xymatrix@C=50pt@R=20pt{
			i \ar@<1pt>@^{->}[r]^{1} \ar@<1pt>@^{->}[d]_{1} & i_1 \ar@<1pt>@^{->}[d]_{1} \ar@<1pt>@^{->}[l] \ar@<1pt>@^{->}[r]^{1} \ar@<1pt>@^{->}[d]\ar@<1pt>@^{->}[l]& \dots \ar@<1pt>@^{->}[r]^{1} \ar@<1pt>@^{->}[d] \ar@<1pt>@^{->}[d]_{1}\ar@<1pt>@^{->}[l]& i''\equiv i'~~~~ \ar@<1pt>@^{->}[d]_{1} \ar@<1pt>@^{->}[l]\\
			s_2 \ar@<1pt>@^{->}[r]_{1} \ar@<1pt>@^{->}[u] & i_1'\equiv i_1''~~~ \ar@<1pt>@^{->}[u] \ar@<1pt>@^{->}[l] \ar@<1pt>@^{->}[r]_{1} & \dots \ar@<1pt>@^{->}[u] \ar@<1pt>@^{->}[u] \ar@<1pt>@^{->}[l] \ar@<1pt>@^{->}[r]_{1} & s''\equiv s' ~~~~~\ar@<1pt>@^{->}[u] \ar@<1pt>@^{->}[l] 
		}
	\end{minipage}
	\] \qedhere
\end{itemize}
\end{proof}
\section{Semantica rollback}\label{sect:semrollback}

In questa sezione verrà introdotto un'operatore di rollback che avvia un calcolo reversibile per un processo.
L'operazione di annullamento (non deterministica) ha alcune somiglianze con l'operatore di rollback di \cite{LMSS11, GLM14}.
I processi vengono messi in modalità di ``rollback'' utilizzando $\lfloor ~ \rfloor_\Psi$, dove $ \Psi $ è l'insieme di rollback. 
Un tipico rollback si riferisce a un checkpoint che deve essere superato da una computazione backward del processo prima di riprendere una computazione forward.
Per essere precisi, si distinguono le seguenti tipologie di rollback:

\begin{itemize}
	\item $\#_\mathsf{ch}^\mathtt{t}$, dove ``$\mathsf{ch}$'' sta per ``checkpoint'': un rollback per annullare le azioni di un processo fino a che non ha raggiunto il checkpoint con identificatore $\mathtt {t}$;
	\item $\#_\mathsf{sp}$, dove ``$ \mathsf{sp}$'' sta per ``spawn'': un rollback per annullare \emph{tutte} le azioni di un processo, infine cancellandolo dal sistema;
	\item $ \#_\mathsf {sch}^{\k}$, dove ``$\mathsf{sch}$'' sta per ``sched'': un rollback per annullare le azioni di un processo fino a che la consegna di un messaggio, nella forma $\{v, \k \}$, non è annullata.
	\item $\#_\mathsf{op}^\mathtt{par}$: richiede un rollback per annullare le azioni di un processo fino a quando non viene raggiunto l'operatore con identificatore $\mathtt{op(par)}$;
	\item $\#_\mathsf{([a],[p]),t}^\mathsf{S'}$: si applica ad un insieme di processi $\Pi$, 
	\begin{itemize}
		\item se $S'=\emptyset$ allora $\lfloor\Pi\rfloor_{\#_\mathsf{([a],[p]),t}^\emptyset} = \Pi$
		\item se $S'\not=\emptyset$ allora $\lfloor\Pi\rfloor_{\#_\mathsf{([a],[p]),t}^{\mathsf{S'}}} = \lfloor\Pi'\rfloor_{\#_\mathsf{([a],[p]),t}^{\mathsf{S''}}}$ dove $\mathsf{S'} = op(par):\mathsf{S''}$ e dove:
		\begin{itemize}
			\item se $a \centernot\varepsilon op(par)$ e $p \centernot\varepsilon op(par)$ allora $\Pi' = \Pi$
			\item se $a~ \varepsilon~op(par)$ o $p ~\varepsilon~op(par)$ allora $\Pi' = \Pi~\cup~\{newproc\}~\backslash~\{proc\}$ dove:
			\begin{itemize}
				\item $proc = \lfloor\tuple{p',(\theta,e),q,h}\rfloor_{\Psi} \in \Pi$ (è il processo che ha eseguito l'operazione $op(par)$ che viene identificato da $p'$ che è presente in $par$);
				\item $newproc = \lfloor\tuple{p',(\theta,e),q,h}\rfloor_{\Psi'}$ con $\Psi' = \Psi\cup \#_{op}^{par}$ se $\#_{op}^{par}\not\in\Psi$, o altrimenti $\Psi' = \Psi$
			\end{itemize}
		\end{itemize}
		Se $t=l$, allora $\Pi' = \Pi$ anche se $op(par)$ è un'operazione in lettura.
	\end{itemize}
\end{itemize}

Di seguito, al fine di semplificare le regole di riduzione, si assume che la semantica descritta soddisfi la seguente \emph{equivalenza strutturale}:
\[
\begin{array}{ll}
	(\mathit{SC}) & {\displaystyle
		\Gamma;
		\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_{\emptyset}
		\:\comp\: \Pi
		~\equiv~
		\Gamma;\tuple{p,\h,(\theta,e),q}\:\comp\: \Pi
	}
\end{array}
\]
Si può notare che solo il primo dei tipi di rollback sopra indicati è destinato a un ~checkpoint. Questo tipo di checkpoint è introdotto in modo non deterministico dalla regola seguente, dove viene indicata con $\lhh$ la nuova relazione di riduzione che modella i movimenti all'indietro della semantica di rollback:
\[
\begin{array}{ll}
	(\mathit{\ol{Undo}}) & {\displaystyle
		\Gamma;
		\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_{\Psi}
		\:\comp\: \Pi
		\lhh
		\Gamma;\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_{\Psi\cup\{\#_\mathsf{ch}^\mathtt{t}\}}\:\comp\: \Pi
	}
	\\[1ex] & \mbox{if } \mathsf{check}(\theta',e',\mathtt{t}) \mbox{ occurs
		in } \h, ~\mbox{for some $\theta'$ and $e'$}
\end{array}
\]
Solo dopo l'applicazione di questa regola i passaggi possono essere annullati, poiché il calcolo predefinito nella semantica di rollback è in avanti.

Le regole backward della semantica di rollback sono mostrate nelle Figure~\ref{fig:rollsem0},~\ref{fig:rollsem1}~e~\ref{fig:rollsem2}. Si assume che $\Psi\neq\emptyset$ (ma $\Psi'$ potrebbe essere vuoto).

\begin{figure}[h!]
	\footnotesize
	\[
	\hspace{-3ex}
	\begin{array}{r@{~~}l}
		(\mathit{\ol{Seq}}) & {\displaystyle
			\Gamma;
			\lfloor\tuple{p,\tau(\theta,e)\cons\h,(\theta',e'),q}\rfloor_{\Psi}
			\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
			\lhh  \Gamma;\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_{\Psi}\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
		}
		\\[2ex]
		
		(\mathit{\ol{Check}}) & {\displaystyle
			\Gamma;
			\lfloor\tuple{p,\mathsf{check}(\theta,e,\mathtt{t})\cons\h,(\theta',e'),q}\rfloor_{\Psi}
			\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
			\lhh  \Gamma;\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_{\Psi\setminus\{\#_\mathsf{ch}^\mathtt{t}\}}\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
		} 
		\\[2ex]
		
		(\mathit{\ol{Send1}}) & {\displaystyle
			\begin{array}{l}
				\Gamma\cup\{(p',\{v,\k\})\};\lfloor\tuple{p,\mathsf{send}(\theta,e,p',\{v,\k\})\cons\h,(\theta',e'),q}\rfloor_{\Psi}\:\comp\:
				\Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
				\lhh \Gamma;\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_{\Psi} 
				\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}\\
			\end{array}
		}\\[2ex]
		
		(\mathit{\ol{Send2}}) & {\displaystyle
			\begin{array}{l}
				\Gamma;\lfloor\tuple{p,\mathsf{send}(\theta,e,p',\{v,\k\})\cons\h,(\theta',e'),q}\rfloor_{\Psi}\:\comp\:
				\lfloor\tuple{p',\h',(\theta'',e''),q'}\rfloor_{\Psi'}\:\comp\:\Pi;\mathcolorbox{yellow}{\mathsf{M;S}}\\
				\lhh 
				\Gamma;\lfloor\tuple{p,\mathsf{send}(\theta,e,p',\{v,\k\})\cons\h,(\theta',e'),q}\rfloor_{\Psi}\:\comp\:
				\lfloor\tuple{p',\h',(\theta'',e''),q'}\rfloor_{\Psi'\cup\{\#_\mathsf{sch}^\k\}}\:\comp\:
				\Pi;\mathcolorbox{yellow}{\mathsf{M;S}}\\
				\hspace{20ex}\mbox{if}~(p',\{v,\k\})~\mbox{does not
					occur
					in}~\Gamma~\mbox{and}~\#_\mathsf{sch}^{\k}\not\in\Psi'
			\end{array}
		}\\[5ex]
		
		(\mathit{\ol{Receive}}) & {\displaystyle
			\Gamma;\lfloor\tuple{p,\mathsf{rec}(\theta,e,\{v,\k\},q)\cons\h,(\theta',e'), q\backslash\!\!\backslash\{v,\k\}}\rfloor_{\Psi}\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
			\lhh  \Gamma;\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_{\Psi}\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
		}
		\\[2ex]
		
		(\mathit{\ol{Spawn1}}) & {\displaystyle
			\begin{array}{l}
				\Gamma;\lfloor\tuple{p,\mathsf{spawn}(\theta,e,p'')\cons\h,(\theta',e'),q}\rfloor_{\Psi}
				\:\comp\: 
				\lfloor\tuple{\nil,p'',(\theta'',e''),\nil}\rfloor_{\Psi'}
				\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}
				\\
				\hspace{20ex}\lhh
				\Gamma;\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_{\Psi}
				\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}} 
			\end{array}
		}\\[3ex]
		
		(\mathit{\ol{Spawn2}}) & {\displaystyle
			\begin{array}{l}
				\Gamma;\lfloor\tuple{p,\mathsf{spawn}(\theta,e,p'')\cons\h,(\theta,e),q}\rfloor_{\Psi}
				\:\comp\: 
				\lfloor\tuple{p'',\h'',(\theta'',e''),q''}\rfloor_{\Psi'}
				\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}} 
				\\
				\hspace{0ex}\lhh
				\Gamma;\lfloor\tuple{p,\mathsf{spawn}(\theta,e,p'')\cons\h,(\theta,e),q}\rfloor_{\Psi}
				\:\comp\: 
				\lfloor\tuple{p'',\h'',(\theta'',e''),q''}\rfloor_{\Psi'\cup\{\#_\mathsf{sp}\}}
				\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}} \\
				\hspace{20ex}\mbox{if}~\h''\neq\nil \lor q''\neq\nil~\mbox{and}~\#_\mathsf{sp}\not\in\Psi'
			\end{array}
		}\\[4ex]
		
		
		(\mathit{\ol{Self}}) & {\displaystyle
			\Gamma;\lfloor\tuple{p,\mathsf{self}(\theta,e)\cons\h,(\theta',e'),q}\rfloor_{\Psi} 
			\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}} \lhh
			\Gamma;\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_{\Psi} 
			\:\comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}}  
		}\\[2ex]
		
		(\mathit{\ol{Sched}}) & {\displaystyle
			\begin{array}{l}
				\Gamma;\lfloor\tuple{p,\h,(\theta,e),\{v,\k\}\cons q}\rfloor_{\Psi} \: \comp\: \Pi;\mathcolorbox{yellow}{\mathsf{M;S}} \lhh 
				\Gamma\cup(p,\{v,\k\});\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_{\Psi\setminus\{\#_\mathsf{sch}^\k\}}\:\comp\:\Pi;\mathcolorbox{yellow}{\mathsf{M;S}}\\
				\hspace{20ex} %%\mbox{if}~\#_\mathsf{sch}^\k\not\in\Psi
				%%~\mbox{and 
				\mbox{if the topmost $\mathsf{rec}(\ldots)$ item in
					$\h$ (if any) has the}\\ 
				\hspace{20ex}\mbox{form}~\mathsf{rec}(\theta',e',\{v',\k'\},q')~\mbox{with}~q'\backslash\!\!\backslash\{v',\k'\}\neq
				\{v,\k\}\cons q
			\end{array}
		}
	\end{array}
	\]
	\caption{Rollback semantics: backward reduction rules} \label{fig:rollsem0}
\end{figure}

\begin{figure}[h!]
	\footnotesize
	\[
	\hspace{-3ex}
	\begin{array}{l@{~~}l}
		
		
		\mathcolorbox{yellow}{ (\mathit{\ol{SendA1}}) ~~ {\displaystyle
				\begin{array}{l}
					\Gamma\cup\{(p',\{v,\k\})\};\lfloor\tuple{p,\mathsf{sendA}(\theta,e,p',\{v,\k\})\cons\h,(\theta',e'),q}\rfloor_{\Psi}\:\comp\:
					\Pi;\\\mathsf{S'}\cons\mathsf{sendA}(\theta,e,p',\{v,\k\},a,p)\cons\mathsf{S}
					\lhh \Gamma;\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_{\Psi} 
					\:\comp\: \Pi ; \mathsf{S'}\cons\mathsf{S}\\
					Se ~ \forall ~ op ~ \mbox{in scrittura} \in \mathsf{S'} ~  a \centernot\varepsilon op        
					%\mbox{Se in S' non sono presenti operazioni di scrittura sulla mappa che coinvolgono l'atomo a}
				\end{array}
		}}\\[4ex]
		
		\mathcolorbox{yellow}{ (\mathit{\ol{SendA2}}) ~~ {\displaystyle
				\begin{array}{l}
					\Gamma\cup\{(p',\{v,\k\})\};\lfloor\tuple{p,\mathsf{sendA}(\theta,e,p',\{v,\k\})\cons\h,(\theta',e'),q}\rfloor_{\Psi}\:\comp\: \Pi;
					\mathsf{S'}\cons\mathsf{sendA}(\theta,e,p',\{v,\k\},a,p)\cons\mathsf{S}\lhh \\
					\Gamma\cup\{(p',\{v,\k\})\};\lfloor\tuple{p,\mathsf{sendA}(\theta,e,p',\{v,\k\})\cons\h,(\theta,e),q}\rfloor_{\Psi} 
					\:\comp\: \lfloor\Pi \rfloor_{\#_\mathsf{([a],\emptyset),l}^\mathsf{S'}};\\
					\mathsf{S'}\cons\mathsf{sendA}(\theta,e,p',\{v,\k\},a,p)\cons\mathsf{S}\\
					Se ~ \exists ~ op ~ \mbox{in scrittura} \in \mathsf{S'} ~  a~ \varepsilon ~op 
					%\mbox{Se in S' sono presenti operazioni di scrittura sulla mappa che coinvolgono l'atomo a}
				\end{array}
		}}\\[6ex]
		
		
		\mathcolorbox{yellow}{ (\mathit{\ol{SendA3}}) ~~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{sendA}(\theta,e,p',\{v,\k\})\cons\h,(\theta',e'),q}\rfloor_{\Psi}\:\comp\:\lfloor\tuple{p',\h',(\theta'',e''),q'}\rfloor_{\Psi'}\:\comp\:\Pi;\\\mathsf{S'}\cons\mathsf{sendA}(\theta,e,p',\{v,\k\},a,p)\cons\mathsf{S}\\
					\lhh 
					\Gamma;\lfloor\tuple{p,\mathsf{sendA}(\theta,e,p',\{v,\k\})\cons\h,(\theta',e'),q}\rfloor_{\Psi}\:\comp\:\lfloor\tuple{p',\h',(\theta'',e''),q'}\rfloor_{\Psi'\cup\{\#_\mathsf{sch}^\k\}}\:\comp\:
					\Pi;\\
					\mathsf{S'}\cons\mathsf{sendA}(\theta,e,p',\{v,\k\},a,p)\cons\mathsf{S}\\
					\hspace{20ex}\mbox{se}~(p',\{v,\k\})~\mbox{non occorre
						in}~\Gamma~\mbox{e}~\#_\mathsf{sch}^{\k}\not\in\Psi'
				\end{array}
		}}\\[7ex]
		
		\mathcolorbox{yellow}{(\mathit{\ol{SendF1}}) ~~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{sendF1}(\theta,e,p,a)\cons\h,(\theta',e'),q}\rfloor_{\Psi}\:\comp\:
					\Pi;\mathsf{M;S'}\cons \mathsf{sendF1}(\theta,e,p,a)\cons\mathsf{S}\\
					\lhh         \Gamma;\lfloor\tuple{p,\h,(\theta',e'),q}\rfloor_{\Psi}\:\comp\:
					\Pi;
					\mathsf{M;S'}\cons \mathsf{S}\\
					Se ~ \forall ~ op ~ \mbox{in scrittura} \in \mathsf{S'} ~  a \centernot\varepsilon op        
					% \mbox{Se in S' non sono presenti operazioni di scrittura sulla mappa che coinvolgono l'atomo a}
				\end{array}
		}}\\[4ex]
		
		\mathcolorbox{yellow}{(\mathit{\ol{SendF2}}) ~~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{sendF1}(\theta,e,p,a)\cons\h,(\theta',e'),q}\rfloor_{\Psi}\:\comp\:
					\Pi;\mathsf{M;S'}\cons \mathsf{sendF1}(\theta,e,p,a)\cons\mathsf{S}\\
					\lhh         \Gamma;\lfloor\tuple{p,\mathsf{sendF1}(\theta,e,p,a)\cons\h,(\theta',e'),q}\rfloor_{\Psi}\:\comp\:
					\lfloor\Pi\rfloor_{\#_\mathsf{([a],\emptyset),l}^\mathsf{S'}};
					\mathsf{M;S'}\cons \mathsf{sendF1}(\theta,e,p,a)\cons\mathsf{S}\\
					Se ~ \exists ~ op ~ \mbox{in scrittura} \in \mathsf{S'} ~  a~ \varepsilon ~op
					%\mbox{Se in S'  sono presenti operazioni di scrittura sulla mappa che coinvolgono l'atomo a}
				\end{array}
		}}\\[5ex]
		
		\mathcolorbox{yellow}{ (\mathit{\ol{RegisterT1}}) ~~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{regT}(\theta,e,a,p',p)\cons\h,(\theta',e'),q} \rfloor_{\Psi} \comp \Pi;\M\cup(a,p') ; \s'\cons\mathsf{regT}(\theta,e,a,p',p) \cons\s \\
					\lhh  \Gamma;\lfloor\tuple{p,\h,(\theta,e),q} \rfloor_{\Psi}\:\comp\: \Pi;\M;\s'\cons\s\\
					Se ~ \forall ~ op ~ \mbox{in scrittura o lettura} \in \s' ~  a \centernot\varepsilon op ~ \mathsf{o} ~ p' \centernot\varepsilon op
					%\mbox{Se in S' non sono presenti operazioni sulla mappa che coinvolgono il pid p' o l'atomo a}                  
				\end{array}
		}}
		\\[5ex]
		
		\mathcolorbox{yellow}{(\mathit{\ol{RegisterT2}}) ~~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{regT}(\theta,e,a,p',p)\cons\h,(\theta',e'),q} \rfloor_{\Psi} \comp \Pi;\M; \s'\cons\mathsf{regT}(\theta,e,a,p',p) \cons\s \\
					\lhh  \Gamma;\lfloor\tuple{p,\mathsf{regT}(\theta,e,a,p',p)\cons\h,(\theta,e),q} \rfloor_{\Psi}\:\comp\: \lfloor\Pi \rfloor_{\#_\mathsf{([a],[p']),s}^{\s'}};\M;\s'\cons\mathsf{regT}(\theta,e,a,p',p)\cons\s\\
					Se ~ \exists ~ op ~ \mbox{in scrittura o lettura} \in \s' ~  a~ \varepsilon ~ op ~ \mathsf{o} ~ p'~ \varepsilon ~ op
					%\mbox{Se in S' sono presenti operazioni sulla mappa che coinvolgono il pid p' o l'atomo a}                  
				\end{array}
		}}
		\\[5ex]
		
		\mathcolorbox{yellow}{(\mathit{\ol{RegisterF1}}) ~~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{regF1}(\theta,e,a,p',p)\cons\h,(\theta',e'),q}\rfloor_{\Psi}\comp \Pi;
					\M; \s'\cons\mathsf{regF1}(\theta,e,a,p',p) \cons\s \\    
					\hspace{20ex} \lhh  \Gamma;\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_{\Psi}\:\comp\: \Pi;\M;\s'\cons\s\\
					Se ~ \forall ~ op ~ \mbox{in scrittura} \in \s' ~  a \centernot\varepsilon op ~ \mathsf{o} ~ p' \centernot\varepsilon op
					%\mbox{Se in S' non sono presenti operazioni sulla mappa che coinvolgono il pid p' o l'atomo a}                  
				\end{array}
		}}\\[5ex]
		
		\mathcolorbox{yellow}{(\mathit{\ol{RegisterF2}}) ~~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{regF1}(\theta,e,a,p',p)\cons\h,(\theta',e'),q}\rfloor_{\Psi}\comp \Pi;
					\M; \s'\cons\mathsf{regF1}(\theta,e,a,p',p) \cons\s \\    
					\lhh \Gamma;\lfloor\tuple{p,\mathsf{regF1}(\theta,e,a,p',p)\cons\h,(\theta',e'),q}\rfloor_{\Psi}\comp \lfloor\Pi\rfloor_{\#_\mathsf{([a],[p']),l}^{\s'}};
					\M; \s'\cons\mathsf{regF1}(\theta,e,a,p',p) \cons\s \\    
					Se ~ \exists ~ op ~ \mbox{in scrittura} \in \s' ~  a~ \varepsilon ~ op ~ \mathsf{o} ~ p'~ \varepsilon ~ op
					% \mbox{Se in S' sono presenti operazioni sulla mappa che coinvolgono il pid p' o l'atomo a}                  
				\end{array}
		}}\\[5ex]
		
	\end{array}
	\]
	\caption{Rollback semantics: backward reduction rules} \label{fig:rollsem1}
\end{figure}

\begin{figure}[h!]
	\footnotesize
	\[
	\hspace{-3ex}
	\begin{array}{l@{~~}l}
		
		\mathcolorbox{yellow}{ (\mathit{\ol{UnregisterT1}}) ~~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{unregT}(\theta,e,a,p',p)\cons\h,(\theta',e'),q} \rfloor_{\Psi} \comp \Pi;\M\backslash\!\!\backslash(a,p') ; \s'\cons\mathsf{unregT}(\theta,e,a,p',p) \cons\s \\
					\lhh  \Gamma;\lfloor\tuple{p,\h,(\theta,e),q} \rfloor_{\Psi}\:\comp\: \Pi;\M;\s'\cons\s\\
					Se ~ \forall ~ op ~ \mbox{in scrittura o lettura} \in \s' ~  a \centernot\varepsilon op ~ \mathsf{o} ~ p' \centernot\varepsilon op
					%\mbox{Se in S' non sono presenti operazioni sulla mappa che coinvolgono il pid p' o l'atomo a}                  
				\end{array}
		}}
		\\[5ex]
		
		\mathcolorbox{yellow}{ (\mathit{\ol{UnregisterT2}}) ~~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{unregT}(\theta,e,a,p',p)\cons\h,(\theta',e'),q} \rfloor_{\Psi} \comp \Pi;\M; \s'\cons\mathsf{unregT}(\theta,e,a,p',p) \cons\s \\
					\lhh  \Gamma;\lfloor\tuple{p,\mathsf{unregT}(\theta,e,a,p',p)\cons\h,(\theta,e),q} \rfloor_{\Psi}\:\comp\: \lfloor\Pi \rfloor_{\#_\mathsf{([a],[p']),s}^{\s'}};\M;\s'\cons\mathsf{unregT}(\theta,e,a,p',p)\cons\s\\
					Se ~ \exists ~ op ~ \mbox{in scrittura o lettura} \in \s' ~  a~ \varepsilon ~ op ~ \mathsf{o} ~ p'~ \varepsilon ~ op
					%\mbox{Se in S' sono presenti operazioni sulla mappa che coinvolgono il pid p' o l'atomo a}                  
				\end{array}
		}}
		\\[5ex]
		
		\mathcolorbox{yellow}{ (\mathit{\ol{UnregisterF1}}) ~~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{unregF1}(\theta,e,a,p)\cons\h,(\theta',e'),q}\rfloor_{\Psi}\comp \Pi;
					\M; \s'\cons\mathsf{unregF1}(\theta,e,a,p) \cons\s \\    
					\lhh \Gamma;\lfloor\tuple{p,\h,(\theta',e'),q}\rfloor_{\Psi}\comp \Pi;
					\M; \s'\cons\s \\    
					Se ~ \forall ~ op ~ \mbox{in scrittura} \in \s' ~  a \centernot\varepsilon op 
					%\mbox{Se in S' non sono presenti operazioni sulla mappa che coinvolgono l'atomo a}                  
				\end{array}
		}}\\[5ex]
		
		\mathcolorbox{yellow}{(\mathit{\ol{UnregisterF2}}) ~~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{unregF1}(\theta,e,a,p)\cons\h,(\theta',e'),q}\rfloor_{\Psi}\comp \Pi;
					\M; \s'\cons\mathsf{unregF1}(\theta,e,a,p) \cons\s \\    
					\lhh \Gamma;\lfloor\tuple{p,\mathsf{unregF1}(\theta,e,a,p)\cons\h,(\theta',e'),q}\rfloor_{\Psi}\comp \lfloor\Pi\rfloor_{\#_\mathsf{([a],[\emptyset]),l}^{\s'}};
					\M; \s'\cons\mathsf{unregF1}(\theta,e,a,p) \cons\s \\    
					Se ~ \exists ~ op ~ \mbox{in scrittura} \in \s' ~  a~ \varepsilon ~ op
					%\mbox{Se in S' sono presenti operazioni sulla mappa che coinvolgono l'atomo a}                  
				\end{array}
		}}\\[5ex]
		
		\mathcolorbox{yellow}{(\mathit{\ol{Call3-1}}) ~ {\displaystyle
				\begin{array}{l}
					\Gamma;
					\lfloor\tuple{p,\tau\M\M'(\theta,e,p)\cons\h,(\theta',e'),q}\rfloor_\Psi
					\:\comp\: \Pi;\mathsf{M;S' : \tau\M\M'(\theta,e,p):S}
					\\ \lhh \Gamma;\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_\Psi\:\comp\: \Pi;\M;\s'\cons\s\\
					\mbox{Se in S' non sono presenti operazioni di scrittura su elementi presenti in M'}     \end{array}
		}}
		\\[5ex]
		
		\mathcolorbox{yellow}{(\mathit{\ol{Call3-2}}) ~ {\displaystyle
				\begin{array}{l}
					\Gamma;
					\lfloor\tuple{p,\tau\M\M'(\theta,e,p)\cons\h,(\theta',e'),q}\rfloor_\Psi
					\:\comp\: \Pi;\M;\s'\cons\mathsf{\tau\M\M'(\theta,e,p)}\cons\s
					\lhh \\
					\Gamma;
					\lfloor\tuple{p,\tau\M\M'(\theta,e,p)\cons\h,(\theta',e'),q}\rfloor_\Psi
					\:\comp\: \lfloor\Pi\rfloor_{\#_\mathsf{(\M'),l}^\mathsf{S'}};\mathsf{M;S' : \tau\mathsf{MM'}(\theta,e,p):S}\\
					\mbox{Se in S' sono presenti operazioni di scrittura su elementi presenti in M'}     \end{array}
		}}
		\\[5ex]
		
		\mathcolorbox{yellow}{ (\mathit{\ol{Catch}}) ~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{fail}(\theta,e)\cons\h,(\theta,fail),q}\rfloor_\Psi \comp \Pi; \M;\s
					\lhh
					\Gamma;\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_\Psi\comp \Pi; \M;\s
				\end{array}
		}}  \\[2ex]
		
		\mathcolorbox{yellow}{ (\mathit{\ol{End1}}) ~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{end}(\theta,\epsilon,a',p)\cons\h,(\theta,\epsilon),q}\rfloor_\Psi \comp \Pi,
					\M\backslash\!\!\backslash (a' ,p), \s'\cons\mathsf{end}(\theta,\epsilon,a',p)\cons\s
					\lhh  \Gamma;\lfloor\tuple{p,\h,(\theta,\epsilon),q}\rfloor_\Psi\:\comp\: \Pi;\M;\s'\cons\s\\
					Se ~ \forall ~ op ~ \mbox{in scrittura o lettura} \in \s' ~  a' \centernot\varepsilon op ~ \mathsf{o} ~ p \centernot\varepsilon op
					% \mbox{Se in S' non sono presenti operazioni di scrittura e lettura sulla mappa}\\\mbox{ che coinvolgono il pid p o l'atomo a'}                  
					
				\end{array}
				
		}}
		\\[4ex]
		
		\mathcolorbox{yellow}{ (\mathit{\ol{End2}}) ~ {\displaystyle
				\begin{array}{l}
					\Gamma;\lfloor\tuple{p,\mathsf{end}(\theta,\epsilon,a',p)\cons\h,(\theta,\epsilon),q}\rfloor_\Psi\comp \Pi,
					\M, \s'\cons\mathsf{end}(\theta,\epsilon,a',p)\cons\s
					\lhh \\ \Gamma;\lfloor\tuple{p,\mathsf{end}(\theta,\epsilon,a',p)\cons\h,(\theta,\epsilon),q}\rfloor_\Psi\comp \lfloor\Pi \rfloor_{\#_\mathsf{([a'],[p]),s}^{\s'}};
					\M, \s'\cons\mathsf{end}(\theta,\epsilon,a',p)\cons\s\\
					Se ~ \exists ~ op ~ \mbox{in scrittura o lettura} \in \s' ~  a'~ \varepsilon ~ op ~ \mathsf{o} ~ p~ \varepsilon ~ op  			
				\end{array}
				
		}}
		
	
	\end{array}
	\]
	\caption{Rollback semantics: backward reduction rules} \label{fig:rollsem2}
\end{figure}

Si può notare che i rollback fino ai checkpoint vengono generati non deterministicamente dalla regola $\mathit{\ol{Undo}}$, mentre gli altri due tipi di rollback sono generati dalle regole di riduzione backward in un certo ordine per garantire la coerenza causale.\\
 Questo è chiarito dalla discussione seguente, dove si spiegano brevemente le principali differenze rispetto alla semantica backward descritta precedentemente:
\begin{itemize}
	\item Come nella semantica nella Figura~\ref{fig:backwardsem}, l'invio di un messaggio può essere annullato quando il messaggio è ancora nella mailbox globale (regola $\ol{\mathit{Send1}}$). Altrimenti, potrebbe essere necessario applicare prima la regola $\ol{\mathit{Send2}}$ per ``propagare'' la modalità di rollback fino al destinatario del messaggio, in modo che le regole $\ol{\mathit{Sched}}$ e $\ol{\mathit{Send1}}$ possano essere eventualmente applicate.
	
	\item Per l'annullamento della generazione di un processo $p''$, la regola $\ol{\mathit{Spawn1}}$ si applica quando sia la cronologia che le code del processo generato $p''$ sono vuote, eliminando sia l'elemento della cronologia in $p$ che il processo $p''$. Altrimenti, si applica la regola $\ol{\mathit{Spawn2}}$ che propaga la modalità di rollback in modo che, alla fine, la regola $\ol{\mathit{Spawn1}}$ si possa applicare a $p''$.
	
	\item Si osserva che la regola $\ol{\mathit{Sched}}$ richiede la stessa side-condition della semantica incontrollata. Questo è necessario per evitare la commutazione delle regole $\mathit{\ol{Receive}}$ e $\mathit{\ol{Sched}}$.
	
	\item Infine, si può notare che per ogni nuova regola $\lh$ sulla mappa sono state aggiunte due regole $\lhh$: una per il caso in cui in $\s'$ siano presenti operazioni eseguite sugli stessi pid e/o atomi che inseriscono gli operatori di rollback ove necessario, l'altra che effettua effettivamente la regola di rollback dell'operazione, visto che in $\s'$ non sono presenti le regole che non consentono il rollback. 
	
\end{itemize}

La semantica di rollback è modellata dalla relazione $\looparrowright$, che è definita come l'unione della relazione reversibile diretta $\rh$ (Figure~\ref {fig:forwardsem} e \ref {fig:forwardsem1}) e la relazione a ritroso $\lhh$ definita nelle Figure~\ref {fig:rollsem0},~\ref {fig:rollsem1} e~\ref {fig:rollsem2}. Si noti che, in contrasto con la semantica reversibile (non controllata) della Sezione~\ref{sect:semreversibile}, la semantica di rollback data dalla relazione $\looparrowright$ ha meno scelte non deterministiche: tutti i calcoli vengono eseguiti in avanti tranne quando un'azione di rollback richiede alcuni passi all'indietro per ripristinare uno stato precedente di un processo, che può essere propagato ad altri processi al fine di annullare la generazione di un processo o l'invio di un messaggio.\\
Si noti, tuttavia, che oltre all'introduzione dei rollback, è ancora presente un certo livello di non determinismo nelle regole all'indietro della semantica del rollback: da un lato, la selezione del processo quando ci sono diversi rollback in corso è non deterministica e dall'altro, in molti casi, sia la regola $\mathit{\ol{Sched}}$ sia un'altra sono applicabili allo stesso processo. La semantica potrebbe essere resa deterministica utilizzando una particolare strategia per selezionare i processi (es. Round robin) e applicando la regola $\mathit{\ol{Sched}}$ ogniqualvolta possibile (es. dare a $\mathit{\ol{Sched}}$ una priorità più alta rispetto alle restanti regole all'indietro).\\
Si vuole dimostrare di seguito la validità della semantica di rollback. Per farlo, si definisce $\rolldel(s)$ che denota il sistema che risulta da $s$ rimuovendo i rollback in corso; formalmente, $\rolldel(\Gamma;\Pi;\M;\s) = \Gamma; \rolldel'(\Pi);\M;\s$, dove:
\[
\begin{array}{lll}
	\rolldel'(\tuple{p,\h,(\theta,e),q}) & = &
	\tuple{p,\h,(\theta,e),q}\\
	\rolldel'(\lfloor \tuple{p,\h,(\theta,e),q}\rfloor_{\Psi}) & = &
	\tuple{p,\h,(\theta,e),q}\\
	\rolldel'(\tuple{p,\h,(\theta,e),q}\:\comp\:\Pi) & = &
	\tuple{p,\h,(\theta,e),q}\:\comp\:\rolldel'(\Pi)\\
	\rolldel'(\lfloor\tuple{p,\h,(\theta,e),q}\rfloor_{\Psi}\:\comp\:\Pi) & = &
	\tuple{p,\h,(\theta,e),q}\:\comp\:\rolldel'(\Pi)
	\\                                              
\end{array}
\]
Dove si assume che $ \Pi $ non sia vuoto.
Si estende anche la definizione di sistemi iniziali e raggiungibili alla semantica di rollback.

\begin{definition} [Sistemi raggiungibili sotto la semantica di rollback] \label {def:reachableroll} \mbox {} 
	Un sistema è \emph {iniziale} sotto la semantica di rollback se è
	composto da un unico processo con un set vuoto $ \Psi $ di rollback attivi; inoltre, la storia, la coda dei massaggi, la mail-box globale, la storia della mappa e la mappa sono vuote. Un sistema $ s $ è
	\emph {raggiungibile} sotto la semantica di rollback se esiste un sistema
	iniziale $ s_0 $ e una derivazione $ s_0 \looparrowright ^ \ast s $
	utilizzando le regole corrispondenti a un determinato programma.
\end{definition}

\begin{theorem} [Soundness] \label{thm:soundness-rollback}
	Sia $ s $ un sistema raggiungibile con la semantica di rollback. Se
	$ s \looparrowright ^ \ast s '$, allora $ \rolldel (s) \rlh^ \ast \rolldel (s') $.
\end{theorem}
\begin{proof}
	Per le transizioni in avanti la dimostrazione è banale poiché le regole in avanti sono le stesse in entrambe le semantiche e si applicano solo ai processi che non sono in fase di rollback. Per le transizioni all'indietro la dimostrazione è per casi analizzando la regola applicata, tramite l'equivalenza strutturale e l'utilizzo di $\rolldel$:
	\begin{itemize}
		\item Regola $ \mathit {\ol{Undo}} $: l'effetto viene rimosso da $ \rolldel $, quindi un'applicazione di questa regola corrisponde a un file derivazione a passo zero sotto la semantica incontrollata;
		\item Regole $ \mathit {\ol{Seq}} $, $ \mathit {\ol{Check}} $, $ \mathit {\ol {Send1}} $, $ \mathit {\ol{Receive}} $, $ \mathit {\ol{Spawn1}} $, $ \mathit {\ol {Self}} $, $ \mathit {\ol{Sched}} $, $\mathit{\ol{SendA1}}$, $\mathit{\ol{SendF1}}$, $\mathit{\ol{Call3-1}}$, $\mathit{\ol{RegisterT1}}$, $\mathit{\ol{RegisterF1}}$, $\mathit{\ol{UnregisterT1}}$, $\mathit{\ol{UnregisterF1}}$,  $\mathit{\ol{Catch}}$ e $\mathit{\ol{End1}}$:
		corrispondono, rispettivamente, alle regole $ \mathit {\ol{Seq}} $, $ \mathit {\ol{Check}} $, $ \mathit{\ol{Send}} $, $ \mathit {\ol{Receive}} $, $ \mathit {\ol{ Spawn}} $, $ \mathit {\ol{Self}} $, $ \mathit {\ol{Sched}} $, $\mathit{\ol{SendA}}$, $\mathit{\ol{SendF}}$, $\mathit{\ol{Call3}}$, $\mathit{\ol{RegisterT}}$, $\mathit{\ol{RegisterF}}$, $\mathit{\ol{UnregisterT}}$, $\mathit{\ol{UnregisterF}}$,  $\mathit{\ol{Catch}}$ e $\mathit{\ol{End}}$ della semantica incontrollata;
		\item Regole $\mathit{\ol{Send2}}$, $\mathit{\ol{Spawn2}}$, $\mathit{\ol{SendA2}}$, $\mathit{\ol{SendA3}}$, $\mathit{\ol{SendF2}}$, $\mathit{\ol{Call3-2}}$,\\ $\mathit{\ol{RegisterT2}}$, $\mathit{\ol{RegisterF2}}$, $\mathit{\ol{UnregisterT2}}$, $\mathit{\ol{UnregisterF2}}$ e $\mathit{\ol{End2}}$: l'effetto viene rimosso da $ \rolldel $, quindi un'applicazione di una qualsiasi di queste regole corrisponde a una derivazione a passo zero sotto semantica incontrollata. \qedhere 
	\end{itemize}
\end{proof}

Ora si può mostrare la completezza della semantica di rollback a condizione che il processo coinvolto sia in modalità rollback:

\begin{lemma} [Completezza in modalità rollback] \label{lemma:completezza-rollback}
	Sia $ s $ un sistema raggiungibile. Se $ s \lh s '$, allora un qualsiasi sistema $ s_r $ tale che $ \rolldel (s_r) = s $ e dove il processo che ha eseguito la transizione $ s \lh s '$ è in modalità rollback per un insieme non vuoto di rollback. Allora esiste $ s'_r $ tale che $ s_r \lhh s'_r $ e $ \rolldel (s'_r) = s '$.
\end{lemma}
\begin{proof}
	La prova è l'analisi dei casi sulla regola applicata. Ogni passaggio è corrispondente alla regola omonima, ma per $ \mathit{\ol{Send}} $, $ \mathit{\ol{Spawn}} $, $\mathit{\ol{SendA}}$, $\mathit{\ol{SendF}}$, $\mathit{\ol{Call3}}$, $\mathit{\ol{RegisterT}}$, $\mathit{\ol{RegisterF}}$, $\mathit{\ol{UnregisterT}}$, $\mathit{\ol{UnregisterF}}$ e $\mathit{\ol{End}}$  corrispondono rispettivamente le regole $ \mathit {\ol{Send1}} $, $ \mathit {\ol{Spawn1}} $, $\mathit{\ol{SendA1}}$, $\mathit{\ol{SendF1}}$, $\mathit{\ol{Call3-1}}$, $\mathit{\ol{RegisterT1}}$, $\mathit{\ol{RegisterF1}}$, $\mathit{\ol{UnregisterT1}}$, $\mathit{\ol{UnregisterF1}}$ e $\mathit{\ol{End1}}$.
\end{proof}


\clearpage{\pagestyle{empty}\cleardoublepage}
\chapter{Lavori Futuri e Conclusione}

In questa tesi è stata estesa la semantica dell'articolo \cite{Lanese}. Inizialmente è stata descritta l'estensione del linguaggio utilizzato con l'aggiunta delle funzioni: 
\begin{itemize}
	\item \textbf{register}: dati in input atomo e pid, inserisce nella mappa la coppia (atomo,pid) e restituisce l'atomo \textbf{true}. Altrimenti il processo fallisce;
	\item \textbf{unregister}: dato in input un atomo, essa toglie dalla mappa la coppia (atomo,pid) e restituisce l'atomo \textbf{true}. Altrimenti il processo fallisce.
	\item \textbf{registered}: restituisce una lista di tutti gli atomi nella mappa;
	\item \textbf{whereis}: dato in input un atomo restituisce il pid associato, altrimenti otterremo \textbf{undefined}.
\end{itemize}
Inoltre al linguaggio viene aggiunto anche il non terminale $end$ utilizzato per la terminazione di un processo.\\
Successivamente è stata mostrata sia la semantica del linguaggio presentato che quella del sistema. In queste semantiche sono presenti anche le valutazioni delle funzioni aggiunte e dei fallimenti, quest'ultimi sono stati aggiunti per avere un comportamento più simile a quello di Erlang. È stata estesa anche la definizione di transizioni concorrenti in accordo con le nuove regole.\\
Dopo di che è stata introdotta la nozione di semantica reversibile, ovvero una semantica non deterministica che permette di eseguire operazioni all'indietro, descrivendo anche le sue principali caratteristiche.\\ 
Infine è stata descritta la semantica rollback in cui viene descritto un'operatore di rollback che serve per rendere deterministica la semantica reversibile introdotta precedentemente preservando le caratterestiche principali.\\
Come abbiamo già accennato prima nella sezione~\ref{Cauder}, CauDEr supporta un sottoinsieme funzionale del linguaggio Core~Erlang; lo scopo di questo lavoro è stato anche di estendere quel sottoinsieme con feature imperative descritte precedentemente. In altre parole, l'obiettivo è realizzare una nuova versione di CauDEr, partendo dalla versione~\cite{cauderV2}, che sia anche in grado di eseguire il debug di programmi più complessi. I costrutti aggiunti sono: $\mathsf{register}$, $\mathsf{unregister}$, $\mathsf{whereis}$ e $\mathsf{registered}$. L'aggiunta di questi costrutti è stata fedele alla descrizione fatta nella tesi, però sono presenti delle differenze; infatti nelle funzioni ausiliari $\mathsf{EvalM}$, $\mathsf{matchPid}$, $\mathsf{matchMapReg}$ e $\mathsf{matchMapUnreg}$ non è stata passata la mappa come input, per evitare di modificare il codice di tutte le funzioni che dovrebbero chiamare quelle ausiliarie, ma è stato deciso di implementare un attore che avesse accesso alla mappa e che sostituisse le funzioni ausiliarie. Inoltre la storia della mappa in CauDEr non è come quella presentata, per evitare di fare funzioni ad hoc per il confronto fra le varie storie si sono tutte estese con elementi, che non vengono considerati, per avere storie tutte della stessa lunghezza e con lo stesso tipo di elementi.
 \\ 
Riassumendo, seguendo l'approccio in \cite{Lanese} sono state definite le varie semantiche, inclusi i nuovi costrutti, prestando attenzione a preservare la consistenza causale, infine è stato realizzato il debugger.\\
~\\
Possibili lavori futuri su questa tesi sono: l'ulteriore estensione del linguaggio con i costrutti di register globale che richiederebbero l'estensione con la semantica relativa ai nodi. Un'altra possibilità sarebbe quella di estendere la semantica con altre feature imperative come le funzioni legate a \textbf{mnesia}, un database distribuito molto utilizzato nelle applicazioni. La semantica può anche essere estesa tramite l'aggiunta delle eccezzioni, che sono operatori di controllo che non sfruttano il fallimento come side-condition per segnalare un errore come le funzioni aggiunte, e che vengono utilizzate per la gestione dei fallimenti.  \\
Un altro possibile lavoro sarebbe quello di implementare una semantica alternativa a quella presentata in cui, al posto di creare una mappa globale imperativa, si utilizza un attore che la sostituisce. In questo modo non bisognerebbe estendere la semantica; le funzioni sarebbero considerate come dei messaggi inviati all'attore, che corrisponde alla mappa, e i risultati sarebbero dei messaggi inviati dall'attore-mappa al processo che ha invocato la funzione. Dopo di che sarebbe interessante dimostrare l'equivalenza delle due semantiche. Le maggiori difficoltà in questa dimostrazione sarebbero nella gestione dei processi terminati e dei fallimenti, ad esempio nel caso in cui viene deregistrato un processo terminato. Questa difficoltà è presente in quanto in questo lavoro è stata modificata la semantica per gestire la terminazione di processi. 





\clearpage{\pagestyle{empty}\cleardoublepage}
\begin{thebibliography}{}
		
	\bibitem{CoreErlang}
	Richard Carlsson.
	\newblock An introduction to core {E}rlang.
	\newblock In {\em In Proceedings of the PLI'01 Erlang Workshop}, 2001.
	
	\bibitem{Lanese}
	Ivan Lanese, Naoki Nishida, Adri{\'{a}}n Palacios, and Germ{\'{a}}n Vidal.
	\newblock A theory of reversibility for {E}rlang.
	\newblock {\em Journal of Logical and Algebraic Methods in Programming},
	100:71--97, November 2018.
	
	\bibitem{Landauer}
	R.~Landauer.
	\newblock Irreversibility and heat generation in the computing process.
	\newblock {\em {IBM} Journal of Research and Development}, 5(3):183--191, July
	1961.
	
	\bibitem{Bennett}
	C.~H. Bennett.
	\newblock Logical reversibility of computation.
	\newblock {\em {IBM} Journal of Research and Development}, 17(6):525--532,
	November 1973.
	
	\bibitem{Danos}
	Vincent Danos and Jean Krivine.
	\newblock Reversible communicating systems.
	\newblock In {\em {CONCUR} 2004 - Concurrency Theory}, pages 292--307. Springer
	Berlin Heidelberg, 2004.
	
	\bibitem{CMRT13tr}
	R.~Caballero, E.~Mart{\'{\i}}n-Mart{\'{\i}}n, A.~Riesco, and S.~Tamarit.
	\newblock A declarative debugger for concurrent erlang programs (extended
	version).
	\newblock Technical Report SIC-15/13, Dpto.\ Sistemas Inform\'aticos y
	Computaci\'on, Universidad Complutense de Madrid, 2013.
	
	\bibitem{Engblom}
	Engblom, J. (2012, September). 
	\newblock A review of reverse debugging.
	\newblock In System, Software, SoC and Silicon Debug Conference (S4D), 2012 (pp. 1-6). IEEE.
	
	\bibitem{paperCauder}
	I.~Lanese, N.~Nishida, A.~Palacios, and G.~Vidal.
	\newblock {CauDEr}: {A} causal-consistent reversible debugger for {E}rlang.
	\newblock In J.~P. Gallagher and M.~Sulzmann, editors, {\em Proceedings of the
		14th International Symposium on Functional and Logic Programming (FLOPS
		2018)}, volume 10818 of {\em Lecture Notes in Computer Science}, pages
	247--263. Springer-Verlag, Berlin, 2018.
	
		\bibitem{cauder}
	I.~Lanese, N.~Nishida, A.~Palacios, and G.~Vidal.
	\newblock {CauDEr} website.
	\newblock URL: \url{https://github.com/mistupv/cauder}.
	
	\bibitem{cauderV2}
	I.~Lanese, N.~Nishida, A.~Palacios, and G.~Vidal.
	\newblock {CauDEr} website.
	\newblock URL: \url{https://github.com/mistupv/cauder-v2}.
	
	\bibitem{NPV16b}
	N.~Nishida, A.~Palacios, and G.~Vidal.
	\newblock A reversible semantics for {E}rlang.
	\newblock In M.~Hermenegildo and P.~L\'opez-Garc\'{\i}a, editors, {\em Proc.\
		of the 26th International Symposium on Logic-Based Program Synthesis and
		Transformation, LOPSTR 2016}, volume 10184 of {\em LNCS}, pages 259--274.
	Springer, 2017.
	\newblock Preliminary version available from
	\texttt{https://arxiv.org/abs/1608.05521}.

	\bibitem{LMSS11}
	I.~Lanese, C.~A. Mezzina, A.~Schmitt, and J.~Stefani.
	\newblock Controlling reversibility in higher-order pi.
	\newblock In J.~Katoen and B.~K{\"{o}}nig, editors, {\em Proceedings of the
		22nd International Conference on Concurrency Theory ({CONCUR} 2011)}, volume
	6901 of {\em Lecture Notes in Computer Science}, pages 297--311. Springer,
	2011.
	
	\bibitem{GLM14}
	E.~Giachino, I.~Lanese, and C.~A. Mezzina.
	\newblock Causal-consistent reversible debugging.
	\newblock In S.~Gnesi and A.~Rensink, editors, {\em Proc.\ of the 17th
		International Conference on Fundamental Approaches to Software Engineering
		({FASE} 2014)}, volume 8411 of {\em Lecture Notes in Computer Science}, pages
	370--384. Springer, 2014.
	





\end{thebibliography}
\end{document}
